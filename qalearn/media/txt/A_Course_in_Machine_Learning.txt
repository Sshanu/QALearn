A Course inMachine LearningHal Daumé IIICopyright © 2013–2017 Hal Daumé III

Self-published

http://ciml.info/

TODO. . . .

Second printing, January 2017

For my students and teachers.

Often the same.

TABLE OF CONTENTS

About this Book

1 Decision Trees


2 Limits of Learning



3 Geometry and Nearest Neighbors


4 The Perceptron

5 Practical Issues


6 Beyond Binary Classification


7 Linear Models

8 Bias and Fairness


9 Probabilistic Modeling

10 Neural Networks

11 Kernel Methods

12 Learning Theory

13

Ensemble Methods

14

Efficient Learning

15 Unsupervised Learning

16

Expectation Maximization


17

Structured Prediction

18

Imitation Learning



ABOUT THIS BOOK

Machine learning is a broad and fascinating field. Even
today, machine learning technology runs a substantial part of your
life, often without you knowing it. Any plausible approach to artiﬁ-
cial intelligence must involve learning, at some level, if for no other
reason than it’s hard to call a system intelligent if it cannot learn.
Machine learning is also fascinating in its own right for the philo-
sophical questions it raises about what it means to learn and succeed
at tasks.

Machine learning is also a very broad ﬁeld, and attempting to

cover everything would be a pedagogical disaster. It is also so quickly
moving that any book that attempts to cover the latest developments
will be outdated before it gets online. Thus, this book has two goals.
First, to be a gentle introduction to what is a very deep ﬁeld. Second,
to provide readers with the skills necessary to pick up new technol-
ogy as it is developed.

0.1 How to Use this Book

This book is designed to be read linearly, since it’s goal is not to be
a generic reference. That said, once you get through chapter 5, you
can pretty much jump anywhere. When I teach a one-semester un-
dergraduate course, I typically cover the chapter 1-13, sometimes
skipping 7 or 9 or 10 or 12 depending on time and interest. For a
graduate course for students with no prior machine learning back-
ground, I would very quickly blaze through 1-4, then cover the rest,
augmented with some additional reading.

0.2 Why Another Textbook?

The purpose of this book is to provide a gentle and pedagogically orga-
nized introduction to the ﬁeld. This is in contrast to most existing ma-
chine learning texts, which tend to organize things topically, rather

7

1 Mitchell 1997

than pedagogically (an exception is Mitchell’s book1, but unfortu-
nately that is getting more and more outdated). This makes sense for
researchers in the ﬁeld, but less sense for learners. A second goal of
this book is to provide a view of machine learning that focuses on
ideas and models, not on math. It is not possible (or even advisable)
to avoid math. But math should be there to aid understanding, not
hinder it. Finally, this book attempts to have minimal dependencies,
so that one can fairly easily pick and choose chapters to read. When
dependencies exist, they are listed at the start of the chapter.

The audience of this book is anyone who knows differential calcu-
lus and discrete math, and can program reasonably well. (A little bit
of linear algebra and probability will not hurt.) An undergraduate in
their fourth or ﬁfth semester should be fully capable of understand-
ing this material. However, it should also be suitable for ﬁrst year
graduate students, perhaps at a slightly faster pace.

0.3 Organization and Auxilary Material

There is an associated web page, http://ciml.info/, which contains
an online copy of this book, as well as associated code and data. It
also contains errata. Please submit bug reports on github: github.com/
hal3/ciml.

0.4 Acknowledgements

Acknowledgements: I am indebted to many people for this book.
My teachers, especially Rami Grossberg (from whom the title of this
book was borrowed) and Stefan Schaal. Students who have taken
machine learning from me over the past ten years, including those
who suffered through the initial versions of the class before I ﬁgured
out how to teach it. Especially Scott Alfeld, Josh de Bever, Cecily
Heiner, Jeffrey Ferraro, Seth Juarez, John Moeller, JT Olds, Piyush
Rai. People who have helped me edit, and who have submitted bug
reports, including TODO. . . , but also check github for the latest list
of contributors!

1 | DECISION TREES

Learning Objectives:
• Explain the difference between

memorization and generalization.

• Implement a decision tree classiﬁer.
• Take a concrete task and cast it as a
learning problem, with a formal no-
tion of input space, features, output
space, generating distribution and
loss function.

Dependencies: None.

The words printed here are concepts.
You must go through the experiences.

– Carl Frederick

At a basic level, machine learning is about predicting the future
based on the past. For instance, you might wish to predict how much
a user Alice will like a movie that she hasn’t seen, based on her rat-
ings of movies that she has seen. This prediction could be based on
many factors of the movies: their category (drama, documentary,
etc.), the language, the director and actors, the production company,
etc. In general, this means making informed guesses about some un-
observed property of some object, based on observed properties of
that object.

The ﬁrst question we’ll ask is: what does it mean to learn? In

order to develop learning machines, we must know what learning
actually means, and how to determine success (or failure). You’ll see
this question answered in a very limited learning setting, which will
be progressively loosened and adapted throughout the rest of this
book. For concreteness, our focus will be on a very simple model of
learning called a decision tree.

1.1 What Does it Mean to Learn?

Alice has just begun taking a course on machine learning. She knows
that at the end of the course, she will be expected to have “learned”
all about this topic. A common way of gauging whether or not she
has learned is for her teacher, Bob, to give her a exam. She has done
well at learning if she does well on the exam.

But what makes a reasonable exam? If Bob spends the entire

semester talking about machine learning, and then gives Alice an
exam on History of Pottery, then Alice’s performance on this exam
will not be representative of her learning. On the other hand, if the
exam only asks questions that Bob has answered exactly during lec-
tures, then this is also a bad test of Alice’s learning, especially if it’s
an “open notes” exam. What is desired is that Alice observes speciﬁc
examples from the course, and then has to answer new, but related
questions on the exam. This tests whether Alice has the ability to

generalize. Generalization is perhaps the most central concept in
machine learning.

As a concrete example, consider a course recommendation system

for undergraduate computer science students. We have a collection
of students and a collection of courses. Each student has taken, and
evaluated, a subset of the courses. The evaluation is simply a score
from −2 (terrible) to +2 (awesome). The job of the recommender
system is to predict how much a particular student (say, Alice) will
like a particular course (say, Algorithms).

Given historical data from course ratings (i.e., the past) we are
trying to predict unseen ratings (i.e., the future). Now, we could
be unfair to this system as well. We could ask it whether Alice is
likely to enjoy the History of Pottery course. This is unfair because
the system has no idea what History of Pottery even is, and has no
prior experience with this course. On the other hand, we could ask
it how much Alice will like Artiﬁcial Intelligence, which she took
last year and rated as +2 (awesome). We would expect the system to
predict that she would really like it, but this isn’t demonstrating that
the system has learned: it’s simply recalling its past experience. In
the former case, we’re expecting the system to generalize beyond its
experience, which is unfair. In the latter case, we’re not expecting it
to generalize at all.

This general set up of predicting the future based on the past is

at the core of most machine learning. The objects that our algorithm
will make predictions about are examples. In the recommender sys-
tem setting, an example would be some particular Student/Course
pair (such as Alice/Algorithms). The desired prediction would be the
rating that Alice would give to Algorithms.

To make this concrete, Figure 1.1 shows the general framework of
induction. We are given training data on which our algorithm is ex-
pected to learn. This training data is the examples that Alice observes
in her machine learning course, or the historical ratings data for
the recommender system. Based on this training data, our learning
algorithm induces a function f that will map a new example to a cor-
responding prediction. For example, our function might guess that
f (Alice/Machine Learning) might be high because our training data
said that Alice liked Artiﬁcial Intelligence. We want our algorithm
to be able to make lots of predictions, so we refer to the collection
of examples on which we will evaluate our algorithm as the test set.
The test set is a closely guarded secret: it is the ﬁnal exam on which
our learning algorithm is being tested. If our algorithm gets to peek
at it ahead of time, it’s going to cheat and do better than it should.
The goal of inductive machine learning is to take some training

data and use it to induce a function f . This function f will be evalu-

decision trees

9

Figure 1.1: The general supervised ap-
proach to machine learning: a learning
algorithm reads in training data and
computes a learned function f . This
function can then automatically label
future text examples.

?

Why is it bad if the learning algo-
rithm gets to peek at the test data?

known labelstrainingdatalearningalgorithmf?testexamplepredictedlabel10 a course in machine learning

ated on the test data. The machine learning algorithm has succeeded
if its performance on the test data is high.

1.2 Some Canonical Learning Problems

There are a large number of typical inductive learning problems.
The primary difference between them is in what type of thing they’re
trying to predict. Here are some examples:

Regression: trying to predict a real value. For instance, predict the

value of a stock tomorrow given its past performance. Or predict
Alice’s score on the machine learning ﬁnal exam based on her
homework scores.

Binary Classiﬁcation: trying to predict a simple yes/no response.
For instance, predict whether Alice will enjoy a course or not.
Or predict whether a user review of the newest Apple product is
positive or negative about the product.

Multiclass Classiﬁcation: trying to put an example into one of a num-
ber of classes. For instance, predict whether a news story is about
entertainment, sports, politics, religion, etc. Or predict whether a
CS course is Systems, Theory, AI or Other.

Ranking: trying to put a set of objects in order of relevance. For in-

stance, predicting what order to put web pages in, in response to a
user query. Or predict Alice’s ranked preferences over courses she
hasn’t taken.

The reason that it is convenient to break machine learning prob-
lems down by the type of object that they’re trying to predict has to
do with measuring error. Recall that our goal is to build a system
that can make “good predictions.” This begs the question: what does
it mean for a prediction to be “good?” The different types of learning
problems differ in how they deﬁne goodness. For instance, in regres-
sion, predicting a stock price that is off by $0.05 is perhaps much
better than being off by $200.00. The same does not hold of multi-
class classiﬁcation. There, accidentally predicting “entertainment”
instead of “sports” is no better or worse than predicting “politics.”

1.3 The Decision Tree Model of Learning

The decision tree is a classic and natural model of learning. It is
closely related to the fundamental computer science notion of “di-
vide and conquer.” Although decision trees can be applied to many

?

For each of these types of canon-
ical machine learning problems,
come up with one or two concrete
examples.

learning problems, we will begin with the simplest case: binary clas-
siﬁcation.

Suppose that your goal is to predict whether some unknown user
will enjoy some unknown course. You must simply answer “yes” or
“no.” In order to make a guess, you’re allowed to ask binary ques-
tions about the user/course under consideration. For example:

You: Is the course under consideration in Systems?
Me: Yes
You: Has this student taken any other Systems courses?
Me: Yes
You: Has this student liked most previous Systems courses?
Me: No
You: I predict this student will not like this course.
The goal in learning is to ﬁgure out what questions to ask, in what

order to ask them, and what answer to predict once you have asked
enough questions.

The decision tree is so-called because we can write our set of ques-

tions and guesses in a tree format, such as that in Figure 1.2. In this
ﬁgure, the questions are written in the internal tree nodes (rectangles)
and the guesses are written in the leaves (ovals). Each non-terminal
node has two children: the left child speciﬁes what to do if the an-
swer to the question is “no” and the right child speciﬁes what to do if
it is “yes.”

In order to learn, I will give you training data. This data consists
of a set of user/course examples, paired with the correct answer for
these examples (did the given user enjoy the given course?). From
this, you must construct your questions. For concreteness, there is a
small data set in Table 1 in the Appendix of this book. This training
data consists of 20 course rating examples, with course ratings and
answers to questions that you might ask about this pair. We will
interpret ratings of 0, +1 and +2 as “liked” and ratings of −2 and −1
as “hated.”

In what follows, we will refer to the questions that you can ask as
features and the responses to these questions as feature values. The
rating is called the label. An example is just a set of feature values.
And our training data is a set of examples, paired with labels.

There are a lot of logically possible trees that you could build,
even over just this small number of features (the number is in the
millions). It is computationally infeasible to consider all of these to
try to choose the “best” one. Instead, we will build our decision tree
greedily. We will begin by asking:

If I could only ask one question, what question would I ask?
You want to ﬁnd a feature that is most useful in helping you guess

whether this student will enjoy this course. A useful way to think

decision trees

11

Figure 1.2: A decision tree for a course
recommender system, from which the
in-text “dialog” is drawn.

Figure 1.3: A histogram of labels for (a)
the entire data set; (b-e) the examples
in the data set for each value of the ﬁrst
four features.

isSystems?takenOtherSys?morning?likedOtherSys?likenahnahlikelikenonononoyesyesyesyesoverall:easy:AI:systems:theory:60%40%likenah60%40%60%40%yesno82%18%33%67%yesno20%80%100%0%yesno80%20%40%60%yesno12 a course in machine learning

about this is to look at the histogram of labels for each feature. 1
This is shown for the ﬁrst four features in Figure 1.3. Each histogram
shows the frequency of “like”/“hate” labels for each possible value
of an associated feature. From this ﬁgure, you can see that asking
the ﬁrst feature is not useful: if the value is “no” then it’s hard to
guess the label; similarly if the answer is “yes.” On the other hand,
asking the second feature is useful: if the value is “no,” you can be
pretty conﬁdent that this student will hate this course; if the answer
is “yes,” you can be pretty conﬁdent that this student will like this
course.

More formally, you will consider each feature in turn. You might

consider the feature “Is this a System’s course?” This feature has two
possible value: no and yes. Some of the training examples have an
answer of “no” – let’s call that the “NO” set. Some of the training
examples have an answer of “yes” – let’s call that the “YES” set. For
each set (NO and YES) we will build a histogram over the labels.
This is the second histogram in Figure 1.3. Now, suppose you were
to ask this question on a random example and observe a value of
“no.” Further suppose that you must immediately guess the label for
this example. You will guess “like,” because that’s the more preva-
lent label in the NO set (actually, it’s the only label in the NO set).
Alternatively, if you receive an answer of “yes,” you will guess “hate”
because that is more prevalent in the YES set.

So, for this single feature, you know what you would guess if you
had to. Now you can ask yourself: if I made that guess on the train-
ing data, how well would I have done? In particular, how many ex-
amples would I classify correctly? In the NO set (where you guessed
“like”) you would classify all 10 of them correctly. In the YES set
(where you guessed “hate”) you would classify 8 (out of 10) of them
correctly. So overall you would classify 18 (out of 20) correctly. Thus,
we’ll say that the score of the “Is this a System’s course?” question is
18/20.

You will then repeat this computation for each of the available

features to us, compute the scores for each of them. When you must
choose which feature consider ﬁrst, you will want to choose the one
with the highest score.

But this only lets you choose the ﬁrst feature to ask about. This
is the feature that goes at the root of the decision tree. How do we
choose subsequent features? This is where the notion of divide and
conquer comes in. You’ve already decided on your ﬁrst feature: “Is
this a Systems course?” You can now partition the data into two parts:
the NO part and the YES part. The NO part is the subset of the data
on which value for this feature is “no”; the YES half is the rest. This
is the divide step.

1 A colleague related the story of
getting his 8-year old nephew to
guess a number between 1 and 100.
His nephew’s ﬁrst four questions
were: Is it bigger than 20? (YES) Is
it even? (YES) Does it have a 7 in it?
(NO) Is it 80? (NO). It took 20 more
questions to get it, even though 10
should have been sufﬁcient. At 8,
the nephew hadn’t quite ﬁgured out
how to divide and conquer. http:
//blog.computationalcomplexity.
org/2007/04/
getting-8-year-old-interested-in.
html.

?

How many training examples
would you classify correctly for
each of the other three features
from Figure 1.3?

decision trees

13

return Leaf(guess)

Algorithm 1 DecisionTreeTrain(data, remaining features)
1: guess ← most frequent answer in data
2: if the labels in data are unambiguous then
3:
4: else if remaining features is empty then
5:
6: else
7:

return Leaf(guess)
for all f ∈ remaining features do

NO ← the subset of data on which f =no
YES ← the subset of data on which f =yes
score[f ] ← # of majority vote answers in NO
+ # of majority vote answers in YES

// default answer for this data

// base case: no need to split further

// base case: cannot split further
// we need to query more features

// the accuracy we would get if we only queried on f

end for
f ← the feature with maximal score(f )
NO ← the subset of data on which f =no
YES ← the subset of data on which f =yes
left ← DecisionTreeTrain(NO, remaining features \ {f})
right ← DecisionTreeTrain(YES, remaining features \ {f})
return Node(f , left, right)

18:
19: end if

8:

9:

10:

11:

12:

13:

14:

15:

16:

17:

5:

6:

7:

Algorithm 2 DecisionTreeTest(tree, test point)
1: if tree is of the form Leaf(guess) then
2:
3: else if tree is of the form Node(f , left, right) then
4:

if f = no in test point then

return guess

return DecisionTreeTest(left, test point)

else

return DecisionTreeTest(right, test point)

end if

8:
9: end if

The conquer step is to recurse, and run the same routine (choosing
the feature with the highest score) on the NO set (to get the left half
of the tree) and then separately on the YES set (to get the right half of
the tree).

At some point it will become useless to query on additional fea-

tures. For instance, once you know that this is a Systems course,
you know that everyone will hate it. So you can immediately predict
“hate” without asking any additional questions. Similarly, at some
point you might have already queried every available feature and still
not whittled down to a single answer. In both cases, you will need to
create a leaf node and guess the most prevalent answer in the current
piece of the training data that you are looking at.

Putting this all together, we arrive at the algorithm shown in Al-
gorithm 1.3.2 This function, DecisionTreeTrain takes two argu-

2 There are more nuanced algorithms
for building decision trees, some of
which are discussed in later chapters of
this book. They primarily differ in how
they compute the score function.

14 a course in machine learning

ments: our data, and the set of as-yet unused features. It has two
base cases: either the data is unambiguous, or there are no remaining
features. In either case, it returns a Leaf node containing the most
likely guess at this point. Otherwise, it loops over all remaining fea-
tures to ﬁnd the one with the highest score. It then partitions the data
into a NO/YES split based on the best feature. It constructs its left
and right subtrees by recursing on itself. In each recursive call, it uses
one of the partitions of the data, and removes the just-selected feature
from consideration.

The corresponding prediction algorithm is shown in Algorithm 1.3.

This function recurses down the decision tree, following the edges
speciﬁed by the feature values in some test point. When it reaches a
leaf, it returns the guess associated with that leaf.

1.4 Formalizing the Learning Problem

As you’ve seen, there are several issues that we must take into ac-
count when formalizing the notion of learning.

• The performance of the learning algorithm should be measured on

unseen “test” data.

• The way in which we measure performance should depend on the

problem we are trying to solve.

• There should be a strong relationship between the data that our
algorithm sees at training time and the data it sees at test time.

In order to accomplish this, let’s assume that someone gives us a
loss function, (cid:96)(·,·), of two arguments. The job of (cid:96) is to tell us how
“bad” a system’s prediction is in comparison to the truth. In particu-
lar, if y is the truth and ˆy is the system’s prediction, then (cid:96)(y, ˆy) is a
measure of error.

For three of the canonical tasks discussed above, we might use the

following loss functions:
Regression: squared loss (cid:96)(y, ˆy) = (y − ˆy)2

or absolute loss (cid:96)(y, ˆy) = |y − ˆy|.

Binary Classiﬁcation: zero/one loss (cid:96)(y, ˆy) =

Multiclass Classiﬁcation: also zero/one loss.

(cid:40)

if y = ˆy

0
1 otherwise

Note that the loss function is something that you must decide on

based on the goals of learning.

Now that we have deﬁned our loss function, we need to consider

where the data (training and test) comes from. The model that we

?

Is Algorithm 1.3 guaranteed to
terminate?

This notation means that the loss is zero
if the prediction is correct and is one
otherwise.

?

Why might it be a bad idea to use
zero/one loss to measure perfor-
mance for a regression problem?

decision trees

15

MATH REVIEW | EXPECTATED VALUES
(x,y)∼D[(cid:96)(y, f (x))] for the expected loss. Expectation means “average.” This is saying “if you
We write E
drew a bunch of (x, y) pairs independently at random from D, what would your average loss be?More
formally, if D is a discrete probability distribution, then this expectation can be expanded as:

E

(x,y)∼D[(cid:96)(y, f (x))] = ∑
(x,y)∈D

[D(x, y)(cid:96)(y, f (x))]

(1.1)

This is exactly the weighted average loss over the all (x, y) pairs in D, weighted by their probability,
D(x, y). If D is a ﬁnite discrete distribution, for instance deﬁned by a ﬁnite data set {(x1, y1), . . . , (xN, yN)
that puts equal weight on each example (probability 1/N), then we get:

E

(x,y)∼D[(cid:96)(y, f (x))] = ∑
(x,y)∈D
N∑

=

[D(xn, yn)(cid:96)(yn, f (xn))]

[D(x, y)(cid:96)(y, f (x))]

deﬁnition of expectation

n=1

N∑

n=1
1
N

[

1
N
N∑

n=1

=

=

(cid:96)(yn, f (xn))]

[(cid:96)(yn, f (xn))]

D is discrete and ﬁnite

deﬁnition of D

rearranging terms

(1.2)

(1.3)

(1.4)

(1.5)

Which is exactly the average loss on that dataset.

The most important thing to remember is that there are two equivalent ways to think about expections:
(1) The expectation of some function g is the weighted average value of g, where the weights are given by
the underlying probability distribution. (2) The expectation of some function g is your best guess of the
value of g if you were to draw a single item from the underlying probability distribution.

Figure 1.4:

will use is the probabilistic model of learning. Namely, there is a prob-
ability distribution D over input/output pairs. This is often called
the data generating distribution. If we write x for the input (the
user/course pair) and y for the output (the rating), then D is a distri-
bution over (x, y) pairs.

A useful way to think about D is that it gives high probability to
reasonable (x, y) pairs, and low probability to unreasonable (x, y)
pairs. A (x, y) pair can be unreasonable in two ways. First, x might
be an unusual input. For example, a x related to an “Intro to Java”
course might be highly probable; a x related to a “Geometric and
Solid Modeling” course might be less probable. Second, y might
be an unusual rating for the paired x. For instance, if Alice were to
take AI 100 times (without remembering that she took it before!),
she would give the course a +2 almost every time. Perhaps some

16 a course in machine learning

semesters she might give a slightly lower score, but it would be un-
likely to see x =Alice/AI paired with y = −2.
It is important to remember that we are not making any assump-
tions about what the distribution D looks like. (For instance, we’re
not assuming it looks like a Gaussian or some other, common distri-
bution.) We are also not assuming that we know what D is. In fact,
if you know a priori what your data generating distribution is, your
learning problem becomes signiﬁcantly easier. Perhaps the hardest
thing about machine learning is that we don’t know what D is: all we
get is a random sample from it. This random sample is our training
data.

Our learning problem, then, is deﬁned by two quantities:

1. The loss function (cid:96), which captures our notion of what is important

to learn.

2. The data generating distribution D, which deﬁnes what sort of

data we expect to see.

?

Consider the following prediction
task. Given a paragraph written
about a course, we have to predict
whether the paragraph is a positive
or negative review of the course.
(This is the sentiment analysis prob-
lem.) What is a reasonable loss
function? How would you deﬁne
the data generating distribution?

We are given access to training data, which is a random sample of

input/output pairs drawn from D. Based on this training data, we
need to induce a function f that maps new inputs ˆx to corresponding
prediction ˆy. The key property that f should obey is that it should do
well (as measured by (cid:96)) on future examples that are also drawn from
D. Formally, it’s expected loss  over D with repsect to (cid:96) should be
as small as possible:

(x,y)∼D(cid:2)(cid:96)(y, f (x))(cid:3) = ∑

 (cid:44) E

D(x, y)(cid:96)(y, f (x))

(1.6)

(x,y)

The difﬁculty in minimizing our expected loss from Eq (1.6) is
that we don’t know what D is! All we have access to is some training
data sampled from it! Suppose that we denote our training data
set by D. The training data consists of N-many input/output pairs,
(x1, y1), (x2, y2), . . . , (xN, yN). Given a learned function f , we can
compute our training error, ˆ:

ˆ (cid:44) 1
N

N∑

n=1

(cid:96)(yn, f (xn))

(1.7)

That is, our training error is simply our average error over the train-

ing data.

Of course, we can drive ˆ to zero by simply memorizing our train-

ing data. But as Alice might ﬁnd in memorizing past exams, this
might not generalize well to a new exam!

This is the fundamental difﬁculty in machine learning: the thing

we have access to is our training error, ˆ. But the thing we care about

?

(x,y)∼D

(cid:2)(cid:96)(y, f (x))(cid:3), by thinking

Verify by calculation that we
can write our training error as
E
of D as a distribution that places
probability 1/N to each example in
D and probability 0 on everything
else.

decision trees

17

minimizing is our expected error . In order to get the expected error
down, our learned function needs to generalize beyond the training
data to some future data that it might not have seen yet!

So, putting it all together, we get a formal deﬁnition of induction
machine learning: Given (i) a loss function (cid:96) and (ii) a sample D
from some unknown distribution D, you must compute a function
f that has low expected error  over D with respect to (cid:96).

A very important comment is that we should never expect a ma-
chine learning algorithm to generalize beyond the data distribution
it has seen at training time. In a famous—if posssibly apocryphal—
example from the 1970s, the US Government wanted to train a clas-
siﬁer to distinguish between US tanks and Russian tanks. They col-
lected a training and test set, and managed to build a classiﬁer with
nearly 100% accuracy on that data. But when this classiﬁer was run
in the “real world”, it failed miserably. It had not, in fact, learned
to distinguish between US tanks and Russian tanks, but rather just
between clear photos and blurry photos. In this case, there was a bias
in the training data (due to how the training data was collected) that
caused the learning algorithm to learn something other than what we
were hoping for. We will return to this issue in Chapter 8; for now,
simply remember that the distribution D for training data must match
the distribution D for the test data.

1.5 Chapter Summary and Outlook

At this point, you should be able to use decision trees to do machine
learning. Someone will give you data. You’ll split it into training,
development and test portions. Using the training and development
data, you’ll ﬁnd a good value for maximum depth that trades off
between underﬁtting and overﬁtting. You’ll then run the resulting
decision tree model on the test data to get an estimate of how well
you are likely to do in the future.

You might think: why should I read the rest of this book? Aside
from the fact that machine learning is just an awesome fun ﬁeld to
learn about, there’s a lot left to cover. In the next two chapters, you’ll
learn about two models that have very different inductive biases than
decision trees. You’ll also get to see a very useful way of thinking
about learning: the geometric view of data. This will guide much of
what follows. After that, you’ll learn how to solve problems more
complicated that simple binary classiﬁcation. (Machine learning
people like binary classiﬁcation a lot because it’s one of the simplest
non-trivial problems that we can work on.) After that, things will
diverge: you’ll learn about ways to think about learning as a formal
optimization problem, ways to speed up learning, ways to learn

18 a course in machine learning

without labeled data (or with very little labeled data) and all sorts of
other fun topics.

But throughout, we will focus on the view of machine learning

that you’ve seen here. You select a model (and its associated induc-
tive biases). You use data to ﬁnd parameters of that model that work
well on the training data. You use development data to avoid under-
ﬁtting and overﬁtting. And you use test data (which you’ll never look
at or touch, right?) to estimate future model performance. Then you
conquer the world.

1.6 Further Reading

In our discussion of decision trees, we used misclassiﬁcation rate for
selecting features. While simple and intuitive, misclassiﬁcation rate
has problems. There has been a signiﬁcant amount of work that
considers more advanced splitting criteria; the most popular is ID3,
based on the mutual information quantity from information the-
ory. We have also only considered a very simple mechanism for
controlling inductive bias: limiting the depth of the decision tree.
Again, there are more advanced “tree pruning” techniques that typ-
ically operate by growing deep trees and then pruning back some
of the branches. These approaches have the advantage that differ-
ent branches can have different depths, accounting for the fact that
the amount of data that gets passed down each branch might differ
dramatically3.

3 Quinlan 1986

2 | LIMITS OF LEARNING

Learning Objectives:
• Deﬁne “inductive bias” and recog-

nize the role of inductive bias in
learning.

• Illustrate how regularization trades
off between underﬁtting and overﬁt-
ting.

• Evaluate whether a use of test data

is “cheating” or not.

Dependencies: None.

Our lives sometimes depend on computers performing as pre-
dicted.

– Philip Emeagwali

Machine learning is a very general and useful framework,
but it is not “magic” and will not always work. In order to better
understand when it will and when it will not work, it is useful to
formalize the learning problem more. This will also help us develop
debugging strategies for learning algorithms.

2.1 Data Generating Distributions

Our underlying assumption for the majority of this book is that
learning problems are characterized by some unknown probability
distribution D over input/output pairs (x, y) ∈ X×Y. Suppose that
someone told you what D was. In particular, they gave you a Python
function computeD that took two inputs, x and y, and returned the
probability of that x, y pair under D. If you had access to such a func-
tion, classiﬁcation becomes simple. We can deﬁne the Bayes optimal
classiﬁer as the classiﬁer that, for any test input ˆx, simply returns the
ˆy that maximizes computeD( ˆx, ˆy), or, more formally:

f (BO)( ˆx) = arg max

ˆy∈Y D( ˆx, ˆy)

(2.1)

This classiﬁer is optimal in one speciﬁc sense: of all possible classiﬁers,
it achieves the smallest zero/one error.

Theorem 1 (Bayes Optimal Classiﬁer). The Bayes Optimal Classiﬁer
f (BO) achieves minimal zero/one error of any deterministic classiﬁer.

This theorem assumes that you are comparing against deterministic
classiﬁers. You can actually prove a stronger result that f (BO) is opti-
mal for randomized classiﬁers as well, but the proof is a bit messier.
However, the intuition is the same: for a given x, f (BO) chooses the
label with highest probability, thus minimizing the probability that it
makes an error.

Proof of Theorem 1. Consider some other classiﬁer g that claims to
be better than f (BO). Then, there must be some x on which g(x) (cid:54)=

20 a course in machine learning

f (BO)(x). Fix such an x. Now, the probability that f (BO) makes an error
on this particular x is 1 − D(x, f (BO)(x)) and the probability that g
makes an error on this x is 1 − D(x, g(x)). But f (BO) was chosen in
such a way to maximize D(x, f (BO)(x)), so this must be greater than
D(x, g(x)). Thus, the probability that f (BO) errs on this particular x is
smaller than the probability that g errs on it. This applies to any x for
which f (BO)(x) (cid:54)= g(x) and therefore f (BO) achieves smaller zero/one
error than any g.

The Bayes error rate (or Bayes optimal error rate) is the error

rate of the Bayes optimal classiﬁer. It is the best error rate you can
ever hope to achieve on this classiﬁcation problem (under zero/one
loss). The take-home message is that if someone gave you access to
the data distribution, forming an optimal classiﬁer would be trivial.
Unfortunately, no one gave you this distribution, so we need to ﬁgure
out ways of learning the mapping from x to y given only access to a
training set sampled from D, rather than D itself.

2.2

Inductive Bias: What We Know Before the Data Arrives

In Figure 2.1 you’ll ﬁnd training data for a binary classiﬁcation prob-
lem. The two labels are “A” and “B” and you can see four examples
for each label. Below, in Figure 2.2, you will see some test data. These
images are left unlabeled. Go through quickly and, based on the
training data, label these images. (Really do it before you read fur-
ther! I’ll wait!)

Most likely you produced one of two labelings: either ABBA or

AABB. Which of these solutions is right? The answer is that you can-
not tell based on the training data. If you give this same example
to 100 people, 60 − 70 of them come up with the ABBA prediction
and 30 − 40 come up with the AABB prediction. Why? Presumably
because the ﬁrst group believes that the relevant distinction is be-
tween “bird” and “non-bird” while the second group believes that
the relevant distinction is between “ﬂy” and “no-ﬂy.”

This preference for one distinction (bird/non-bird) over another
(ﬂy/no-ﬂy) is a bias that different human learners have. In the con-
text of machine learning, it is called inductive bias: in the absense of
data that narrow down the relevant concept, what type of solutions
are we more likely to prefer? Two thirds of people seem to have an
inductive bias in favor of bird/non-bird, and one third seem to have
an inductive bias in favor of ﬂy/no-ﬂy.

Throughout this book you will learn about several approaches to

machine learning. The decision tree model is the ﬁrst such approach.
These approaches differ primarily in the sort of inductive bias that

Figure 2.1: Training data for a binary
classiﬁcation problem.

Figure 2.2: Test data for the same
classiﬁcation problem.

?

It is also possible that the correct
classiﬁcation on the test data is
ABAB. This corresponds to the bias
“is the background in focus.” Some-
how no one seems to come up with
this classiﬁcation rule.

class AclassBlimits of learning 21

they exhibit.

Consider a variant of the decision tree learning algorithm. In this
variant, we will not allow the trees to grow beyond some pre-deﬁned
maximum depth, d. That is, once we have queried on d-many fea-
tures, we cannot query on any more and must just make the best
guess we can at that point. This variant is called a shallow decision
tree.

The key question is: What is the inductive bias of shallow decision
trees? Roughly, their bias is that decisions can be made by only look-
ing at a small number of features. For instance, a shallow decision
tree would be very good at learning a function like “students only
like AI courses.” It would be very bad at learning a function like “if
this student has liked an odd number of their past courses, they will
like the next one; otherwise they will not.” This latter is the parity
function, which requires you to inspect every feature to make a pre-
diction. The inductive bias of a decision tree is that the sorts of things
we want to learn to predict are more like the ﬁrst example and less
like the second example.

2.3 Not Everything is Learnable

Although machine learning works well—perhaps astonishingly
well—in many cases, it is important to keep in mind that it is not
magical. There are many reasons why a machine learning algorithm
might fail on some learning task.

There could be noise in the training data. Noise can occur both

at the feature level and at the label level. Some features might corre-
spond to measurements taken by sensors. For instance, a robot might
use a laser range ﬁnder to compute its distance to a wall. However,
this sensor might fail and return an incorrect value. In a sentiment
classiﬁcation problem, someone might have a typo in their review of
a course. These would lead to noise at the feature level. There might
also be noise at the label level. A student might write a scathingly
negative review of a course, but then accidentally click the wrong
button for the course rating.

The features available for learning might simply be insufﬁcient.

For example, in a medical context, you might wish to diagnose
whether a patient has cancer or not. You may be able to collect a
large amount of data about this patient, such as gene expressions,
X-rays, family histories, etc. But, even knowing all of this information
exactly, it might still be impossible to judge for sure whether this pa-
tient has cancer or not. As a more contrived example, you might try
to classify course reviews as positive or negative. But you may have
erred when downloading the data and only gotten the ﬁrst ﬁve char-

22 a course in machine learning

acters of each review. If you had the rest of the features you might
be able to do well. But with this limited feature set, there’s not much
you can do.

Some examples may not have a single correct answer. You might

be building a system for “safe web search,” which removes offen-
sive web pages from search results. To build this system, you would
collect a set of web pages and ask people to classify them as “offen-
sive” or not. However, what one person considers offensive might be
completely reasonable for another person. It is common to consider
this as a form of label noise. Nevertheless, since you, as the designer
of the learning system, have some control over this problem, it is
sometimes helpful to isolate it as a source of difﬁculty.

Finally, learning might fail because the inductive bias of the learn-
ing algorithm is too far away from the concept that is being learned.
In the bird/non-bird data, you might think that if you had gotten
a few more training examples, you might have been able to tell
whether this was intended to be a bird/non-bird classiﬁcation or a
ﬂy/no-ﬂy classiﬁcation. However, no one I’ve talked to has ever come
up with the “background is in focus” classiﬁcation. Even with many
more training points, this is such an unusual distinction that it may
be hard for anyone to ﬁgure out it. In this case, the inductive bias of
the learner is simply too misaligned with the target classiﬁcation to
learn.

Note that the inductive bias source of error is fundamentally dif-

ferent than the other three sources of error. In the inductive bias case,
it is the particular learning algorithm that you are using that cannot
cope with the data. Maybe if you switched to a different learning
algorithm, you would be able to learn well. For instance, Neptunians
might have evolved to care greatly about whether backgrounds are
in focus, and for them this would be an easy classiﬁcation to learn.
For the other three sources of error, it is not an issue to do with the
particular learning algorithm. The error is a fundamental part of the
learning problem.

2.4 Underﬁtting and Overﬁtting

As with many problems, it is useful to think about the extreme cases
of learning algorithms. In particular, the extreme cases of decision
trees. In one extreme, the tree is “empty” and we do not ask any
questions at all. We simply immediately make a prediction. In the
other extreme, the tree is “full.” That is, every possible question
is asked along every branch. In the full tree, there may be leaves
with no associated training data. For these we must simply choose
arbitrarily whether to say “yes” or “no.”

Consider the course recommendation data from Table 1. Sup-

pose we were to build an “empty” decision tree on this data. Such a
decision tree will make the same prediction regardless of its input,
because it is not allowed to ask any questions about its input. Since
there are more “likes” than “hates” in the training data (12 versus
8), our empty decision tree will simply always predict “likes.” The
training error, ˆ, is 8/20 = 40%.

On the other hand, we could build a “full” decision tree. Since

each row in this data is unique, we can guarantee that any leaf in a
full decision tree will have either 0 or 1 examples assigned to it (20
of the leaves will have one example; the rest will have none). For the
leaves corresponding to training points, the full decision tree will
always make the correct prediction. Given this, the training error, ˆ, is
0/20 = 0%.

Of course our goal is not to build a model that gets 0% error on

the training data. This would be easy! Our goal is a model that will
do well on future, unseen data. How well might we expect these two
models to do on future data? The “empty” tree is likely to do not
much better and not much worse on future data. We might expect
that it would continue to get around 40% error.

Life is more complicated for the “full” decision tree. Certainly
if it is given a test example that is identical to one of the training
examples, it will do the right thing (assuming no noise). But for
everything else, it will only get about 50% error. This means that
even if every other test point happens to be identical to one of the
training points, it would only get about 25% error. In practice, this is
probably optimistic, and maybe only one in every 10 examples would
match a training example, yielding a 35% error.

So, in one case (empty tree) we’ve achieved about 40% error and

in the other case (full tree) we’ve achieved 35% error. This is not
very promising! One would hope to do better! In fact, you might
notice that if you simply queried on a single feature for this data, you
would be able to get very low training error, but wouldn’t be forced
to “guess” randomly.

This example illustrates the key concepts of underﬁtting and

overﬁtting. Underﬁtting is when you had the opportunity to learn
something but didn’t. A student who hasn’t studied much for an up-
coming exam will be underﬁt to the exam, and consequently will not
do well. This is also what the empty tree does. Overﬁtting is when
you pay too much attention to idiosyncracies of the training data,
and aren’t able to generalize well. Often this means that your model
is ﬁtting noise, rather than whatever it is supposed to ﬁt. A student
who memorizes answers to past exam questions without understand-
ing them has overﬁt the training data. Like the full tree, this student

limits of learning 23

?

Convince yourself (either by proof
or by simulation) that even in the
case of imbalanced data – for in-
stance data that is on average 80%
positive and 20% negative – a pre-
dictor that guesses randomly (50/50
positive/negative) will get about
50% error.

?

Which feature is it, and what is it’s
training error?

24 a course in machine learning

MATH REVIEW | LAW OF LARGE NUMBERS
Consider some random event, like spins of a roulette wheel, cars driving through an intersection, the
outcome of an election, or pasta being appropriately al dente. We often want to make a conclusion
about the entire population (the pot of pasta) based on a much smaller sample (biting a couple pieces
of pasta). The law of large numbers tells us that under mild conditions this is an okay thing to do.

Formally, suppose that v1, v2, . . . , vN are random variables (e.g., vn measures if the nth spaghetti is
al dente). Assume that these random variables are independent (i.e., v2 and v3 are uncorrelated—
they weren’t both taken from the same place in the pot) and identically distributed (they were all
drawn from the same population—pot—that we wish to measure). We can compute the sample av-
n=1 vn and under the strong law of large numbers, you can prove that ¯v → E[v] as
erage ¯v = 1
N → ∞. Namely, the empirical sample average approaches the population average as the number of
samples goes do inﬁnity.

N ∑N

(Technical note: the notion of convergence here is almost sure convergence. In particular, the formal result is
limN→∞ 1
that Pr
population average.)

= 1. Or, in words, with probability one the sample average reaches the

N ∑n vn = E[v]

(cid:16)

(cid:17)

Figure 2.3:

also will not do well on the exam. A model that is neither overﬁt nor
underﬁt is the one that is expected to do best in the future.

2.5 Separation of Training and Test Data

Suppose that, after graduating, you get a job working for a company
that provides personalized recommendations for pottery. You go in
and implement new algorithms based on what you learned in your
machine learning class (you have learned the power of generaliza-
tion!). All you need to do now is convince your boss that you have
done a good job and deserve a raise!

How can you convince your boss that your fancy learning algo-

rithms are really working?

Based on what we’ve talked about already with underﬁtting and
overﬁtting, it is not enough to just tell your boss what your training
error is. Noise notwithstanding, it is easy to get a training error of
zero using a simple database query (or grep, if you prefer). Your boss
will not fall for that.

The easiest approach is to set aside some of your available data as
“test data” and use this to evaluate the performance of your learning
algorithm. For instance, the pottery recommendation service that you
work for might have collected 1000 examples of pottery ratings. You
will select 800 of these as training data and set aside the ﬁnal 200

limits of learning 25

?

If you have more data at your dis-
posal, why might a 90/10 split be
preferable to an 80/20 split?

as test data. You will run your learning algorithms only on the 800
training points. Only once you’re done will you apply your learned
model to the 200 test points, and report your test error on those 200
points to your boss.

The hope in this process is that however well you do on the 200
test points will be indicative of how well you are likely to do in the
future. This is analogous to estimating support for a presidential
candidate by asking a small (random!) sample of people for their
opinions. Statistics (speciﬁcally, concentration bounds of which the
“Central limit theorem” is a famous example) tells us that if the sam-
ple is large enough, it will be a good representative. The 80/20 split
is not magic: it’s simply fairly well established. Occasionally people
use a 90/10 split instead, especially if they have a lot of data.

The cardinal rule of machine learning is: never touch your test

data. Ever. If that’s not clear enough:
Never ever touch your test data!
If there is only one thing you learn from this book, let it be that.

Do not look at your test data. Even once. Even a tiny peek. Once
you do that, it is not test data any more. Yes, perhaps your algorithm
hasn’t seen it. But you have. And you are likely a better learner than
your learning algorithm. Consciously or otherwise, you might make
decisions based on whatever you might have seen. Once you look at
the test data, your model’s performance on it is no longer indicative
of it’s performance on future unseen data. This is simply because
future data is unseen, but your “test” data no longer is.

2.6 Models, Parameters and Hyperparameters

The general approach to machine learning, which captures many ex-
isting learning algorithms, is the modeling approach. The idea is that
we come up with some formal model of our data. For instance, we
might model the classiﬁcation decision of a student/course pair as a
decision tree. The choice of using a tree to represent this model is our
choice. We also could have used an arithmetic circuit or a polynomial
or some other function. The model tells us what sort of things we can
learn, and also tells us what our inductive bias is.

For most models, there will be associated parameters. These are

the things that we use the data to decide on. Parameters in a decision
tree include: the speciﬁc questions we asked, the order in which we
asked them, and the classiﬁcation decisions at the leaves. The job of
our decision tree learning algorithm DecisionTreeTrain is to take
data and ﬁgure out a good set of parameters.

26 a course in machine learning

Many learning algorithms will have additional knobs that you can

adjust. In most cases, these knobs amount to tuning the inductive
bias of the algorithm. In the case of the decision tree, an obvious
knob that one can tune is the maximum depth of the decision tree.
That is, we could modify the DecisionTreeTrain function so that
it stops recursing once it reaches some pre-deﬁned maximum depth.
By playing with this depth knob, we can adjust between underﬁtting
(the empty tree, depth= 0) and overﬁtting (the full tree, depth= ∞).
Such a knob is called a hyperparameter. It is so called because it

is a parameter that controls other parameters of the model. The exact
deﬁnition of hyperparameter is hard to pin down: it’s one of those
things that are easier to identify than deﬁne. However, one of the
key identiﬁers for hyperparameters (and the main reason that they
cause consternation) is that they cannot be naively adjusted using the
training data.

In DecisionTreeTrain, as in most machine learning, the learn-

ing algorithm is essentially trying to adjust the parameters of the
model so as to minimize training error. This suggests an idea for
choosing hyperparameters: choose them so that they minimize train-
ing error.

What is wrong with this suggestion? Suppose that you were to

treat “maximum depth” as a hyperparameter and tried to tune it on
your training data. To do this, maybe you simply build a collection
of decision trees, tree0, tree1, tree2, . . . , tree100, where treed is a tree
of maximum depth d. We then computed the training error of each
of these trees and chose the “ideal” maximum depth as that which
minimizes training error? Which one would it pick?

The answer is that it would pick d = 100. Or, in general, it would

pick d as large as possible. Why? Because choosing a bigger d will
never hurt on the training data. By making d larger, you are simply
encouraging overﬁtting. But by evaluating on the training data, over-
ﬁtting actually looks like a good idea!

An alternative idea would be to tune the maximum depth on test

data. This is promising because test data peformance is what we
really want to optimize, so tuning this knob on the test data seems
like a good idea. That is, it won’t accidentally reward overﬁtting. Of
course, it breaks our cardinal rule about test data: that you should
never touch your test data. So that idea is immediately off the table.
However, our “test data” wasn’t magic. We simply took our 1000

examples, called 800 of them “training” data and called the other 200
“test” data. So instead, let’s do the following. Let’s take our original
1000 data points, and select 700 of them as training data. From the
remainder, take 100 as development data1 and the remaining 200
as test data. The job of the development data is to allow us to tune

?

Go back to the DecisionTree-
Train algorithm and modify it so
that it takes a maximum depth pa-
rameter. This should require adding
two lines of code and modifying
three others.

1 Some people call this “validation
data” or “held-out data.”

hyperparameters. The general approach is as follows:

1. Split your data into 70% training data, 10% development data and

20% test data.

2. For each possible setting of your hyperparameters:

(a) Train a model using that setting of hyperparameters on the

training data.

(b) Compute this model’s error rate on the development data.

3. From the above collection of models, choose the one that achieved

the lowest error rate on development data.

4. Evaluate that model on the test data to estimate future test perfor-

mance.

2.7 Real World Applications of Machine Learning

Figure 2.4 shows a typical sequence of decisions that must be made
to deploy a machine learning approach in the real world. In the left
column, you can see the generic decision being made. In the right
column, an example of this decision for the particular case of adver-
tising placement on a search engine we’ve built.

In this sequence, (1) we have some real world goal like increasing

revenue for our search engine, and decide to try to increase rev-
enue by (2) displaying better ads. We convert this task into a ma-
chine learning problem by (3) deciding to train a classiﬁer to predict
whether a user will click on an ad or not. In order to apply machine
learning, we must collect some training data; in this case, (4) we col-
lect data by logging user interactions with the current system. We
must choose what to log; (5) we choose to log the ad being displayed,
the query the user entered into our search engine, and binary value
showing if they clicked or not.

In order to make these logs consumable by a machine learning
algorithm, (6) we convert the data into input/output pairs: in this
case, pairs of words from a bag-of-words representing the query and
a bag-of-words representing the ad as input, and the click as a ±
label. We then (7) select a model family (e.g., depth 20 decision trees),
and thereby an inductive bias, for instance depth ≤ 20 decision trees.

We’re now ready to (8) select a speciﬁc subset of data to use as
training data: in this case, data from April 2016. We split this into
training and development and (9) learn a ﬁnal decision tree, tuning
the maximum depth on the development data. We can then use this
decision tree to (10) make predictions on some held-out test data, in

limits of learning 27

?

In step 3, you could either choose
the model (trained on the 70% train-
ing data) that did the best on the
development data. Or you could
choose the hyperparameter settings
that did best and retrain the model
on the 80% union of training and
development data. Is either of these
options obviously better or worse?

1

2

3

4

5

6

7

8

9

10

11

12

real world
goal
real world
mechanism
learning
problem

data collection

collected data
data
representation
select model
family
select training
data
train model &
hyperparams
predict on test
data

evaluate error

deploy!

increase
revenue
better ad
display
classify
click-through
interaction w/
current system

query, ad, click
bow2, ± click
decision trees,
depth 20
subset from
april’16
ﬁnal decision
tree
subset from
may’16
zero/one loss
for ± click
(hope we
achieve our
goal)

Figure 2.4: A typical design process for
a machine learning application.

28 a course in machine learning

this case from the following month. We can (11) measure the overall
quality of our predictor as zero/one loss (clasiﬁcation error) on this
test data and ﬁnally (12) deploy our system.

The important thing about this sequence of steps is that in any

one, things can go wrong. That is, between any two rows of this table,
we are necessarily accumulating some additional error against our
original real world goal of increasing revenue. For example, in step 5,
we decided on a representation that left out many possible variables
we could have logged, like time of day or season of year. By leaving
out those variables, we set an explicit upper bound on how well our
learned system can do.

It is often an effective strategy to run an oracle experiment. In an

oracle experiment, we assume that everything below some line can be
solved perfectly, and measure how much impact that will have on a
higher line. As an extreme example, before embarking on a machine
learning approach to the ad display problem, we should measure
something like: if our classiﬁer were perfect, how much more money
would we make? If the number is not very high, perhaps there is
some better for our time.

Finally, although this sequence is denoted linearly, the entire pro-

cess is highly interactive in practice. A large part of “debugging”
machine learning (covered more extensively in Chapter 5 involves
trying to ﬁgure out where in this sequence the biggest losses are and
ﬁxing that step. In general, it is often useful to build the stupidest thing
that could possibly work, then look at how well it’s doing, and decide if
and where to ﬁx it.

2.8 Further Reading

TODO further reading

3 | GEOMETRY AND NEAREST NEIGHBORS

Learning Objectives:
• Describe a data set as points in a

high dimensional space.

• Explain the curse of dimensionality.
• Compute distances between points

in high dimensional space.

• Implement a K-nearest neighbor

model of learning.

• Draw decision boundaries.
• Implement the K-means algorithm

for clustering.

Dependencies: Chapter 1

Our brains have evolved to get us out of the rain, ﬁnd where the
berries are, and keep us from getting killed. Our brains did not
evolve to help us grasp really large numbers or to look at things in
a hundred thousand dimensions.
– Ronald Graham

You can think of prediction tasks as mapping inputs (course
reviews) to outputs (course ratings). As you learned in the previ-
ous chapter, decomposing an input into a collection of features (e.g.,
words that occur in the review) forms a useful abstraction for learn-
ing. Therefore, inputs are nothing more than lists of feature values.
This suggests a geometric view of data, where we have one dimen-
sion for every feature. In this view, examples are points in a high-
dimensional space.

Once we think of a data set as a collection of points in high dimen-

sional space, we can start performing geometric operations on this
data. For instance, suppose you need to predict whether Alice will
like Algorithms. Perhaps we can try to ﬁnd another student who is
most “similar” to Alice, in terms of favorite courses. Say this student
is Jeremy. If Jeremy liked Algorithms, then we might guess that Alice
will as well. This is an example of a nearest neighbor model of learn-
ing. By inspecting this model, we’ll see a completely different set of
answers to the key learning questions we discovered in Chapter 1.

3.1 From Data to Feature Vectors

An example is just a collection of feature values about that example,
for instance the data in Table 1 from the Appendix. To a person, these
features have meaning. One feature might count how many times the
reviewer wrote “excellent” in a course review. Another might count
the number of exclamation points. A third might tell us if any text is
underlined in the review.

To a machine, the features themselves have no meaning. Only

the feature values, and how they vary across examples, mean some-
thing to the machine. From this perspective, you can think about an
example as being represented by a feature vector consisting of one
“dimension” for each feature, where each dimenion is simply some
real value.

Consider a review that said “excellent” three times, had one excla-

30 a course in machine learning

mation point and no underlined text. This could be represented by
the feature vector (cid:104)3, 1, 0(cid:105). An almost identical review that happened
to have underlined text would have the feature vector (cid:104)3, 1, 1(cid:105).

Note, here, that we have imposed the convention that for binary

features (yes/no features), the corresponding feature values are 0
and 1, respectively. This was an arbitrary choice. We could have
made them 0.92 and −16.1 if we wanted. But 0/1 is convenient and
helps us interpret the feature values. When we discuss practical
issues in Chapter 5, you will see other reasons why 0/1 is a good
choice.

Figure 3.1 shows the data from Table 1 in three views. These three
views are constructed by considering two features at a time in differ-
ent pairs. In all cases, the plusses denote positive examples and the
minuses denote negative examples. In some cases, the points fall on
top of each other, which is why you cannot see 20 unique points in
all ﬁgures.

The mapping from feature values to vectors is straighforward in

the case of real valued features (trivial) and binary features (mapped
to zero or one). It is less clear what to do with categorical features.
For example, if our goal is to identify whether an object in an image
is a tomato, blueberry, cucumber or cockroach, we might want to
know its color: is it Red, Blue, Green or Black?

One option would be to map Red to a value of 0, Blue to a value
of 1, Green to a value of 2 and Black to a value of 3. The problem
with this mapping is that it turns an unordered set (the set of colors)
into an ordered set (the set {0, 1, 2, 3}). In itself, this is not necessarily
a bad thing. But when we go to use these features, we will measure
examples based on their distances to each other. By doing this map-
ping, we are essentially saying that Red and Blue are more similar
(distance of 1) than Red and Black (distance of 3). This is probably
not what we want to say!

A solution is to turn a categorical feature that can take four dif-
ferent values (say: Red, Blue, Green and Black) into four binary
features (say: IsItRed?, IsItBlue?, IsItGreen? and IsItBlack?). In gen-
eral, if we start from a categorical feature that takes V values, we can
map it to V-many binary indicator features.

With that, you should be able to take a data set and map each

example to a feature vector through the following mapping:

• Real-valued features get copied directly.

• Binary features become 0 (for false) or 1 (for true).

• Categorical features with V possible values get mapped to V-many

binary indicator features.

Figure 3.1: A ﬁgure showing projections
of data in two dimension in three
ways – see text. Top: horizontal axis
corresponds to the ﬁrst feature (easy)
and the vertical axis corresponds to
the second feature (AI?); Middle:
horizontal is second feature and vertical
is third (systems?); Bottom: horizontal
is ﬁrst and vertical is third. Truly,
the data points would like exactly on
(0, 0) or (1, 0), etc., but they have been
purturbed slightly to show duplicates.
?

Match the example ids from Table 1
with the points in Figure 3.1.

?

The computer scientist in you might
be saying: actually we could map it
to log2 V-many binary features! Is
this a good idea or not?

easy?AI?AI?sys?easy?sys?geometry and nearest neighbors

31

After this mapping, you can think of a single example as a vec-
tor in a high-dimensional feature space. If you have D-many fea-
tures (after expanding categorical features), then this feature vector
will have D-many components. We will denote feature vectors as
x = (cid:104)x1, x2, . . . , xD(cid:105), so that xd denotes the value of the dth fea-
ture of x. Since these are vectors with real-valued components in
D-dimensions, we say that they belong to the space RD.

For D = 2, our feature vectors are just points in the plane, like in
Figure 3.1. For D = 3 this is three dimensional space. For D > 3 it
becomes quite hard to visualize. (You should resist the temptation
to think of D = 4 as “time” – this will just make things confusing.)
Unfortunately, for the sorts of problems you will encounter in ma-
chine learning, D ≈ 20 is considered “low dimensional,” D ≈ 1000 is
“medium dimensional” and D ≈ 100000 is “high dimensional.”

3.2 K-Nearest Neighbors

?

Can you think of problems (per-
haps ones already mentioned in this
book!) that are low dimensional?
That are medium dimensional?
That are high dimensional?

The biggest advantage to thinking of examples as vectors in a high
dimensional space is that it allows us to apply geometric concepts
to machine learning. For instance, one of the most basic things
that one can do in a vector space is compute distances. In two-
dimensional space, the distance between (cid:104)2, 3(cid:105) and (cid:104)6, 1(cid:105) is given

by(cid:112)(2 − 6)2 + (3 − 1)2 =

18 ≈ 4.24. In general, in D-dimensional

√

space, the Euclidean distance between vectors a and b is given by
Eq (3.1) (see Figure 3.2 for geometric intuition in three dimensions):

(cid:35) 1

2

(cid:34) D∑

d=1

d(a, b) =

(ad − bd)2

(3.1)

Now that you have access to distances between examples, you

can start thinking about what it means to learn again. Consider Fig-
ure 3.3. We have a collection of training data consisting of positive
examples and negative examples. There is a test point marked by a
question mark. Your job is to guess the correct label for that point.

Most likely, you decided that the label of this test point is positive.

One reason why you might have thought that is that you believe
that the label for an example should be similar to the label of nearby
points. This is an example of a new form of inductive bias.

The nearest neighbor classiﬁer is build upon this insight. In com-

parison to decision trees, the algorithm is ridiculously simple. At
training time, we simply store the entire training set. At test time,
we get a test example ˆx. To predict its label, we ﬁnd the training ex-
ample x that is most similar to ˆx. In particular, we ﬁnd the training

Figure 3.2: A ﬁgure showing Euclidean
distance in three dimensions. The
length of the green segments are 0.6, 0.6
and 0.3 respectively, in the x-, y-, and
z-axes. The total distance between the
√
red dot and the orange dot is therefore

0.62 + 0.62 + 0.32 = 0.9.

?

Verify that d from Eq (3.1) gives the
same result (4.24) for the previous
computation.

(0, .4, .5)(.6, 1, .8)?32 a course in machine learning

example x that minimizes d(x, ˆx). Since x is a training example, it has
a corresponding label, y. We predict that the label of ˆx is also y.
Despite its simplicity, this nearest neighbor classiﬁer is incred-
ibly effective. (Some might say frustratingly effective.) However, it
is particularly prone to overﬁtting label noise. Consider the data in
Figure 3.4. You would probably want to label the test point positive.
Unfortunately, it’s nearest neighbor happens to be negative. Since the
nearest neighbor algorithm only looks at the single nearest neighbor,
it cannot consider the “preponderance of evidence” that this point
should probably actually be a positive example. It will make an un-
necessary error.

A solution to this problem is to consider more than just the single
nearest neighbor when making a classiﬁcation decision. We can con-
sider the K-nearest neighbors and let them vote on the correct class
for this test point. If you consider the 3-nearest neighbors of the test
point in Figure 3.4, you will see that two of them are positive and one
is negative. Through voting, positive would win.

The full algorithm for K-nearest neighbor classiﬁcation is given

in Algorithm 3.2. Note that there actually is no “training” phase for
K-nearest neighbors. In this algorithm we have introduced ﬁve new
conventions:

1. The training data is denoted by D.

2. We assume that there are N-many training examples.

3. These examples are pairs (x1, y1), (x2, y2), . . . , (xN, yN).

(Warning: do not confuse xn, the nth training example, with xd,
the dth feature for example x.)

4. We use [ ]to denote an empty list and ⊕ · to append · to that list.
5. Our prediction on ˆx is called ˆy.

The ﬁrst step in this algorithm is to compute distances from the
test point to all training points (lines 2-4). The data points are then
sorted according to distance. We then apply a clever trick of summing
the class labels for each of the K nearest neighbors (lines 6-10) and
using the sign of this sum as our prediction.

The big question, of course, is how to choose K. As we’ve seen,
with K = 1, we run the risk of overﬁtting. On the other hand, if
K is large (for instance, K = N), then KNN-Predict will always
predict the majority class. Clearly that is underﬁtting. So, K is a
hyperparameter of the KNN algorithm that allows us to trade-off
between overﬁtting (small value of K) and underﬁtting (large value of
K).

Figure 3.4: A ﬁgure showing an easy
NN classiﬁcation problem where the
test point is a ? and should be positive,
but its NN is actually a negative point
that’s noisy.
?

Why is it a good idea to use an odd
number for K?

?

Why is the sign of the sum com-
puted in lines 2-4 the same as the
majority vote of the associated
training examples?

?

Why can’t you simply pick the
value of K that does best on the
training data? In other words, why
do we have to treat it like a hy-
perparameter rather than just a
parameter.

?geometry and nearest neighbors

33

// store distance to training example n

// put lowest-distance objects ﬁrst

S ← S ⊕ (cid:104)d(xn, ˆx), n(cid:105)

Algorithm 3 KNN-Predict(D, K, ˆx)
1: S ← [ ]
2: for n = 1 to N do
3:
4: end for
5: S ← sort(S)
ˆy ← 0
6:
7: for k = 1 to K do
(cid:104)dist,n(cid:105) ← Sk
8:
ˆy ← ˆy + yn

9:
10: end for
11: return sign( ˆy)

// n this is the kth closest data point
// vote according to the label for the nth training point
// return +1 if ˆy > 0 and −1 if ˆy < 0

One aspect of inductive bias that we’ve seen for KNN is that it
assumes that nearby points should have the same label. Another
aspect, which is quite different from decision trees, is that all features
are equally important! Recall that for decision trees, the key question
was which features are most useful for classiﬁcation? The whole learning
algorithm for a decision tree hinged on ﬁnding a small set of good
features. This is all thrown away in KNN classiﬁers: every feature
is used, and they are all used the same amount. This means that if
you have data with only a few relevant features and lots of irrelevant
features, KNN is likely to do poorly.

A related issue with KNN is feature scale. Suppose that we are
trying to classify whether some object is a ski or a snowboard (see
Figure 3.5). We are given two features about this data: the width
and height. As is standard in skiing, width is measured in millime-
ters and height is measured in centimeters. Since there are only two
features, we can actually plot the entire training set; see Figure 3.6
where ski is the positive class. Based on this data, you might guess
that a KNN classiﬁer would do well.

Suppose, however, that our measurement of the width was com-

puted in millimeters (instead of centimeters). This yields the data
shown in Figure 3.7. Since the width values are now tiny, in compar-
ison to the height values, a KNN classiﬁer will effectively ignore the
width values and classify almost purely based on height. The pre-
dicted class for the displayed test point had changed because of this
feature scaling.

We will discuss feature scaling more in Chapter 5. For now, it is

just important to keep in mind that KNN does not have the power to
decide which features are important.

Figure 3.5: A ﬁgure of a ski and a
snowboard.

Figure 3.6: Classiﬁcation data for ski vs
snowboard in 2d

Figure 3.7: Classiﬁcation data for ski vs
snowboard in 2d, with width rescaled
to mm.

34 a course in machine learning

MATH REVIEW | VECTOR ARITHMETIC AND VECTOR NORMS
A (real-valued) vector is just an array of real values, for instance x = (cid:104)1, 2.5,−6(cid:105) is a three-dimensional
vector. In general, if x = (cid:104)x1, x2, . . . , xD(cid:105), then xd is it’s dth component. So x3 = −6 in the previous ex-
ample.
Vector sums are computed pointwise, and are only deﬁned when dimensions match, so (cid:104)1, 2.5,−6(cid:105) +
(cid:104)2,−2.5, 3(cid:105) = (cid:104)3, 0,−3(cid:105). In general, if c = a + b then cd = ad + bd for all d. Vector addition can
be viewed geometrically as taking a vector a, then tacking on b to the end of it; the new end point is
exactly c.
Vectors can be scaled by real values; for instance 2(cid:104)1, 2.5,−6(cid:105) = (cid:104)2, 5,−12(cid:105); this is called scalar multi-
plication. In general, ax = (cid:104)ax1, ax2, . . . , axD(cid:105).
The norm of a vector x, written ||x|| is its length. Unless otherwise speciﬁed, this is its Euclidean length,
namely: ||x|| =

(cid:113)

∑d x2
d.

3.3 Decision Boundaries

Figure 3.8:

The standard way that we’ve been thinking about learning algo-
rithms up to now is in the query model. Based on training data, you
learn something. I then give you a query example and you have to
guess it’s label.

An alternative, less passive, way to think about a learned model
is to ask: what sort of test examples will it classify as positive, and
what sort will it classify as negative. In Figure 3.9, we have a set of
training data. The background of the image is colored blue in regions
that would be classiﬁed as positive (if a query were issued there)
and colored red in regions that would be classiﬁed as negative. This
coloring is based on a 1-nearest neighbor classiﬁer.

In Figure 3.9, there is a solid line separating the positive regions
from the negative regions. This line is called the decision boundary
for this classiﬁer. It is the line with positive land on one side and
negative land on the other side.

Decision boundaries are useful ways to visualize the complex-

ity of a learned model. Intuitively, a learned model with a decision
boundary that is really jagged (like the coastline of Norway) is really
complex and prone to overﬁtting. A learned model with a decision
boundary that is really simple (like the bounary between Arizona
and Utah) is potentially underﬁt.

Now that you know about decision boundaries, it is natural to ask:

what do decision boundaries for decision trees look like? In order

Figure 3.9: decision boundary for 1nn.

Figure 3.10: decision boundary for knn
with k=3.

geometry and nearest neighbors

35

to answer this question, we have to be a bit more formal about how
to build a decision tree on real-valued features. (Remember that the
algorithm you learned in the previous chapter implicitly assumed
binary feature values.) The idea is to allow the decision tree to ask
questions of the form: “is the value of feature 5 greater than 0.2?”
That is, for real-valued features, the decision tree nodes are param-
eterized by a feature and a threshold for that feature. An example
decision tree for classifying skis versus snowboards is shown in Fig-
ure 3.11.

Now that a decision tree can handle feature vectors, we can talk
about decision boundaries. By example, the decision boundary for
the decision tree in Figure 3.11 is shown in Figure 3.12. In the ﬁgure,
space is ﬁrst split in half according to the ﬁrst query along one axis.
Then, depending on which half of the space you look at, it is either
split again along the other axis, or simply classiﬁed.

Figure 3.12 is a good visualization of decision boundaries for

decision trees in general. Their decision boundaries are axis-aligned
cuts. The cuts must be axis-aligned because nodes can only query on
a single feature at a time. In this case, since the decision tree was so
shallow, the decision boundary was relatively simple.

3.4 K-Means Clustering

Up through this point, you have learned all about supervised learn-
ing (in particular, binary classiﬁcation). As another example of the
use of geometric intuitions and data, we are going to temporarily
consider an unsupervised learning problem. In unsupervised learn-
ing, our data consists only of examples xn and does not contain corre-
sponding labels. Your job is to make sense of this data, even though
no one has provided you with correct labels. The particular notion of
“making sense of” that we will talk about now is the clustering task.
Consider the data shown in Figure 3.13. Since this is unsupervised

learning and we do not have access to labels, the data points are
simply drawn as black dots. Your job is to split this data set into
three clusters. That is, you should label each data point as A, B or C
in whatever way you want.

For this data set, it’s pretty clear what you should do. You prob-

ably labeled the upper-left set of points A, the upper-right set of
points B and the bottom set of points C. Or perhaps you permuted
these labels. But chances are your clusters were the same as mine.
The K-means clustering algorithm is a particularly simple and

effective approach to producing clusters on data like you see in Fig-
ure 3.13. The idea is to represent each cluster by it’s cluster center.
Given cluster centers, we can simply assign each point to its nearest

Figure 3.11: decision tree for ski vs.
snowboard

Figure 3.12: decision boundary for dt in
previous ﬁgure

?

What sort of data might yield a
very simple decision boundary with
a decision tree and very complex
decision boundary with 1-nearest
neighbor? What about the other
way around?

Figure 3.13: simple clustering data...
clusters in UL, UR and BC.

36 a course in machine learning

center. Similarly, if we know the assignment of points to clusters, we
can compute the centers. This introduces a chicken-and-egg problem.
If we knew the clusters, we could compute the centers. If we knew
the centers, we could compute the clusters. But we don’t know either.
The general computer science answer to chicken-and-egg problems

is iteration. We will start with a guess of the cluster centers. Based
on that guess, we will assign each data point to its closest center.
Given these new assignments, we can recompute the cluster centers.
We repeat this process until clusters stop moving. The ﬁrst few it-
erations of the K-means algorithm are shown in Figure 3.14. In this
example, the clusters converge very quickly.

Algorithm 3.4 spells out the K-means clustering algorithm in de-
tail. The cluster centers are initialized randomly. In line 6, data point
xn is compared against each cluster center µk. It is assigned to cluster
k if k is the center with the smallest distance. (That is the “argmin”
step.) The variable zn stores the assignment (a value from 1 to K) of
example n. In lines 8-12, the cluster centers are re-computed. First, Xk
stores all examples that have been assigned to cluster k. The center of
cluster k, µk is then computed as the mean of the points assigned to
it. This process repeats until the centers converge.

An obvious question about this algorithm is: does it converge?
A second question is: how long does it take to converge. The ﬁrst
question is actually easy to answer. Yes, it does. And in practice, it
usually converges quite quickly (usually fewer than 20 iterations). In
Chapter 15, we will actually prove that it converges. The question of
how long it takes to converge is actually a really interesting question.
Even though the K-means algorithm dates back to the mid 1950s, the
best known convergence rates were terrible for a long time. Here, ter-
rible means exponential in the number of data points. This was a sad
situation because empirically we knew that it converged very quickly.
New algorithm analysis techniques called “smoothed analysis” were
invented in 2001 and have been used to show very fast convergence
for K-means (among other algorithms). These techniques are well
beyond the scope of this book (and this author!) but sufﬁce it to say
that K-means is fast in practice and is provably fast in theory.

It is important to note that although K-means is guaranteed to

converge and guaranteed to converge quickly, it is not guaranteed to
converge to the “right answer.” The key problem with unsupervised
learning is that we have no way of knowing what the “right answer”
is. Convergence to a bad solution is usually due to poor initialization.

Figure 3.14: ﬁrst few iterations of
k-means running on previous data set

?

What is the difference between un-
supervised and supervised learning
that means that we know what the
“right answer” is for supervised
learning but not for unsupervised
learning?

µk ← some random location

Algorithm 4 K-Means(D, K)
1: for k = 1 to K do
2:
3: end for
4: repeat
5:

for n = 1 to N do

zn ← argmink ||µk − xn||

end for
for k = 1 to K do
Xk ← { xn : zn = k }
µk ← mean(Xk)

6:

7:

8:

9:

10:

end for

11:
12: until µs stop changing
13: return z

geometry and nearest neighbors

37

// randomly initialize center for kth cluster

// assign example n to closest center

// points assigned to cluster k
// re-estimate center of cluster k

// return cluster assignments

3.5 Warning: High Dimensions are Scary

Visualizing one hundred dimensional space is incredibly difﬁcult for
humans. After huge amounts of training, some people have reported
that they can visualize four dimensional space in their heads. But
beyond that seems impossible.1

In addition to being hard to visualize, there are at least two addi-
tional problems in high dimensions, both refered to as the curse of
dimensionality. One is computational, the other is mathematical.
From a computational perspective, consider the following prob-
lem. For K-nearest neighbors, the speed of prediction is slow for a
very large data set. At the very least you have to look at every train-
ing example every time you want to make a prediction. To speed
things up you might want to create an indexing data structure. You
can break the plane up into a grid like that shown in Figure 3.15.
Now, when the test point comes in, you can quickly identify the grid
cell in which it lies. Now, instead of considering all training points,
you can limit yourself to training points in that grid cell (and perhaps
the neighboring cells). This can potentially lead to huge computa-
tional savings.
space up into a grid whose cells are 0.2×0.2, we can clearly do this
with 25 grid cells in two dimensions (assuming the range of the
features is 0 to 1 for simplicity). In three dimensions, we’ll need
125 = 5×5×5 grid cells. In four dimensions, we’ll need 625. By the
time we get to “low dimensional” data in 20 dimensions, we’ll need
95, 367, 431, 640, 625 grid cells (that’s 95 trillion, which is about 6 to
7 times the US national debt as of January 2011). So if you’re in 20
dimensions, this gridding technique will only be useful if you have at
least 95 trillion training examples.

In two dimensions, this procedure is effective. If we want to break

1 If you want to try to get an intu-
itive sense of what four dimensions
looks like, I highly recommend the
short 1884 book Flatland: A Romance
of Many Dimensions by Edwin Abbott
Abbott. You can even read it online at
gutenberg.org/ebooks/201.

Figure 3.15: 2d knn with an overlaid
grid, cell with test point highlighted

38 a course in machine learning

For “medium dimensional” data (approximately 1000) dimesions,

the number of grid cells is a 9 followed by 698 numbers before the
decimal point. For comparison, the number of atoms in the universe
is approximately 1 followed by 80 zeros. So even if each atom yielded
a googul training examples, we’d still have far fewer examples than
grid cells. For “high dimensional” data (approximately 100000) di-
mensions, we have a 1 followed by just under 70, 000 zeros. Far too
big a number to even really comprehend.

Sufﬁce it to say that for even moderately high dimensions, the
amount of computation involved in these problems is enormous.
In addition to the computational difﬁculties of working in high
dimensions, there are a large number of strange mathematical oc-
curances there. In particular, many of your intuitions that you’ve
built up from working in two and three dimensions just do not carry
over to high dimensions. We will consider two effects, but there are
countless others. The ﬁrst is that high dimensional spheres look more
like porcupines than like balls.2 The second is that distances between
points in high dimensions are all approximately the same.

Let’s start in two dimensions as in Figure 3.16. We’ll start with

four green spheres, each of radius one and each touching exactly two
other green spheres. (Remember that in two dimensions a “sphere”
is just a “circle.”) We’ll place a red sphere in the middle so that it
touches all four green spheres. We can easily compute the radius of
this small sphere. The pythagorean theorem says that 12 + 12 = (1 +
2 − 1 ≈ 0.41. Thus, by calculation,
r)2, so solving for r we get r =
the blue sphere lies entirely within the cube (cube = square) that
contains the grey spheres. (Yes, this is also obvious from the picture,
but perhaps you can see where this is going.)

√

Now we can do the same experiment in three dimensions, as

shown in Figure 3.17. Again, we can use the pythagorean theorem
to compute the radius of the blue sphere. Now, we get 12 + 12 + 12 =
3 − 1 ≈ 0.73. This is still entirely enclosed in the
(1 + r)2, so r =
cube of width four that holds all eight grey spheres.

√

At this point it becomes difﬁcult to produce ﬁgures, so you’ll

have to apply your imagination. In four dimensions, we would have
16 green spheres (called hyperspheres), each of radius one. They
would still be inside a cube (called a hypercube) of width four. The
4 − 1 = 1. Continuing
blue hypersphere would have radius r =
√
to ﬁve dimensions, the blue hypersphere embedded in 256 green
hyperspheres would have radius r =

5 − 1 ≈ 1.23 and so on.

√

In general, in D-dimensional space, there will be 2D green hyper-

spheres of radius one. Each green hypersphere will touch exactly
n-many other hyperspheres. The blue hyperspheres in the middle
will touch them all and will have radius r =

D − 1.

√

?

How does the above analysis relate
to the number of data points you
would need to ﬁll out a full decision
tree with D-many features? What
does this say about the importance
of shallow trees?

2 This result was related to me by Mark
Reid, who heard about it from Marcus
Hutter.

Figure 3.16: 2d spheres in spheres

Figure 3.17: 3d spheres in spheres

geometry and nearest neighbors

39

Think about this for a moment. As the number of dimensions

grows, the radius of the blue hypersphere grows without bound!. For
√
example, in 9-dimensions the radius of the blue hypersphere is now
9 − 1 = 2. But with a radius of two, the blue hypersphere is now
“squeezing” between the green hypersphere and touching the edges
of the hypercube. In 10 dimensional space, the radius is approxi-
mately 2.16 and it pokes outside the cube.

The second strange fact we will consider has to do with the dis-
tances between points in high dimensions. We start by considering
random points in one dimension. That is, we generate a fake data set
consisting of 100 random points between zero and one. We can do
the same in two dimensions and in three dimensions. See Figure ??
for data distributed uniformly on the unit hypercube in different
dimensions.

Now, pick two of these points at random and compute the dis-
tance between them. Repeat this process for all pairs of points and
average the results. For the data shown in Figure ??, the average
distance between points in one dimension is about 0.346; in two di-
mensions is about 0.518; and in three dimensions is 0.615. The fact
that these increase as the dimension increases is not surprising. The
furthest two points can be in a 1-dimensional hypercube (line) is 1;
the furthest in a 2-dimensional hypercube (square) is
2 (opposite
corners); the furthest in a 3-d hypercube is
the furthest two points in a D-dimensional hypercube will be

√
D.
You can actually compute these values analytically. Write UniD
for the uniform distribution in D dimensions. The quantity we are
interested in computing is:

√

√

3 and so on. In general,

(cid:104)

(cid:104) ||a − b||(cid:105)(cid:105)

avgDist(D) = Ea∼UniD

Eb∼UniD

(3.2)

√
We can actually compute this in closed form and arrive at avgDist(D) =

D/3. Because we know that the maximum distance between two
D, this says that the ratio between average dis-

points grows like
tance and maximum distance converges to 1/3.

√

√

What is more interesting, however, is the variance of the distribu-
tion of distances. You can show that in D dimensions, the variance
18, independent of D. This means that when you look
is constant 1/
at (variance) divided-by (max distance), the variance behaves like
1/
as D grows3.

18D, which means that the effective variance continues to shrink

√

When I ﬁrst saw and re-proved this result, I was skeptical, as I
imagine you are. So I implemented it. In Figure 3.18 you can see
the results. This presents a histogram of distances between random
points in D dimensions for D ∈ {1, 2, 3, 10, 20, 100}. As you can see,
D, even for
all of these distances begin to concentrate around 0.4

√

3 Brin 1995

Figure 3.18: histogram of distances in
D=2,8,32,128,512

0.00.20.40.60.81.0distance / sqrt(dimensionality)02000400060008000100001200014000# of pairs of points at that distancedimensionality versus uniform point distances2 dims8 dims32 dims128 dims512 dims40 a course in machine learning

“medium dimension” problems.

You should now be terriﬁed: the only bit of information that KNN

gets is distances. And you’ve just seen that in moderately high di-
mensions, all distances becomes equal. So then isn’t it the case that
KNN simply cannot work?

The answer has to be no. The reason is that the data that we get

is not uniformly distributed over the unit hypercube. We can see this
by looking at two real-world data sets. The ﬁrst is an image data set
of hand-written digits (zero through nine); see Section ??. Although
this data is originally in 256 dimensions (16 pixels by 16 pixels), we
can artiﬁcally reduce the dimensionality of this data. In Figure 3.19
you can see the histogram of average distances between points in this
data at a number of dimensions.

As you can see from these histograms, distances have not con-
centrated around a single value. This is very good news: it means
that there is hope for learning algorithms to work! Nevertheless, the
moral is that high dimensions are weird.

3.6 Further Reading

TODO further reading

Figure 3.19: knn:mnist: histogram of
distances in multiple D for mnist

4 | THE PERCEPTRON

Algebra is nothing more than geometry, in words; geometry is
nothing more than algebra, in pictures.

– Sophie Germain

So far, you’ve seen two types of learning models: in decision
trees, only a small number of features are used to make decisions; in
nearest neighbor algorithms, all features are used equally. Neither of
these extremes is always desirable. In some problems, we might want
to use most of the features, but use some more than others.

In this chapter, we’ll discuss the perceptron algorithm for learn-
ing weights for features. As we’ll see, learning weights for features
amounts to learning a hyperplane classiﬁer: that is, basically a di-
vision of space into two halves by a straight line, where one half is
“positive” and one half is “negative.” In this sense, the perceptron
can be seen as explicitly ﬁnding a good linear decision boundary.

Learning Objectives:
• Describe the biological motivation

behind the perceptron.

• Classify learning algorithms based
on whether they are error-driven or
not.

• Implement the perceptron algorithm

for binary classiﬁcation.

• Draw perceptron weight vectors
and the corresponding decision
boundaries in two dimensions.

• Contrast the decision boundaries
of decision trees, nearest neighbor
algorithms and perceptrons.

• Compute the margin of a given

weight vector on a given data set.

4.1 Bio-inspired Learning

Dependencies: Chapter 1, Chapter 3

Folk biology tells us that our brains are made up of a bunch of little
units, called neurons, that send electrical signals to one another. The
rate of ﬁring tells us how “activated” a neuron is. A single neuron,
like that shown in Figure 4.1 might have three incoming neurons.
These incoming neurons are ﬁring at different rates (i.e., have dif-
ferent activations). Based on how much these incoming neurons are
ﬁring, and how “strong” the neural connections are, our main neu-
ron will “decide” how strongly it wants to ﬁre. And so on through
the whole brain. Learning in the brain happens by neurons becom-
ming connected to other neurons, and the strengths of connections
adapting over time.

The real biological world is much more complicated than this.
However, our goal isn’t to build a brain, but to simply be inspired
by how they work. We are going to think of our learning algorithm
as a single neuron. It receives input from D-many other neurons,
one for each input feature. The strength of these inputs are the fea-
ture values. This is shown schematically in Figure 4.1. Each incom-
ing connection has a weight and the neuron simply sums up all the
weighted inputs. Based on this sum, it decides whether to “ﬁre” or

Figure 4.1: a picture of a neuron

Figure 4.2: ﬁgure showing feature
vector and weight vector and products
and sum

42 a course in machine learning

not. Firing is interpreted as being a positive example and not ﬁring is
interpreted as being a negative example. In particular, if the weighted
sum is positive, it “ﬁres” and otherwise it doesn’t ﬁre. This is shown
diagramatically in Figure 4.2.
Mathematically, an input vector x = (cid:104)x1, x2, . . . , xD(cid:105) arrives. The

neuron stores D-many weights, w1, w2, . . . , wD. The neuron computes
the sum:
D∑

a =

(4.1)

wdxd

d=1

to determine it’s amount of “activation.” If this activiation is posi-
tive (i.e., a > 0) it predicts that this example is a positive example.
Otherwise it predicts a negative example.

The weights of this neuron are fairly easy to interpret. Suppose

that a feature, for instance “is this a System’s class?” gets a zero
weight. Then the activation is the same regardless of the value of
this feature. So features with zero weight are ignored. Features with
positive weights are indicative of positive examples because they
cause the activation to increase. Features with negative weights are
indicative of negative examples because they cause the activiation to
decrease.

It is often convenient to have a non-zero threshold. In other

words, we might want to predict positive if a > θ for some value
θ. The way that is most convenient to achieve this is to introduce a
bias term into the neuron, so that the activation is always increased
by some ﬁxed value b. Thus, we compute:

(4.2)

(cid:35)

(cid:34) D∑

d=1

a =

wdxd

+ b

?

What would happen if we encoded
binary features like “is this a Sys-
tem’s class” as no=0 and yes=−1
(rather than the standard no=0 and
yes=+1)?

This is the complete neural model of learning. The model is pa-
rameterized by D-many weights, w1, w2, . . . , wD, and a single scalar
bias value b.

?

If you wanted the activation thresh-
old to be a > θ instead of a > 0,
what value would b have to be?

4.2 Error-Driven Updating: The Perceptron Algorithm

The perceptron is a classic learning algorithm for the neural model
of learning. Like K-nearest neighbors, it is one of those frustrating
algorithms that is incredibly simple and yet works amazingly well,
for some types of problems.

The algorithm is actually quite different than either the decision
tree algorithm or the KNN algorithm. First, it is online. This means
that instead of considering the entire data set at the same time, it only
ever looks at one example. It processes that example and then goes

the perceptron 43

// initialize weights
// initialize bias

Algorithm 5 PerceptronTrain(D, MaxIter)
1: wd ← 0, for all d = 1 . . . D
2: b ← 0
3: for iter = 1 . . . MaxIter do
4:

for all (x,y) ∈ D do

d=1 wd xd + b

a ← ∑D
if ya ≤ 0 then
wd ← wd + yxd, for all d = 1 . . . D
b ← b + y

5:

6:

7:

8:

9:

// compute activation for this example

// update weights
// update bias

end if
end for

10:
11: end for
12: return w0, w1, . . . , wD, b

Algorithm 6 PerceptronTest(w0, w1, . . . , wD, b, ˆx)
1: a ← ∑D
2: return sign(a)

d=1 wd ˆxd + b

// compute activation for the test example

on to the next one. Second, it is error driven. This means that, so
long as it is doing well, it doesn’t bother updating its parameters.
The algorithm maintains a “guess” at good parameters (weights
and bias) as it runs. It processes one example at a time. For a given
example, it makes a prediction. It checks to see if this prediction
is correct (recall that this is training data, so we have access to true
labels). If the prediction is correct, it does nothing. Only when the
prediction is incorrect does it change its parameters, and it changes
them in such a way that it would do better on this example next
time around. It then goes on to the next example. Once it hits the
last example in the training set, it loops back around for a speciﬁed
number of iterations.

The training algorithm for the perceptron is shown in Algo-

rithm 4.2 and the corresponding prediction algorithm is shown in
Algorithm 4.2. There is one “trick” in the training algorithm, which
probably seems silly, but will be useful later. It is in line 6, when we
check to see if we want to make an update or not. We want to make
an update if the current prediction (just sign(a)) is incorrect. The
trick is to multiply the true label y by the activation a and compare
this against zero. Since the label y is either +1 or −1, you just need
to realize that ya is positive whenever a and y have the same sign.
In other words, the product ya is positive if the current prediction is
correct.

The particular form of update for the perceptron is quite simple.

The weight wd is increased by yxd and the bias is increased by y. The
goal of the update is to adjust the parameters so that they are “bet-
ter” for the current example. In other words, if we saw this example

?

It is very very important to check
ya ≤ 0 rather than ya < 0. Why?

44 a course in machine learning

twice in a row, we should do a better job the second time around.

To see why this particular update achieves this, consider the fol-

lowing scenario. We have some current set of parameters w1, . . . , wD, b.
We observe an example (x, y). For simplicity, suppose this is a posi-
tive example, so y = +1. We compute an activation a, and make an
error. Namely, a < 0. We now update our weights and bias. Let’s call
the new weights w(cid:48)
D, b(cid:48). Suppose we observe the same exam-
ple again and need to compute a new activation a(cid:48). We proceed by a
little algebra:

1, . . . , w(cid:48)

a(cid:48) =

=

=

D∑

d=1

D∑

d=1

D∑

d=1

w(cid:48)
dxd + b(cid:48)

(wd + xd)xd + (b + 1)

wdxd + b +

D∑

d=1

xdxd + 1

= a +

D∑

d=1

x2
d + 1 > a

(4.3)

(4.4)

(4.5)

(4.6)

d + 1. But x2

So the difference between the old activation a and the new activa-
d ≥ 0, since it’s squared. So this value is
tion a(cid:48) is ∑d x2
always at least one. Thus, the new activation is always at least the old
activation plus one. Since this was a positive example, we have suc-
cessfully moved the activation in the proper direction. (Though note
that there’s no guarantee that we will correctly classify this point the
second, third or even fourth time around!)

The only hyperparameter of the perceptron algorithm is MaxIter,

the number of passes to make over the training data. If we make
many many passes over the training data, then the algorithm is likely
to overﬁt. (This would be like studying too long for an exam and just
confusing yourself.) On the other hand, going over the data only
one time might lead to underﬁtting. This is shown experimentally in
Figure 4.3. The x-axis shows the number of passes over the data and
the y-axis shows the training error and the test error. As you can see,
there is a “sweet spot” at which test performance begins to degrade
due to overﬁtting.

One aspect of the perceptron algorithm that is left underspeciﬁed
is line 4, which says: loop over all the training examples. The natural
implementation of this would be to loop over them in a constant
order. The is actually a bad idea.

Consider what the perceptron algorithm would do on a data set

that consisted of 500 positive examples followed by 500 negative
examples. After seeing the ﬁrst few positive examples (maybe ﬁve),
it would likely decide that every example is positive, and would stop

?

This analysis hold for the case pos-
itive examples (y = +1). It should
also hold for negative examples.
Work it out.

Figure 4.3: training and test error via
early stopping

learning anything. It would do well for a while (next 495 examples),
until it hit the batch of negative examples. Then it would take a while
(maybe ten examples) before it would start predicting everything as
negative. By the end of one pass through the data, it would really
only have learned from a handful of examples (ﬁfteen in this case).

So one thing you need to avoid is presenting the examples in some
ﬁxed order. This can easily be accomplished by permuting the order
of examples once in the beginning and then cycling over the data set
in the same (permuted) order each iteration. However, it turns out
that you can actually do better if you re-permute the examples in each
iteration. Figure 4.4 shows the effect of re-permuting on convergence
speed. In practice, permuting each iteration tends to yield about 20%
savings in number of iterations. In theory, you can actually prove that
it’s expected to be about twice as fast.

4.3 Geometric Intrepretation

the perceptron 45

Figure 4.4: training and test error for
permuting versus not-permuting

?

If permuting the data each iteration
saves somewhere between 20% and
50% of your time, are there any
cases in which you might not want
to permute the data every iteration?

A question you should be asking yourself by now is: what does the
decision boundary of a perceptron look like? You can actually answer
that question mathematically. For a perceptron, the decision bound-
ary is precisely where the sign of the activation, a, changes from −1
to +1. In other words, it is the set of points x that achieve zero ac-
tivation. The points that are not clearly positive nor negative. For
simplicity, we’ll ﬁrst consider the case where there is no “bias” term
(or, equivalently, the bias is zero). Formally, the decision boundary B
is:

(cid:40)

(cid:41)

B =

x : ∑
d

wdxd = 0

(4.7)

We can now apply some linear algebra. Recall that ∑d wdxd is just
the dot product between the vector w = (cid:104)w1, w2, . . . , wD(cid:105) and the
vector x. We will write this as w · x. Two vectors have a zero dot
product if and only if they are perpendicular. Thus, if we think of
the weights as a vector w, then the decision boundary is simply the
plane perpendicular to w.

46 a course in machine learning

MATH REVIEW | DOT PRODUCTS
Given two vectors u and v their dot product u · v is ∑d udvd. The dot product
grows large and positive when u and v point in same direction, grows large
and negative when u and v point in opposite directions, and is zero when
their are perpendicular. A useful geometric interpretation of dot products is
projection. Suppose ||u|| = 1, so that u is a unit vector. We can think of any
other vector v as consisting of two components: (a) a component in the di-
rection of u and (b) a component that’s perpendicular to u. This is depicted
geometrically to the right: Here, u = (cid:104)0.8, 0.6(cid:105) and v = (cid:104)0.37, 0.73(cid:105). We
can think of v as the sum of two vectors, a and b, where a is parallel to u and b is perpendicular. The
length of b is exactly u · v = 0.734, which is why you can think of dot products as projections: the dot
product between u and v is the “projection of v onto u.”

Figure 4.5:

This is shown pictorially in Figure 4.6. Here, the weight vector is
shown, together with it’s perpendicular plane. This plane forms the
decision boundary between positive points and negative points. The
vector points in the direction of the positive examples and away from
the negative examples.

One thing to notice is that the scale of the weight vector is irrele-

vant from the perspective of classiﬁcation. Suppose you take a weight
vector w and replace it with 2w. All activations are now doubled.
But their sign does not change. This makes complete sense geometri-
cally, since all that matters is which side of the plane a test point falls
on, now how far it is from that plane. For this reason, it is common
to work with normalized weight vectors, w, that have length one; i.e.,
||w|| = 1.
The geometric intuition can help us even more when we realize
that dot products compute projections. That is, the value w · x is
just the distance of x from the origin when projected onto the vector
w. This is shown in Figure 4.7. In that ﬁgure, all the data points are
projected onto w. Below, we can think of this as a one-dimensional
version of the data, where each data point is placed according to its
projection along w. This distance along w is exactly the activiation of
that example, with no bias.

From here, you can start thinking about the role of the bias term.

Previously, the threshold would be at zero. Any example with a
negative projection onto w would be classiﬁed negative; any exam-
ple with a positive projection, positive. The bias simply moves this
threshold. Now, after the projection is computed, b is added to get
the overall activation. The projection plus b is then compared against

Figure 4.6: picture of data points with
hyperplane and weight vector

?

If I give you a non-zero weight vec-
tor w, how do I compute a weight
vector w(cid:48) that points in the same
direction but has a norm of one?

Figure 4.7: The same picture as before,
but with projections onto weight vector;
then, below, those points along a one-
dimensional axis with zero marked.

uv}a}bthe perceptron 47

Figure 4.8: perc:bias: perceptron
picture with bias

zero.

Thus, from a geometric perspective, the role of the bias is to shift
the decision boundary away from the origin, in the direction of w. It
is shifted exactly −b units. So if b is positive, the boundary is shifted
away from w and if b is negative, the boundary is shifted toward w.
This is shown in Figure 4.8. This makes intuitive sense: a positive
bias means that more examples should be classiﬁed positive. By
moving the decision boundary in the negative direction, more space
yields a positive classiﬁcation.
D dimensional space, it is always a D − 1-dimensional hyperplane.
(In two dimensions, a 1-d hyperplane is simply a line. In three di-
mensions, a 2-d hyperplane is like a sheet of paper.) This hyperplane
divides space in half. In the rest of this book, we’ll refer to the weight
vector, and to hyperplane it deﬁnes, interchangeably.

The decision boundary for a perceptron is a very magical thing. In

The perceptron update can also be considered geometrically. (For

simplicity, we will consider the unbiased case.) Consider the sit-
uation in Figure 4.9. Here, we have a current guess as to the hy-
perplane, and positive training example comes in that is currently
mis-classiﬁed. The weights are updated: w ← w + yx. This yields the
new weight vector, also shown in the Figure. In this case, the weight
vector changed enough that this training example is now correctly
classiﬁed.

4.4

Interpreting Perceptron Weights

Figure 4.9: perceptron picture with
update, no bias

You may ﬁnd yourself having run the perceptron, learned a really
awesome classiﬁer, and then wondering “what the heck is this clas-
siﬁer doing?” You might ask this question because you’re curious to
learn something about the underlying data. You might ask this ques-
tion because you want to make sure that the perceptron is learning
“the right thing.” You might ask this question because you want to
remove a bunch of features that aren’t very useful because they’re
expensive to compute or take a lot of storage.

The perceptron learns a classiﬁer of the form x (cid:55)→ sign (∑d wdxd + b).

A reasonable question to ask is: how sensitive is the ﬁnal classiﬁca-
tion to small changes in some particular feature. We can answer this
question by taking a derivative. If we arbitrarily take the 7th fea-
(∑d wdxd + b) = w7. This says: the rate at
ture we can compute ∂
∂x7
which the activation changes as a function of the 7th feature is ex-
actly w7. This gives rise to a useful heuristic for interpreting percep-
tron weights: sort all the weights from largest (positive) to largest
(negative), and take the top ten and bottom ten. The top ten are the
features that the perceptron is most sensitive to for making positive

48 a course in machine learning

predictions. The bottom ten are the features that the perceptron is
most sensitive to for making negative predictions.

This heuristic is useful, especially when the inputs x consist en-

tirely of binary values (like a bag of words representation). The
heuristic is less useful when the range of the individual features
varies signiﬁcantly. The issue is that if you have one feat x5 that’s ei-
ther 0 or 1, and another feature x7 that’s either 0 or 100, but w5 = w7,
it’s reasonable to say that w7 is more important because it is likely to
have a much larger inﬂuence on the ﬁnal prediction. The easiest way
to compensate for this is simply to scale your features ahead of time:
this is another reason why feature scaling is a useful preprocessing
step.

4.5 Perceptron Convergence and Linear Separability

You already have an intuitive feeling for why the perceptron works:
it moves the decision boundary in the direction of the training exam-
ples. A question you should be asking yourself is: does the percep-
tron converge? If so, what does it converge to? And how long does it
take?

It is easy to construct data sets on which the perceptron algorithm
will never converge. In fact, consider the (very uninteresting) learn-
ing problem with no features. You have a data set consisting of one
positive example and one negative example. Since there are no fea-
tures, the only thing the perceptron algorithm will ever do is adjust
the bias. Given this data, you can run the perceptron for a bajillion
iterations and it will never settle down. As long as the bias is non-
negative, the negative example will cause it to decrease. As long as
it is non-positive, the positive example will cause it to increase. Ad
inﬁnitum. (Yes, this is a very contrived example.)

What does it mean for the perceptron to converge? It means that
it can make an entire pass through the training data without making
any more updates. In other words, it has correctly classiﬁed every
training example. Geometrically, this means that it was found some
hyperplane that correctly segregates the data into positive and nega-
tive examples, like that shown in Figure 4.10.

In this case, this data is linearly separable. This means that there

exists some hyperplane that puts all the positive examples on one side
and all the negative examples on the other side. If the training is not
linearly separable, like that shown in Figure 4.11, then the perceptron
has no hope of converging. It could never possibly classify each point
correctly.

The somewhat surprising thing about the perceptron algorithm is
that if the data is linearly separable, then it will converge to a weight

Figure 4.10: separable data

Figure 4.11: inseparable data

the perceptron 49

vector that separates the data. (And if the data is inseparable, then it
will never converge.) This is great news. It means that the perceptron
converges whenever it is even remotely possible to converge.

The second question is: how long does it take to converge? By

“how long,” what we really mean is “how many updates?” As is the
case for much learning theory, you will not be able to get an answer
of the form “it will converge after 5293 updates.” This is asking too
much. The sort of answer we can hope to get is of the form “it will
converge after at most 5293 updates.”

What you might expect to see is that the perceptron will con-

verge more quickly for easy learning problems than for hard learning
problems. This certainly ﬁts intuition. The question is how to deﬁne
“easy” and “hard” in a meaningful way. One way to make this def-
inition is through the notion of margin. If I give you a data set and
hyperplane that separates itthen the margin is the distance between
the hyperplane and the nearest point. Intuitively, problems with large
margins should be easy (there’s lots of “wiggle room” to ﬁnd a sepa-
rating hyperplane); and problems with small margins should be hard
(you really have to get a very speciﬁc well tuned weight vector).
Formally, given a data set D, a weight vector w and bias b, the

margin of w, b on D is deﬁned as:

(cid:40)

min(x,y)∈D y(cid:0)w · x + b(cid:1)

margin(D, w, b) =

−∞

if w separates D
otherwise

(4.8)

In words, the margin is only deﬁned if w, b actually separate the data
(otherwise it is just −∞). In the case that it separates the data, we
ﬁnd the point with the minimum activation, after the activation is
multiplied by the label.

For some historical reason (that is unknown to the author), mar-
gins are always denoted by the Greek letter γ (gamma). One often
talks about the margin of a data set. The margin of a data set is the
largest attainable margin on this data. Formally:

margin(D) = sup
w,b

margin(D, w, b)

(4.9)

In words, to compute the margin of a data set, you “try” every possi-
ble w, b pair. For each pair, you compute its margin. We then take the
largest of these as the overall margin of the data.1 If the data is not
linearly separable, then the value of the sup, and therefore the value
of the margin, is −∞.

There is a famous theorem due to Rosenblatt2 that shows that the
number of errors that the perceptron algorithm makes is bounded by
γ−2. More formally:

So long as the margin is not −∞,
it is always positive. Geometrically
this makes sense, but why does
Eq (4.8) yield this?

?

1 You can read “sup” as “max” if you
like: the only difference is a technical
difference in how the −∞ case is
handled.
2 Rosenblatt 1958

50 a course in machine learning

Theorem 2 (Perceptron Convergence Theorem). Suppose the perceptron
algorithm is run on a linearly separable data set D with margin γ > 0.
Assume that ||x|| ≤ 1 for all x ∈ D. Then the algorithm will converge after
at most 1

γ2 updates.

The proof of this theorem is elementary, in the sense that it does

not use any fancy tricks: it’s all just algebra. The idea behind the
proof is as follows. If the data is linearly separable with margin γ,
then there exists some weight vector w∗ that achieves this margin.
Obviously we don’t know what w∗ is, but we know it exists. The
perceptron algorithm is trying to ﬁnd a weight vector w that points
roughly in the same direction as w∗. (For large γ, “roughly” can be
very rough. For small γ, “roughly” is quite precise.) Every time the
perceptron makes an update, the angle between w and w∗ changes.
What we prove is that the angle actually decreases. We show this in
two steps. First, the dot product w · w∗ increases a lot. Second, the
norm ||w|| does not increase very much. Since the dot product is
increasing, but w isn’t getting too long, the angle between them has
to be shrinking. The rest is algebra.

Proof of Theorem 2. The margin γ > 0 must be realized by some set
of parameters, say x∗. Suppose we train a perceptron on this data.
Denote by w(0) the initial weight vector, w(1) the weight vector after
the ﬁrst update, and w(k) the weight vector after the kth update. (We
are essentially ignoring data points on which the perceptron doesn’t
update itself.) First, we will show that w∗ · w(k) grows quicky as

a function of k. Second, we will show that(cid:12)(cid:12)(cid:12)(cid:12)w(k)(cid:12)(cid:12)(cid:12)(cid:12) does not grow

quickly.

First, suppose that the kth update happens on example (x, y). We
are trying to show that w(k) is becoming aligned with w∗. Because we
updated, know that this example was misclassiﬁed: yw(k-1) · x < 0.
After the update, we get w(k) = w(k-1) + yx. We do a little computa-
tion:

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)w(k)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2

w∗ · w(k) = w∗ ·(cid:16)

(cid:17)
= w∗ · w(k-1) + yw∗ · x
≥ w∗ · w(k-1) + γ

w(k-1) + yx

deﬁnition of w(k)

(4.10)
(4.11)
(4.12)
Thus, every time w(k) is updated, its projection onto w∗ increases by
at least γ. Therefore: w∗ · w(k) ≥ kγ.
because w(k) is getting closer to w∗, not just because it’s getting ex-
ceptionally long. To do this, we compute the norm of w(k):

Next, we need to show that the increase of γ along w∗ occurs

vector algebra
w∗ has margin γ

def. of w(k)

quadratic rule (4.14)

assumption and a < 0 (4.15)

=

=

+ 1 + 0

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2

+ y2 ||x||2 + 2yw(k-1) · x

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)w(k-1) + yx
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)w(k-1)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2
≤(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)w(k-1)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2
date. Therefore: (cid:12)(cid:12)(cid:12)(cid:12)w(k)(cid:12)(cid:12)(cid:12)(cid:12)2 ≤ k.
that(cid:12)(cid:12)(cid:12)(cid:12)w(k)(cid:12)(cid:12)(cid:12)(cid:12) ≥ w∗ · w(k). Putting this together, we have:
k ≥ (cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)w(k)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) ≥ w∗ · w(k) ≥ kγ

√

Now we put together the two things we have learned before. By
our ﬁrst conclusion, we know w∗ · w(k) ≥ kγ. But our second con-
clusion,

k ≥(cid:12)(cid:12)(cid:12)(cid:12)w(k)(cid:12)(cid:12)(cid:12)(cid:12)2. Finally, because w∗ is a unit vector, we know

√

Thus, the squared norm of w(k) increases by at most one every up-

the perceptron 51

(4.13)

Taking the left-most and right-most terms, we get that
Dividing both sides by k, we get 1√
k
This means that once we’ve made 1
γ2 updates, we cannot make any
more!

k ≥ kγ.
≥ γ and therefore k ≤ 1
γ2 .

(4.16)

√

It is important to keep in mind what this proof shows and what

it does not show. It shows that if I give the perceptron data that
is linearly separable with margin γ > 0, then the perceptron will
converge to a solution that separates the data. And it will converge
quickly when γ is large. It does not say anything about the solution,
other than the fact that it separates the data. In particular, the proof
makes use of the maximum margin separator. But the perceptron
is not guaranteed to ﬁnd this maximum margin separator. The data
may be separable with margin 0.9 and the perceptron might still
ﬁnd a separating hyperplane with a margin of only 0.000001. Later
(in Chapter 7), we will see algorithms that explicitly try to ﬁnd the
maximum margin solution.

4.6

Improved Generalization: Voting and Averaging

In the beginning of this chapter, there was a comment that the per-
ceptron works amazingly well. This was a half-truth. The “vanilla”
perceptron algorithm does well, but not amazingly well. In order to
make it more competitive with other learning algorithms, you need
to modify it a bit to get better generalization. The key issue with the
vanilla perceptron is that it counts later points more than it counts earlier
points.

To see why, consider a data set with 10, 000 examples. Suppose

that after the ﬁrst 100 examples, the perceptron has learned a really

?

Perhaps we don’t want to assume
that all x have norm at most 1. If
they have all have norm at most
R, you can achieve a very simi-
lar bound. Modify the perceptron
convergence proof to handle this
case.

?

Why does the perceptron conver-
gence bound not contradict the
earlier claim that poorly ordered
data points (e.g., all positives fol-
lowed by all negatives) will cause
the perceptron to take an astronom-
ically long time to learn?

52 a course in machine learning

good classiﬁer. It’s so good that it goes over the next 9899 exam-
ples without making any updates. It reaches the 10, 000th example
and makes an error. It updates. For all we know, the update on this
10, 000th example completely ruins the weight vector that has done so
well on 99.99% of the data!

What we would like is for weight vectors that “survive” a long

time to get more say than weight vectors that are overthrown quickly.
One way to achieve this is by voting. As the perceptron learns, it
remembers how long each hyperplane survives. At test time, each
hyperplane encountered during training “votes” on the class of a test
example. If a particular hyperplane survived for 20 examples, then
it gets a vote of 20. If it only survived for one example, it only gets a
vote of 1. In particular, let (w, b)(1), . . . , (w, b)(K) be the K + 1 weight
vectors encountered during training, and c(1), . . . , c(K) be the survival
times for each of these weight vectors. (A weight vector that gets
immediately updated gets c = 1; one that survives another round
gets c = 2 and so on.) Then the prediction on a test point is:

(cid:32) K∑

(cid:16)

w(k) · ˆx + b(k)(cid:17)(cid:33)

ˆy = sign

c(k)sign

(4.17)

k=1

This algorithm, known as the voted perceptron works quite well in
practice, and there is some nice theory showing that it is guaranteed
to generalize better than the vanilla perceptron. Unfortunately, it is
also completely impractical. If there are 1000 updates made during
perceptron learning, the voted perceptron requires that you store
1000 weight vectors, together with their counts. This requires an
absurd amount of storage, and makes prediction 1000 times slower
than the vanilla perceptron.

A much more practical alternative is the averaged perceptron.

The idea is similar: you maintain a collection of weight vectors and
survival times. However, at test time, you predict according to the
average weight vector, rather than the voting. In particular, the predic-
tion is:

c(k)(cid:16)

w(k) · ˆx + b(k)(cid:17)(cid:33)

(cid:32) K∑

k=1

ˆy = sign

The only difference between the voted prediction, Eq (4.17), and the
averaged prediction, Eq (4.18), is the presense of the interior sign
operator. With a little bit of algebra, we can rewrite the test-time
prediction as:

(cid:33)

(4.18)

(4.19)

(cid:33)

(cid:32)(cid:32) K∑

k=1

ˆy = sign

c(k)w(k)

· ˆx +

K∑

k=1

c(k)b(k)

The advantage of the averaged perceptron is that we can simply
maintain a running sum of the averaged weight vector (the blue term)

?

The training algorithm for the voted
perceptron is the same as the
vanilla perceptron. In particular,
in line 5 of Algorithm 4.2, the ac-
tivation on a training example is
computed based on the current
weight vector, not based on the voted
prediction. Why?

the perceptron 53

Algorithm 7 AveragedPerceptronTrain(D, MaxIter)
1: w ← (cid:104)0, 0, . . . 0(cid:105)
2: u ← (cid:104)0, 0, . . . 0(cid:105)
3: c ← 1
4: for iter = 1 . . . MaxIter do
5:

b ← 0
,
, β ← 0

// initialize weights and bias
// initialize cached weights and bias
// initialize example counter to one

if y(w · x + b) ≤ 0 then

for all (x,y) ∈ D do
w ← w + y x
b ← b + y
u ← u + y c x
β ← β + y c

6:

7:

8:

9:

10:

11:

12:

end if
c ← c + 1

end for

13:
14: end for
15: return w - 1

c u, b - 1

c β

// update weights
// update bias
// update cached weights
// update cached bias

// increment counter regardless of update

// return averaged weights and bias

and averaged bias (the red term). Test-time prediction is then just as
efﬁcient as it is with the vanilla perceptron.

The full training algorithm for the averaged perceptron is shown
in Algorithm 4.6. Some of the notation is changed from the original
perceptron: namely, vector operations are written as vector opera-
tions, and the activation computation is folded into the error check-
ing.

It is probably not immediately apparent from Algorithm 4.6 that

the computation unfolding is precisely the calculation of the averaged
weights and bias. The most natural implementation would be to keep
track of an averaged weight vector u. At the end of every example,
you would increase u ← u + w (and similarly for the bias). However,
such an implementation would require that you updated the aver-
aged vector on every example, rather than just on the examples that
were incorrectly classiﬁed! Since we hope that eventually the per-
ceptron learns to do a good job, we would hope that it will not make
updates on every example. So, ideally, you would like to only update
the averaged weight vector when the actual weight vector changes.
The slightly clever computation in Algorithm 4.6 achieves this.

The averaged perceptron is almost always better than the percep-
tron, in the sense that it generalizes better to test data. However, that
does not free you from having to do early stopping. It will, eventu-
ally, overﬁt.

4.7 Limitations of the Perceptron

Although the perceptron is very useful, it is fundamentally limited in
a way that neither decision trees nor KNN are. Its limitation is that

?

By writing out the computation of
the averaged weights from Eq (4.18)
as a telescoping sum, derive the
computation from Algorithm 4.6.

54 a course in machine learning

its decision boundaries can only be linear. The classic way of showing
this limitation is through the XOR problem (XOR = exclusive or). The
XOR problem is shown graphically in Figure 4.12. It consists of four
data points, each at a corner of the unit square. The labels for these
points are the same, along the diagonals. You can try, but you will
not be able to ﬁnd a linear decision boundary that perfectly separates
these data points.

One question you might ask is: do XOR-like problems exist in

the real world? Unfortunately for the perceptron, the answer is yes.
Consider a sentiment classiﬁcation problem that has three features
that simply say whether a given word is contained in a review of
a course. These features are: excellent, terrible and not. The
excellent feature is indicative of positive reviews and the terrible
feature is indicative of negative reviews. But in the presence of the
not feature, this categorization ﬂips.

One way to address this problem is by adding feature combina-
tions. We could add two additional features: excellent-and-not
and terrible-and-not that indicate a conjunction of these base
features. By assigning weights as follows, you can achieve the desired
effect:

wexecellent = +1
wexecllent-and-not = −2

wterrible = −1
wterrible-and-not = +2

wnot = 0

In this particular case, we have addressed the problem. However, if
we start with D-many features, if we want to add all pairs, we’ll blow
2 ) = O(D2) features through this feature mapping. And
up to (D
there’s no guarantee that pairs of features is enough. We might need
3 ) = O(D2) features. These
triples of features, and now we’re up to (D
additional features will drastically increase computation and will
often result in a stronger propensity to overﬁtting.

In fact, the “XOR problem” is so signiﬁcant that it basically killed

research in classiﬁers with linear decision boundaries for a decade
or two. Later in this book, we will see two alternative approaches to
taking key ideas from the perceptron and generating classiﬁers with
non-linear decision boundaries. One approach is to combine multi-
ple perceptrons in a single framework: this is the neural networks
approach (see Chapter 10). The second approach is to ﬁnd computa-
tionally efﬁcient ways of doing feature mapping in a computationally
and statistically efﬁcient way: this is the kernels approach (see Chap-
ter 11).

4.8 Further Reading

TODO further reading

Figure 4.12: picture of xor problem

?

Suppose that you took the XOR
problem and added one new fea-
ture: x3 = x1 ∧ x2 (the logical and
of the two existing features). Write
out feature weights and a bias that
would achieve perfect classiﬁcation
on this data.

5 | PRACTICAL ISSUES

A ship in port is safe, but that is not what ships are for.
Grace Hopper

–

At this point, you have seen three qualitatively different models
for learning: decision trees, nearest neighbors, and perceptrons. You
have also learned about clustering with the K-means algorithm. You
will shortly learn about more complex models, most of which are
variants on things you already know. However, before attempting
to understand more complex models of learning, it is important to
have a ﬁrm grasp on how to use machine learning in practice. This
chapter is all about how to go from an abstract learning problem
to a concrete implementation. You will see some examples of “best
practices” along with justiﬁcations of these practices.

In many ways, going from an abstract problem to a concrete learn-

ing task is more of an art than a science. However, this art can have
a huge impact on the practical performance of learning systems. In
many cases, moving to a more complicated learning algorithm will
gain you a few percent improvement. Going to a better representa-
tion will gain you an order of magnitude improvement. To this end,
we will discuss several high level ideas to help you develop a better
artistic sensibility.

5.1 The Importance of Good Features

Consider a problem of object recognition from images. If you start

Machine learning is magical. You give it data and it manages to
classify that data. For many, it can actually outperform a human! But,
like so many problems in the world, there is a signiﬁcant “garbage
in, garbage out” aspect to machine learning. If the data you give it is
trash, the learning algorithm is unlikely to be able to overcome it.
with a 100×100 pixel image, a very easy feature representation of
this image is as a 30, 000 dimensional vector, where each dimension
corresponds to the red, green or blue component of some pixel in
the image. So perhaps feature 1 is the amount of red in pixel (1, 1);
feature 2 is the amount of green in that pixel; and so on. This is the
pixel representation of images.

Learning Objectives:
• Translate between a problem de-
scription and a concrete learning
problem.

• Perform basic feature engineering on

image and text data.

• Explain how to use cross-validation

to tune hyperparameters and esti-
mate future performance.

• Compare and contrast the differ-
ences between several evaluation
metrics.

• Explain why feature combinations

are important for learning with
some models but not others.

• Explain the relationship between the

three learning techniques you have
seen so far.

• Apply several debugging techniques

to learning algorithms.

Dependencies: Chapter 1,Chap-
ter 3,Chapter 4

Figure 5.1: object recognition in pixels

56 a course in machine learning

One thing to keep in mind is that the pixel representation throws

away all locality information in the image. Learning algorithms don’t
care about features: they only care about feature values. So I can
permute all of the features, with no effect on the learning algorithm
(so long as I apply the same permutation to all training and test
examples). Figure 5.1 shows some images whose pixels have been
randomly permuted (in this case only the pixels are permuted, not
the colors). All of these objects are things that you’ve seen plenty of
examples of; can you identify them? Should you expect a machine to
be able to?

An alternative representation of images is the patch represen-

tation, where the unit of interest is a small rectangular block of an
image, rather than a single pixel. Again, permuting the patches has
no effect on the classiﬁer. Figure 5.2 shows the same images in patch
representation. Can you identify them? A ﬁnal representation is a
shape representation. Here, we throw out all color and pixel infor-
mation and simply provide a bounding polygon. Figure 5.3 shows
the same images in this representation. Is this now enough to iden-
tify them? (If not, you can ﬁnd the answers in Figure 5.15 at the end
of the chapter.)

In the context of text categorization (for instance, the sentiment
recognition task), one standard representation is the bag of words
representation. Here, we have one feature for each unique word that
appears in a document. For the feature happy, the feature value is
the number of times that the word “happy” appears in the document.
The bag of words (BOW) representation throws away all position
information. Table 5.1 shows a BOW representation for two chapters
of this book. Can you tell which is which?

5.2

Irrelevant and Redundant Features

One big difference between learning models is how robust they are to
the addition of noisy or irrelevant features. Intuitively, an irrelevant
feature is one that is completely uncorrelated with the prediction
task. A feature f whose expectation does not depend on the label
E[ f | Y] = E[ f ] might be irrelevant. For instance, the presence of
the word “the” might be largely irrelevant for predicting whether a
course review is positive or negative.

A secondary issue is how well these algorithms deal with redun-

dant features. Two features are redundant if they are highly cor-
related, regardless of whether they are correlated with the task or
not. For example, having a bright red pixel in an image at position
(20, 93) is probably highly redundant with having a bright red pixel
at position (21, 93). Both might be useful (e.g., for identifying ﬁre hy-

Figure 5.2: object recognition in patches

Figure 5.3: object recognition in shapes

data learning
training set
predict
fea-
ture function
test machine
loss alice tree
guess
features
algorithm

data knn
dimensions
points
fea-
ture ﬁgure
decision fea-
tures point
ﬁg training
set
space
examples

Table 5.1: Bag of (most frequent) words
representation for the Decision Tree
and KNN chapters of this book, after
dropping high frequency words like
“the”.

Figure 5.4: prac:bow: BOW repr of one
positive and one negative review

practical issues

57

?

Is it possible to have a feature f
whose expectation does not depend
on the label, but is nevertheless still
useful for prediction?

1 You might think it’s absurd to have
so many irrelevant features, but the
cases you’ve seen so far (bag of words,
bag of pixels) are both reasonable
examples of this! How many words,
out of the entire English vocabulary
(roughly 10, 000 − 100, 000 words), are
actually useful for predicting positive
and negative course reviews?

drants), but because of how images are structured, these two features
are likely to co-occur frequently.

When thinking about robustness to irrelevant or redundant fea-

tures, it is usually not worthwhile thinking of the case where one has
999 great features and 1 bad feature. The interesting case is when the
bad features outnumber the good features, and often outnumber by a
large degree. The question is how robust are algorithms in this case.1

For shallow decision trees, the model explicitly selects features

that are highly correlated with the label. In particular, by limiting the
depth of the decision tree, one can at least hope that the model will be
able to throw away irrelevant features. Redundant features are almost
certainly thrown out: once you select one feature, the second feature
now looks mostly useless. The only possible issue with irrelevant
features is that even though they’re irrelevant, they happen to correlate
with the class label on the training data, but chance.

As a thought experiment, suppose that we have N training ex-

amples, and exactly half are positive examples and half are negative
examples. Suppose there’s some binary feature, f , that is completely
uncorrelated with the label. This feature has a 50/50 chance of ap-
pearing in any example, regardless of the label. In principle, the deci-
sion tree should not select this feature. But, by chance, especially if N
is small, the feature might look correlated with the label. This is anal-
ogous to ﬂipping two coins simultaneously N times. Even though the
coins are independent, it’s entirely possible that you will observe a
sequence like (H, H), (T, T), (H, H), (H, H), which makes them look
entirely correlated! The hope is that as N grows, this becomes less
and less likely. In fact, we can explicitly compute how likely this is to
happen.

To do this, let’s ﬁx the sequence of N labels. We now ﬂip a coin N

times and consider how likely it is that it exactly matches the label.
This is easy: the probability is 0.5N. Now, we would also be confused
if it exactly matched not the label, which has the same probability. So
the chance that it looks perfectly correlated is 0.5N + 0.5N = 0.5N−1.
Thankfully, this shrinks down very small (e.g., 10−6) after only 21
data points, meaning that even with a very small training set, the
chance that a random feature happens to correlate exactly with the
label is tiny.

This makes us happy. The problem is that we don’t have one irrel-
evant feature: we have many! If we randomly pick two irrelevant fea-
tures, each has the same probability of perfectly correlating: 0.5N−1.
But since there are two and they’re independent coins, the chance
that either correlates perfectly is 2×0.5N−1 = 0.5N−2. In general,
if we have K irrelevant features, all of which are random indepen-
dent coins, the chance that at least one of them perfectly correlates is

58 a course in machine learning

0.5N−K. This suggests that if we have a sizeable number K of irrele-
vant features, we’d better have at least K + 21 training examples.
Unfortunately, the situation is actually worse than this. In the

above analysis we only considered the case of perfect correlation. We
could also consider the case of partial correlation, which would yield
even higher probabilities. Sufﬁce it to say that even decision trees can
become confused.

In the case of K-nearest neighbors, the situation is perhaps more

dire. Since KNN weighs each feature just as much as another feature,
the introduction of irrelevant features can completely mess up KNN
prediction. In fact, as you saw, in high dimensional space, randomly
distributed points all look approximately the same distance apart. If
we add lots and lots of randomly distributed features to a data set,
then all distances still converge.

In the case of the perceptron, one can hope that it might learn to

assign zero weight to irrelevant features. For instance, consider a
binary feature is randomly one or zero independent of the label. If
the perceptron makes just as many updates for positive examples
as for negative examples, there is a reasonable chance this feature
weight will be zero. At the very least, it should be small.

5.3 Feature Pruning and Normalization

In text categorization problems, some words simply do not appear
very often. Perhaps the word “groovy”2 appears in exactly one train-
ing document, which is positive. Is it really worth keeping this word
around as a feature? It’s a dangerous endeavor because it’s hard to
tell with just one training example if it is really correlated with the
positive class, or is it just noise. You could hope that your learning
algorithm is smart enough to ﬁgure it out. Or you could just remove
it. That means that (a) the learning algorithm won’t have to ﬁgure it
out, and (b) you’ve reduced the number of dimensions you have, so
things should be more efﬁcient, and less “scary.”

This idea of feature pruning is very useful and applied in many
applications. It is easiest in the case of binary features. If a binary
feature only appears some small number K times (in the training
data: no fair looking at the test data!), you simply remove it from
consideration. (You might also want to remove features that appear
in all-but-K many documents, for instance the word “the” appears in
pretty much every English document ever written.) Typical choices
for K are 1, 2, 5, 10, 20, 50, mostly depending on the size of the data.
On a text data set with 1000 documents, a cutoff of 5 is probably
reasonable. On a text data set the size of the web, a cut of 50 or even
100 or 200 is probably reasonable3. Figure 5.6 shows the effect of

Figure 5.5: prac:addirrel: data from
high dimensional warning, interpolated

?

What happens with the perceptron
with truly redundant features (i.e.,
one is literally a copy of the other)?

2 This is typically positive indicator,
or at least it was back in the US in the
1970s.

Figure 5.6: prac:pruning: effect of
pruning on text data
3 According to Google, the following
words (among many others) appear
200 times on the web: moudlings, agag-
gagctg, setgravity, rogov, prosomeric,
spunlaid, piyushtwok, telelesson, nes-
mysl, brighnasa. For comparison, the
word “the” appears 19, 401, 194, 714 (19
billion) times.

practical issues

59

MATH REVIEW | DATA STATISTICS: MEANS AND VARIANCES
We often need to discuss various statistics of a data set. Most often, it is enough to consider univariate
(one-dimensional) data. Suppose we have N real valued numbers z1, z2, . . . , zN. The sample mean (or
N ∑n zn. The sample
just mean) of these numbers is just their average value, or expected value: µ = 1
∑n(zn − µ)2,
variance (or just variance) measures how much they vary around their mean: σ2 = 1
N−1
where µ is the sample mean.

The mean and variance have convenient interpretations in terms of prediction. Suppose we wanted
to choose a single constant value to “predict” the next z, and were minimizing squared error. Call
this constant value a. Then a = argmina∈R
2 is for convenience and does
∑n(a − zn)2
not change the answer.) To solve for a, we can take derivatives and set to zero: ∂
=
∂a
∑n(a − zn) = Na − ∑n zn; therefore Na = ∑n zn and a = µ. This means that the sample mean is
the number that minimizes squared error to the sample. Moreover, the variance is propotional to the
squared error of that “predictor.”

∑n(a − zn)2. (Here, the 1

1
2

1
2

pruning on a sentiment analysis task. In the beginning, pruning does
not hurt (and sometimes helps!) but eventually we prune away all the
interesting words and performance suffers.

In the case of real-valued features, the question is how to extend
the idea of “does not occur much” to real values. A reasonable def-
inition is to look for features with low variance. In fact, for binary
features, ones that almost never appear or almost always appear will
also have low variance. Figure 5.8 shows the result of pruning low-
variance features on the digit recognition task. Again, at ﬁrst pruning
does not hurt (and sometimes helps!) but eventually we have thrown
out all the useful features.

It is often useful to normalize the data so that it is consistent in
some way. There are two basic types of normalization: feature nor-
malization and example normalization. In feature normalization,
you go through each feature and adjust it the same way across all
examples. In example normalization, each example is adjusted indi-
vidually.

The goal of both types of normalization is to make it easier for your

learning algorithm to learn. In feature normalization, there are two
standard things to do:

1. Centering: moving the entire data set so that it is centered around

the origin.

2. Scaling: rescaling each feature so that one of the following holds:

(a) Each feature has variance 1 across the training data.

Figure 5.7:

Figure 5.8: prac:variance: effect of
pruning on vision

?

Earlier we discussed the problem
of scale of features (e.g., millimeters
versus centimeters). Does this have
an impact on variance-based feature
pruning?

Figure 5.9: prac:transform: picture

60 a course in machine learning

(b) Each feature has maximum absolute value 1 across the train-

ing data.

These transformations are shown geometrically in Figure 5.9. The
goal of centering is to make sure that no features are arbitrarily large.
The goal of scaling is to make sure that all features have roughly the
same scale (to avoid the issue of centimeters versus millimeters).

These computations are fairly straightforward. Here, xn,d refers

to the dth feature of example n. Since it is very rare to apply scaling
without previously applying centering, the expressions below for
scaling assume that the data is already centered.
xn,d ← xn,d − µd
xn,d ← xn,d/σd
xn,d ← xn,d/rd
∑
xn,d
µd =
n

Centering:
Variance Scaling:
Absolute Scaling:

where:

(5.1)
(5.2)
(5.3)
(5.4)

1
N

(cid:115)

σd =

rd = max

n

1

N − 1

(cid:12)(cid:12)xn,d

(xn,d − µd)2

∑
n

(cid:12)(cid:12)

(5.5)

(5.6)

?

For the three models you know
about (KNN, DT, Perceptron),
which are most sensitive to center-
ing? Which are most sensitive to
scaling?

In practice, if the dynamic range of your features is already some
subset of [−2, 2] or [−3, 3], then it is probably not worth the effort of
centering and scaling. (It’s an effort because you have to keep around
your centering and scaling calculations so that you can apply them
to the test data as well!) However, if some of your features are orders
of magnitude larger than others, it might be helpful. Remember that
you might know best: if the difference in scale is actually signiﬁcant
for your problem, then rescaling might throw away useful informa-
tion.

One thing to be wary of is centering binary data. In many cases,

binary data is very sparse: for a given example, only a few of the
features are “on.” For instance, out of a vocabulary of 10, 000 or
100, 000 words, a given document probably only contains about 100.
From a storage and computation perspective, this is very useful.
However, after centering, the data will no longer be sparse and you
will pay dearly with outrageously slow implementations.

In example normalization, you view examples one at a time. The

most standard normalization is to ensure that the length of each
example vector is one: namely, each example lies somewhere on the
unit hypersphere. This is a simple transformation:

Example Normalization:

xn ← xn/ ||xn||

(5.7)

Figure 5.10: prac:exnorm: example of
example normalization

This transformation is depicted in Figure 5.10.

The main advantage to example normalization is that it makes
comparisons more straightforward across data sets. If I hand you
two data sets that differ only in the norm of the feature vectors (i.e.,
one is just a scaled version of the other), it is difﬁcult to compare the
learned models. Example normalization makes this more straightfor-
ward. Moreover, as you saw in the perceptron convergence proof, it is
often just mathematically easier to assume normalized data.

5.4 Combinatorial Feature Explosion

You learned in Chapter 4 that linear models (like the perceptron)
cannot solve the XOR problem. You also learned that by performing
a combinatorial feature explosion, they could. But that came at the
computational expense of gigantic feature vectors.

Of the algorithms that you’ve seen so far, the perceptron is the one

that has the most to gain by feature combination. And the decision
tree is the one that has the least to gain. In fact, the decision tree
construction is essentially building meta features for you. (Or, at
least, it is building meta features constructed purely through “logical
ands.”)

This observation leads to a heuristic for constructing meta features

for perceptrons from decision trees. The idea is to train a decision
tree on the training data. From that decision tree, you can extract
meta features by looking at feature combinations along branches. You
can then add only those feature combinations as meta features to the
feature set for the perceptron. Figure 5.11 shows a small decision tree
and a set of meta features that you might extract from it. There is a
hyperparameter here of what length paths to extract from the tree: in
this case, only paths of length two are extracted. For bigger trees, or
if you have more data, you might beneﬁt from longer paths.

In addition to combinatorial transformations, the logarithmic

transformation can be quite useful in practice. It seems like a strange
thing to be useful, since it doesn’t seem to fundamentally change
the data. However, since many learning algorithms operate by linear
operations on the features (both perceptron and KNN do this), the
log-transform is a way to get product-like operations. The question is
which of the following feels more applicable to your data: (1) every
time this feature increases by one, I’m equally more likely to predict
a positive label; (2) every time this feature doubles, I’m equally more
like to predict a positive label. In the ﬁrst case, you should stick
with linear features and in the second case you should switch to
a log-transform. This is an important transformation in text data,
where the presence of the word “excellent” once is a good indicator
of a positive review; seeing “excellent” twice is a better indicator;

practical issues

61

Figure 5.11: prac:dttoperc: turning a
DT into a set of meta features

Figure 5.12: prac:log: performance on
text categ with word counts versus log
word counts

62 a course in machine learning

but the difference between seeing “excellent” 10 times and seeing it
11 times really isn’t a big deal any more. A log-transform achieves
this. Experimentally, you can see the difference in test performance
between word count data and log-word count data in Figure 5.12.
Here, the transformation is actually xd (cid:55)→ log2(xd + 1) to ensure that
zeros remain zero and sparsity is retained. In the case that feature
values can also be negative, the slightly more complex mapping
xd (cid:55)→ log2(|xd| + 1)sign(xd), where sign(xd) denotes the sign of xd.

5.5 Evaluating Model Performance

So far, our focus has been on classiﬁers that achieve high accuracy.
In some cases, this is not what you might want. For instance, if you
are trying to predict whether a patient has cancer or not, it might be
better to err on one side (saying they have cancer when they don’t)
than the other (because then they die). Similarly, letting a little spam
slip through might be better than accidentally blocking one email
from your boss.

There are two major types of binary classiﬁcation problems. One

is “X versus Y.” For instance, positive versus negative sentiment.
Another is “X versus not-X.” For instance, spam versus non-spam.
(The argument being that there are lots of types of non-spam.) Or
in the context of web search, relevant document versus irrelevant
document. This is a subtle and subjective decision. But “X versus not-
X” problems often have more of the feel of “X spotting” rather than
a true distinction between X and Y. (Can you spot the spam? can you
spot the relevant documents?)

For spotting problems (X versus not-X), there are often more ap-
propriate success metrics than accuracy. A very popular one from
information retrieval is the precision/recall metric. Precision asks
the question: of all the X’s that you found, how many of them were
actually X’s? Recall asks: of all the X’s that were out there, how many
of them did you ﬁnd?4 Formally, precision and recall are deﬁned as:

P =

R =

I
S
I
T

S = number of Xs that your system found
T = number of Xs in the data
I = number of correct Xs that your system found

(5.8)

(5.9)
(5.10)
(5.11)
(5.12)

Here, S is mnemonic for “System,” T is mnemonic for “Truth” and I
is mnemonic for “Intersection.” It is generally accepted that 0/0 = 1
in these deﬁnitions. Thus, if you system found nothing, your preci-

4 A colleague make the analogy to the
US court system’s saying “Do you
promise to tell the whole truth and
nothing but the truth?” In this case, the
“whole truth” means high recall and
“nothing but the truth” means high
precision.”

sion is always perfect; and if there is nothing to ﬁnd, your recall is
always perfect.

Once you can compute precision and recall, you are often able to

produce precision/recall curves. Suppose that you are attempting
to identify spam. You run a learning algorithm to make predictions
on a test set. But instead of just taking a “yes/no” answer, you allow
your algorithm to produce its conﬁdence. For instance, in perceptron,
you might use the distance from the hyperplane as a conﬁdence
measure. You can then sort all of your test emails according to this
ranking. You may put the most spam-like emails at the top and the
least spam-like emails at the bottom, like in Figure 5.13.

Once you have this sorted list, you can choose how aggressively
you want your spam ﬁlter to be by setting a threshold anywhere on
this list. One would hope that if you set the threshold very high, you
are likely to have high precision (but low recall). If you set the thresh-
old very low, you’ll have high recall (but low precision). By consider-
ing every possible place you could put this threshold, you can trace out
a curve of precision/recall values, like the one in Figure 5.14. This
allows us to ask the question: for some ﬁxed precision, what sort of
recall can I get. Obviously, the closer your curve is to the upper-right
corner, the better. And when comparing learning algorithms A and
B you can say that A dominates B if A’s precision/recall curve is
always higher than B’s.

Precision/recall curves are nice because they allow us to visualize
many ways in which we could use the system. However, sometimes
we like to have a single number that informs us of the quality of the
solution. A popular way of combining precision and recall into a
single number is by taking their harmonic mean. This is known as
the balanced f-measure (or f-score):

F =

2×P×R
P + R

(5.13)

The reason that you want to use a harmonic mean rather than an
arithmetic mean (the one you’re more used to) is that it favors sys-
tems that achieve roughly equal precision and recall. In the extreme
case where P = R, then F = P = R. But in the imbalanced case, for
instance P = 0.1 and R = 0.9, the overall f-measure is a modest 0.18.
Table 5.2 shows f-measures as a function of precision and recall, so
that you can see how important it is to get balanced values.

In some cases, you might believe that precision is more impor-
tant than recall. This idea leads to the weighted f-measure, which is
parameterized by a weight β ∈ [0, ∞) (beta):

Fβ =

(1 + β2)×P×R

β2×P + R

(5.14)

practical issues

63

Figure 5.13: prac:spam: show a bunch
of emails spam/nospam sorted by
model predicion, not perfect
?

How would you get a conﬁdence
out of a decision tree or KNN?

Figure 5.14: prac:prcurve: precision
recall curve
0.0
0.00
0.00
0.00
0.00
0.00
0.00

0.8
0.00
0.0
0.32
0.2
0.4
0.53
0.68
0.6
0.80
0.8
1.0
0.88
Table 5.2: Table of f-measures when
varying precision and recall values.

0.6
0.00
0.30
0.48
0.60
0.68
0.74

0.2
0.00
0.20
0.26
0.30
0.32
0.33

0.4
0.00
0.26
0.40
0.48
0.53
0.57

1.0
0.00
0.33
0.57
0.74
0.88
1.00

64 a course in machine learning

For β = 1, this reduces to the standard f-measure. For β = 0, it
focuses entirely on recall and for β → ∞ it focuses entirely on preci-
sion. The interpretation of the weight is that Fβ measures the perfor-
mance for a user who cares β times as much about precision as about
recall.

One thing to keep in mind is that precision and recall (and hence
f-measure) depend crucially on which class is considered the thing
you wish to ﬁnd. In particular, if you take a binary data set if ﬂip
what it means to be a positive or negative example, you will end
up with completely difference precision and recall values. It is not
the case that precision on the ﬂipped task is equal to recall on the
original task (nor vice versa). Consequently, f-measure is also not the
same. For some tasks where people are less sure about what they
want, they will occasionally report two sets of precision/recall/f-
measure numbers, which vary based on which class is considered the
thing to spot.

There are other standard metrics that are used in different com-
munities. For instance, the medical community is fond of the sensi-
tivity/speciﬁcity metric. A sensitive classiﬁer is one which almost
always ﬁnds everything it is looking for: it has high recall. In fact,
sensitivity is exactly the same as recall. A speciﬁc classiﬁer is one
which does a good job not ﬁnding the things that it doesn’t want to
ﬁnd. Speciﬁcity is precision on the negation of the task at hand.

You can compute curves for sensitivity and speciﬁcity much like
those for precision and recall. The typical plot, referred to as the re-
ceiver operating characteristic (or ROC curve) plots the sensitivity
against 1 − speciﬁcity. Given an ROC curve, you can compute the
area under the curve (or AUC) metric, which also provides a mean-
ingful single number for a system’s performance. Unlike f-measures,
which tend to be low because the require agreement, AUC scores
tend to be very high, even for not great systems. This is because ran-
dom chance will give you an AUC of 0.5 and the best possible AUC
is 1.0.

The main message for evaluation metrics is that you should choose

whichever one makes the most sense. In many cases, several might
make sense. In that case, you should do whatever is more commonly
done in your ﬁeld. There is no reason to be an outlier without cause.

5.6 Cross Validation

In Chapter 1, you learned about using development data (or held-out
data) to set hyperparameters. The main disadvantage to the develop-
ment data approach is that you throw out some of your training data,
just for estimating one or two hyperparameters.

practical issues

65

Algorithm 8 CrossValidate(LearningAlgorithm, Data, K)
1: ˆ ← ∞
2: ˆα ← unknown
3: for all hyperparameter settings α do
4:

// store lowest error encountered so far
// store the hyperparameter setting that yielded it

// keep track of the K-many error estimates

err ← [ ]
for k = 1 to K do

5:

6:

7:

8:

9:

10:

11:

12:

13:

14:

train ← {(xn, yn) ∈ Data : n mod K (cid:54)= k − 1}
test ← {(xn, yn) ∈ Data : n mod K = k − 1} // test every Kth example
model ← Run LearningAlgorithm on train
err ← err ⊕ error of model on test

// add current error to list of errors

end for
avgErr ← mean of set err
if avgErr < ˆ then

ˆ ← avgErr
ˆα ← α

// remember these settings
// because they’re the best so far

end if
15:
16: end for

An alternative is the idea of cross validation. In cross validation,

you break your training data up into 10 equally-sized partitions. You
train a learning algorithm on 9 of them and test it on the remaining
1. You do this 10 times, each time holding out a different partition as
the “development” part. You can then average your performance over
all ten parts to get an estimate of how well your model will perform
in the future. You can repeat this process for every possible choice of
hyperparameters to get an estimate of which one performs best. The
general K-fold cross validation technique is shown in Algorithm 5.6,
where K = 10 in the preceeding discussion.

In fact, the development data approach can be seen as an approxi-
mation to cross validation, wherein only one of the K loops (line 5 in
Algorithm 5.6) is executed.
Typical choices for K are 2, 5, 10 and N − 1. By far the most com-

mon is K = 10: 10-fold cross validation. Sometimes 5 is used for
efﬁciency reasons. And sometimes 2 is used for subtle statistical rea-
sons, but that is quite rare. In the case that K = N − 1, this is known
as leave-one-out cross validation (or abbreviated as LOO cross val-
idation). After running cross validation, you have two choices. You
can either select one of the K trained models as your ﬁnal model to
make predictions with, or you can train a new model on all of the
data, using the hyperparameters selected by cross-validation. If you
have the time, the latter is probably a better options.

It may seem that LOO cross validation is prohibitively expensive
to run. This is true for most learning algorithms except for K-nearest
neighbors. For KNN, leave-one-out is actually very natural. We loop
through each training point and ask ourselves whether this example
would be correctly classiﬁed for all different possible values of K.

66 a course in machine learning

Algorithm 9 KNN-Train-LOO(D)
1: errk ← 0, ∀1 ≤ k ≤ N − 1
2: for n = 1 to N do
3:

Sm ← (cid:104)||xn − xm|| , m(cid:105), ∀m (cid:54)= n
S ← sort(S)
ˆy ← 0
for k = 1 to N − 1 do

(cid:104)dist,m(cid:105) ← Sk
ˆy ← ˆy + ym
if ˆy (cid:54)= ym then

errk ← errk + 1

4:

5:

6:

7:

8:

9:

10:

11:

end if
end for

12:
13: end for
14: return argmink errk

// errk stores how well you do with kNN

// compute distances to other points
// put lowest-distance objects ﬁrst
// current label prediction

// let kth closest point vote

// one more error for kNN

// return the K that achieved lowest error

This requires only as much computation as computing the K nearest
neighbors for the highest value of K. This is such a popular and
effective approach for KNN classiﬁcation that it is spelled out in
Algorithm 5.6.

Overall, the main advantage to cross validation over develop-

ment data is robustness. The main advantage of development data is
speed.

One warning to keep in mind is that the goal of both cross valida-
tion and development data is to estimate how well you will do in the
future. This is a question of statistics, and holds only if your test data
really looks like your training data. That is, it is drawn from the same
distribution. In many practical cases, this is not entirely true.

For example, in person identiﬁcation, we might try to classify

every pixel in an image based on whether it contains a person or not.
If we have 100 training images, each with 10, 000 pixels, then we have
a total of 1m training examples. The classiﬁcation for a pixel in image
5 is highly dependent on the classiﬁcation for a neighboring pixel in
the same image. So if one of those pixels happens to fall in training
data, and the other in development (or cross validation) data, your
model will do unreasonably well. In this case, it is important that
when you cross validate (or use development data), you do so over
images, not over pixels. The same goes for text problems where you
sometimes want to classify things at a word level, but are handed a
collection of documents. The important thing to keep in mind is that
it is the images (or documents) that are drawn independently from
your data distribution and not the pixels (or words), which are drawn
dependently.

5.7 Hypothesis Testing and Statistical Signiﬁcance

Suppose that you’ve presented a machine learning solution to your
boss that achieves 7% error on cross validation. Your nemesis, Gabe,
gives a solution to your boss that achieves 6.9% error on cross vali-
dation. How impressed should your boss be? It depends. If this 0.1%
improvement was measured over 1000 examples, perhaps not too
impressed. It would mean that Gabe got exactly one more example
right than you did. (In fact, they probably got 15 more right and 14
more wrong.) If this 0.1% impressed was measured over 1, 000, 000
examples, perhaps this is more impressive.

This is one of the most fundamental questions in statistics. You
have a scientiﬁc hypothesis of the form “Gabe’s algorithm is better
than mine.” You wish to test whether this hypothesis is true. You
are testing it against the null hypothesis, which is that Gabe’s algo-
rithm is no better than yours. You’ve collected data (either 1000 or
1m data points) to measure the strength of this hypothesis. You want
to ensure that the difference in performance of these two algorithms
is statistically significant: i.e., is probably not just due to random
luck. (A more common question statisticians ask is whether one drug
treatment is better than another, where “another” is either a placebo
or the competitor’s drug.)

There are about ∞-many ways of doing hypothesis testing. Like

evaluation metrics and the number of folds of cross validation, this is
something that is very discipline speciﬁc. Here, we will discuss two
popular tests: the paired t-test and bootstrapping. These tests, and
other statistical tests, have underlying assumptions (for instance, as-
sumptions about the distribution of observations) and strengths (for
instance, small or large samples). In most cases, the goal of hypoth-
esis testing is to compute a p-value: namely, the probability that the
observed difference in performance was by chance. The standard way
of reporting results is to say something like “there is a 95% chance
that this difference was not by chance.” The value 95% is arbitrary,
and occasionally people use weaker (90%) test or stronger (99.5%)
tests.

The t-test is an example of a parametric test. It is applicable when
the null hypothesis states that the difference between two responses
has mean zero and unknown variance. The t-test actually assumes
that data is distributed according to a Gaussian distribution, which is
probably not true of binary responses. Fortunately, for large samples
(at least a few hundred), binary samples are well approximated by
a Gaussian distribution. So long as your sample is sufﬁciently large,
the t-test is reasonable either for regression or classiﬁcation problems.

Suppose that you evaluate two algorithm on N-many examples.

practical issues

67

t

≥ 1.28
≥ 1.64
≥ 1.96
≥ 2.58

Table 5.3: Table of signiﬁcance values
for the t-test.

signiﬁcance

90.0%
95.0%
97.5%
99.5%

68 a course in machine learning

On each example, you can compute whether the algorithm made
the correct prediction. Let a1, . . . , aN denote the error of the ﬁrst
algorithm on each example. Let b1, . . . , bN denote the error of the
second algorithm. You can compute µa and µb as the means of a and
b, respecitively. Finally, center the data as ˆa = a − µa and ˆb = b − µb.
The t-statistic is deﬁned as:

(cid:115)

t = (µa − µb)

N(N − 1)
∑n(ˆan − ˆbn)2

(5.15)

After computing the t-value, you can compare it to a list of values
for computing conﬁdence intervals. Assuming you have a lot of data
(N is a few hundred or more), then you can compare your t-value to
Table 5.3 to determine the signiﬁcance level of the difference.

One disadvantage to the t-test is that it cannot easily be applied
to evaluation metrics like f-score. This is because f-score is a com-
puted over an entire test set and does not decompose into a set of
individual errors. This means that the t-test cannot be applied.

Fortunately, cross validation gives you a way around this problem.

?

What does it mean for the means
µa and µb to become further apart?
How does this affect the t-value?
What happens if the variance of a
increases?

When you do K-fold cross validation, you are able to compute K
error metrics over the same data. For example, you might run 5-fold
cross validation and compute f-score for every fold. Perhaps the f-
scores are 92.4, 93.9, 96.1, 92.2 and 94.4. This gives you an average
f-score of 93.8 over the 5 folds. The standard deviation of this set of
f-scores is:

σ =

(cid:115)
(cid:114) 1

=

4
= 1.595

1

N − 1

(ai − µ)2

∑
n

(1.96 + 0.01 + 5.29 + 2.56 + 0.36)

(5.16)

(5.17)
(5.18)

You can now assume that the distribution of scores is approximately
Gaussian. If this is true, then approximately 70% of the proba-
bility mass lies in the range [µ − σ, µ + σ]; 95% lies in the range
[µ − 2σ, µ + 2σ]; and 99.5% lies in the range [µ − 3σ, µ + 3σ]. So, if we
were comparing our algorithm against one whose average f-score was
90.6%, we could be 95% certain that our superior performance was
not due to chance.5

WARNING: A conﬁdence of 95% does not mean “There is a 95%
chance that I am better.” All it means is that if I reran the same ex-
periment 100 times, then in 95 of those experiments I would still win.
These are very different statements. If you say the ﬁrst one, people
who know about statistics will get very mad at you!

One disadvantage to cross validation is that it is computationally
expensive. More folds typically leads to better estimates, but every

5 Had we run 10-fold cross validation
we might be been able to get tighter
conﬁdence intervals.

practical issues

69

Algorithm 10 BootstrapEvaluate(y, ˆy, NumFolds)
1: scores ← [ ]
2: for k = 1 to NumFolds do
truth ← [ ]
3:
pred ← [ ]
for n = 1 to N do

4:

m ← uniform random value from 1 to N
truth ← truth ⊕ ym
pred ← pred ⊕ ˆym

5:

6:

7:

8:

9:

// list of values we want to predict
// list of values we actually predicted

// sample a test point
// add on the truth
// add on our prediction

// evaluate

end for
scores ← scores ⊕ f-score(truth, pred)

10:
11: end for
12: return (mean(scores), stddev(scores))

new fold requires training a new classiﬁer. This can get very time
consuming. The technique of bootstrapping (and closely related idea
of jack-knifing can address this problem.

Suppose that you didn’t want to run cross validation. All you have

is a single held-out test set with 1000 data points in it. You can run
your classiﬁer and get predictions on these 1000 data points. You
would like to be able to compute a metric like f-score on this test set,
but also get conﬁdence intervals. The idea behind bootstrapping is
that this set of 1000 is a random draw from some distribution. We
would like to get multiple random draws from this distribution on
which to evaluate. We can simulate multiple draws by repeatedly
subsampling from these 1000 examples, with replacement.

To perform a single bootstrap, you will sample 1000 random points

from your test set of 1000 random points. This sampling must be
done with replacement (so that the same example can be sampled
more than once), otherwise you’ll just end up with your original test
set. This gives you a bootstrapped sample. On this sample, you can
compute f-score (or whatever metric you want). You then do this 99
more times, to get a 100-fold bootstrap. For each bootstrapped sam-
ple, you will be a different f-score. The mean and standard deviation
of this set of f-scores can be used to estimate a conﬁdence interval for
your algorithm.

The bootstrap resampling procedure is sketched in Algorithm 5.7.
This takes three arguments: the true labels y, the predicted labels ˆy
and the number of folds to run. It returns the mean and standard
deviation from which you can compute a conﬁdence interval.

5.8 Debugging Learning Algorithms

Learning algorithms are notoriously hard to debug, as you may have
already experienced if you have implemented any of the models

70 a course in machine learning

presented so far. The main issue is that when a learning algorithm
doesn’t learn, it’s unclear if this is because there’s a bug or because
the learning problem is too hard (or there’s too much noise, or . . . ).
Moreover, sometimes bugs lead to learning algorithms performing
better than they should: these are especially hard to catch (and always
a bit disappointing when you do catch them).

In order to debug failing learning models, it is useful to revisit the

notion of: where can error enter our system? In Chapter 2, we con-
sidered a typical design process for machine learning in Figure 2.4.
Leaving off the top steps in that are not relevant to machine learning
in particular, the basic steps that go into crafting a machine learning
system are: collect data, choose features, choose model family, choose
training data, train model, evaluate on test data. In each of these
steps, things can go wrong. Below are some strategies for isolating
the cause of error.

Is the problem with generalization to the test data? We have
talked a lot about training error versus test error. In general, it’s
unrealistic to expect to do better on the test data than on the training
data. Can your learning system do well on ﬁtting the training data?
If so, then the problem is in generalization (perhaps your model
family is too complicated, you have too many features or not enough
data). If not, then the problem is in representation (you probably
need better features or better data).

Do you have train/test mismatch? If you can ﬁt the training data,

but it doesn’t generalize, it could be because there’s something dif-
ferent about your test data. Try shufﬂing your training data and test
data together and then randomly selecting a new test set. If you do
well in that condition, then probably the test distribution is strange
in some way. If reselecting the test data doesn’t help, you have other
generalization problems.

Is your learning algorithm implemented correctly? This often

means: is it optimizing what you think it’s optimizing. Instead
of measuring accuracy, try measuring whatever-quantity-your-
algorithm-is-supposedly-optimizing (like log loss or hinge loss) and
make sure that the optimizer is successfully minimizing this quantity.
It is usually useful to hand-craft some datasets on which you know
the desired behavior. For instance, you could run KNN on the XOR
data. Or you could run perceptron on some easily linearly separa-
ble data (for instance positive points along the line x2 = x1 + 1 and
negative points along the line x2 = x1 − 1). Or a decision tree on
nice axis-aligned data. Finally, can you compare against a reference
implementation?

Do you have an adequate representation? If you cannot even

ﬁt the training data, you might not have a rich enough feature set.

practical issues

71

The easiest way to try to get a learning algorithm to overﬁt is to add
a new feature to it. You can call this feature the CheatingIsFun
feature. The feature value associated with this feature is +1 if this
is a positive example and −1 (or zero) if this is a negative example.
In other words, this feature is a perfect indicator of the class of this
example. If you add the CheatingIsFun feature and your algorithm
does not get near 0% training error, this could be because there are
too many noisy features confusing it. You could either remove a lot
of the other features, or make the feature value for CheatingIsFun
either +100 or −100 so that the algorithm really looks at it. If you
do this and your algorithm still cannot overﬁt then you likely have a
bug. (Remember to remove the CheatingIsFun feature from your
ﬁnal implementation!) If the CheatingIsFun technique gets you
near 0% error, then you need to work on better feature design or pick
another learning model (e.g., decision tree versus linear model). If
not, you probably don’t have enough data or have too many features;
try removing as many features as possible.

Do you have enough data? Try training on 80% of your training
data and look at how much this hurts performance. If it hurts a lot,
then getting more data is likely to help; if it only hurts a little, you
might be data saturated.

5.9 Bias/Variance Trade-off

Because one of the key questions in machine learning is the question
of representation, it is common to think about test error in terms of a
decomposition into two terms. Let f be the learned classiﬁer, selected
from a set F of “all possible classiﬁers using a ﬁxed representation,”
then:

error( f ) =

(cid:123)(cid:122)
f ∗∈F error( f ∗)
error( f ) − min

estimation error

+

f ∗∈F error( f )
min

(5.19)

approximation error

(cid:20)
(cid:124)

(cid:21)
(cid:125)

(cid:20)
(cid:124)

(cid:123)(cid:122)

(cid:21)
(cid:125)

Here, the second term, the approximation error, measures the qual-
ity of the model family6. One way of thinking of approximation error
is: suppose someone gave me inﬁnite data to train on—how well
could I do with this representation? The ﬁrst term, the estimation
error, measures how far the actual learned classiﬁer f is from the
optimal classiﬁer f ∗. You can think of this term as measuring how
much you have to pay for the fact that you don’t have inﬁnite training
data.

Unfortunately, it is nearly impossible to compute the estima-

tion error and approxiation error, except in constructed cases. This
doesn’t make the decomposition useless. Decompositions like this

6 The “model family” (such as depth
20 decision trees, or linear classiﬁers)
is often refered to as the hypothesis
class. The hypothesis class F denotes
the set of all possible classiﬁers we
consider, such as all linear classiﬁers.
An classiﬁer f ∈ F is sometimes called
a hypothesis, though we generally
avoid this latter terminology here.

72 a course in machine learning

are very useful for designing debugging strategies. For instance, the
CheatingIsFun strategy is designed explicitly to ensure that the ap-
proximation error is zero, and therefore isolating all error into the
estimation error.

There is a fundamental trade-off between estimation error and ap-
proximation error. As you make your representation more complex,
you make F bigger. This will typically cause a decrease in approxi-
mation error, because you can now ﬁt more functions. But you run a
risk of increasing the estimation error, because you have added more
parameters to ﬁt, and you are likely to suffer from overﬁtting.

The trade-off between estimation error and approximation error

is often called the bias/variance trade-off, where “approximation
error” is “bias” and “estimation error” is “variance.” To understand
this connection, consider a very simple hypothesis class F that only
contains two functions: the always positive classiﬁer (that returns +1
regardless of input) and the always negative classiﬁer. Suppose you
have a data generating distribution D that is 60% positive examples
and 40% negative examples. You draw a training set of 41 exam-
ples. There’s about a 90% chance that the majority of these training
examples will be positive, so on this impoverished hypothesis class
F, there’s a 90% chance that it will learn the “all positive” classiﬁer.
That is: 90% of the time, regardless of the training set, the learning
algorithm learns the same thing. This is low variance as a function of
the random draw of the training set. On the other hand, the learned
classiﬁer is very insensitive to the input example (in this extreme
case, it’s completely insensitive): it is strongly biased toward predicting
+1 even if everything about the input contradicts this.

5.10 Further Reading

TODO

Figure 5.15: object recognition with full
information

6 | BEYOND BINARY CLASSIFICATION

Learning Objectives:
• Represent complex prediction prob-

lems in a formal learning setting.

• Be able to artiﬁcally “balance”

imbalanced data.

• Understand the positive and neg-
ative aspects of several reductions
from multiclass classiﬁcation to
binary classiﬁcation.

• Recognize the difference between
regression and ordinal regression.

Dependencies:

Different general classiﬁcation methods can give different, but
equally plausible, classiﬁcations, so you need an application
context to choose among them.

– Karen Spärck-Jones

In the preceeding chapters, you have learned all about a very
simple form of prediction: predicting bits. In the real world, how-
ever, we often need to predict much more complex objects. You may
need to categorize a document into one of several categories: sports,
entertainment, news, politics, etc. You may need to rank web pages
or ads based on relevance to a query. These problems are all com-
monly encountered, yet fundamentally more complex than binary
classiﬁcation.

In this chapter, you will learn how to use everything you already

know about binary classiﬁcation to solve these more complicated
problems. You will see that it’s relatively easy to think of a binary
classiﬁer as a black box, which you can reuse for solving these more
complex problems. This is a very useful abstraction, since it allows us
to reuse knowledge, rather than having to build new learning models
and algorithms from scratch.

6.1 Learning with Imbalanced Data

Your boss tells you to build a classiﬁer that can identify fraudulent
transactions in credit card histories. Fortunately, most transactions
are legitimate, so perhaps only 0.1% of the data is a positive in-
stance. The imbalanced data problem refers to the fact that for a
large number of real world problems, the number of positive exam-
ples is dwarfed by the number of negative examples (or vice versa).
This is actually something of a misnomer: it is not the data that is
imbalanced, but the distribution from which the data is drawn. (And
since the distribution is imbalanced, so must the data be.)

Imbalanced data is a problem because machine learning algo-
rithms are too smart for your own good. For most learning algo-
rithms, if you give them data that is 99.9% negative and 0.1% posi-
tive, they will simply learn to always predict negative. Why? Because
they are trying to minimize error, and they can achieve 0.1% error by
doing nothing! If a teacher told you to study for an exam with 1000

74 a course in machine learning

true/false questions and only one of them is true, it is unlikely you
will study very long.

Really, the problem is not with the data, but rather with the way

that you have deﬁned the learning problem. That is to say, what you
care about is not accuracy: you care about something else. If you
want a learning algorithm to do a reasonable job, you have to tell it
what you want!

Most likely, what you want is not to optimize accuracy, but rather
to optimize some other measure, like f-score or AUC. You want your
algorithm to make some positive predictions, and simply prefer those
to be “good.” We will shortly discuss two heuristics for dealing with
this problem: subsampling and weighting. In subsampling, you throw
out some of your negative examples so that you are left with a bal-
anced data set (50% positive, 50% negative). This might scare you
a bit since throwing out data seems like a bad idea, but at least it
makes learning much more efﬁcient. In weighting, instead of throw-
ing out positive examples, we just give them lower weight. If you
assign an importance weight of 0.00101 to each of the positive ex-
amples, then there will be as much weight associated with positive
examples as negative examples.

Before formally deﬁning these heuristics, we need to have a mech-

anism for formally deﬁning supervised learning problems. We will
proceed by example, using binary classiﬁcation as the canonical
learning problem.

TASK: BINARY CLASSIFICATION
Given:
1. An input space X
2. An unknown distribution D over X×{−1, +1}
3. A training set D sampled from D
Compute: A function f minimizing: E

(x,y)∼D(cid:2) f (x) (cid:54)= y(cid:3)

As in all the binary classiﬁcation examples you’ve seen, you have
some input space (which has always been RD). There is some distri-
bution that produces labeled examples over the input space. You do
not have access to that distribution, but can obtain samples from it.
Your goal is to ﬁnd a classiﬁer that minimizes error on that distribu-
tion.

A small modiﬁcation on this deﬁnition gives a α-weighted classiﬁ-
cation problem, where you believe that the positive class is α-times as

beyond binary classification 75

Algorithm 11 SubsampleMap(Dweighted, α)
1: while true do
2:

(x, y) ∼ Dweighted
u ∼ uniform random variable in [0, 1]
if y = +1 or u < 1
return (x, y)

α then

3:

4:

5:

// draw an example from the weighted distribution

end if

6:
7: end while

Algorithm 12 SubsampleTest( f binary, ˆx)
1: return f binary(ˆx)

important as the negative class.

TASK: α-WEIGHTED BINARY CLASSIFICATION
Given:
1. An input space X
2. An unknown distribution D over X×{−1, +1}
3. A training set D sampled from D

Compute: A function f minimizing: E

(x,y)∼D

(cid:104)

αy=1(cid:2) f (x) (cid:54)= y(cid:3)(cid:105)

The objects given to you in weighted binary classiﬁcation are iden-

tical to standard binary classiﬁcation. The only difference is that the
cost of misprediction for y = +1 is α, while the cost of misprediction
for y = −1 is 1. In what follows, we assume that α > 1. If it is not,
you can simply swap the labels and use 1/α.

The question we will ask is: suppose that I have a good algorithm

for solving the BINARY CLASSIFICATION problem. Can I turn that into
a good algorithm for solving the α-WEIGHTED BINARY CLASSIFICATION
problem?

In order to do this, you need to deﬁne a transformation that maps
a concrete weighted problem into a concrete unweighted problem.
This transformation needs to happen both at training time and at test
time (though it need not be the same transformation!). Algorithm 6.1
sketches a training-time sub-sampling transformation and Algo-
rithm 6.1 sketches a test-time transformation (which, in this case, is
trivial). All the training algorithm is doing is retaining all positive ex-
amples and a 1/α fraction of all negative examples. The algorithm is
explicitly turning the distribution over weighted examples into a (dif-
ferent) distribution over binary examples. A vanilla binary classiﬁer

76 a course in machine learning

is trained on this induced distribution.

Aside from the fact that this algorithm throws out a lot of data

(especially for large α), it does seem to be doing a reasonable thing.
In fact, from a reductions perspective, it is an optimal algorithm. You
can prove the following result:

Theorem 3 (Subsampling Optimality). Suppose the binary classiﬁer
trained in Algorithm 6.1 achieves a binary error rate of . Then the error
rate of the weighted predictor is equal to α.

This theorem states that if your binary classiﬁer does well (on the

induced distribution), then the learned predictor will also do well
(on the original distribution). Thus, we have successfully converted
a weighted learning problem into a plain classiﬁcation problem! The
fact that the error rate of the weighted predictor is exactly α times
more than that of the unweighted predictor is unavoidable: the error
metric on which it is evaluated is α times bigger!

The proof of this theorem is so straightforward that we will prove

it here. It simply involves some algebra on expected values.
Proof of Theorem 3. Let Dw be the original distribution and let Db be
the induced distribution. Let f be the binary classiﬁer trained on data
from Db that achieves a binary error rate of b on that distribution.
We will compute the expected error w of f on the weighted problem:

(x,y)∼Dw
∑
y∈±1

w = E
= ∑
x∈X
= α ∑
x∈X

= α ∑
x∈X
(x,y)∼Db

= αE
= αb

(cid:104)
αy=1(cid:2) f (x) (cid:54)= y(cid:3)(cid:105)
Dw(x, y)αy=1(cid:2) f (x) (cid:54)= y(cid:3)
(cid:16)Dw(x, +1)(cid:2) f (x) (cid:54)= +1(cid:3) + Dw(x,−1)
(cid:2) f (x) (cid:54)= −1(cid:3)(cid:17)
(cid:16)Db(x, +1)(cid:2) f (x) (cid:54)= +1(cid:3) + Db(x,−1)(cid:2) f (x) (cid:54)= −1(cid:3)(cid:17)
(cid:2) f (x) (cid:54)= y(cid:3)

1
α

(6.1)
(6.2)

(6.3)
(6.4)

(6.5)
(6.6)

?

Why is it unreasonable to expect
√
to be able to achieve, for instance,
an error of
sublinear in α?

α, or anything that is

And we’re done! (We implicitly assumed X is discrete. In the case
of continuous data, you need to replace all the sums over x with
integrals over x, but the result still holds.)

Instead of subsampling the low-cost class, you could alternatively

oversample the high-cost class. The easiest case is when α is an in-
teger, say 5. Now, whenever you get a positive point, you include 5
copies of it in the induced distribution. Whenever you get a negative
point, you include a single copy.

?

How can you handle non-integral α,
for instance 5.5?

beyond binary classification 77

This oversampling algorithm achieves exactly the same theoretical
result as the subsampling algorithm. The main advantage to the over-
sampling algorithm is that it does not throw out any data. The main
advantage to the subsampling algorithm is that it is more computa-
tionally efﬁcient.

You might be asking yourself: intuitively, the oversampling algo-

rithm seems like a much better idea than the subsampling algorithm,
at least if you don’t care about computational efﬁciency. But the the-
ory tells us that they are the same! What is going on? Of course the
theory isn’t wrong. It’s just that the assumptions are effectively dif-
ferent in the two cases. Both theorems state that if you can get error
of  on the binary problem, you automatically get error of α on the
weighted problem. But they do not say anything about how possible
it is to get error  on the binary problem. Since the oversampling al-
gorithm produces more data points than the subsampling algorithm
it is very concievable that you could get lower binary error with over-
sampling than subsampling.

The primary drawback to oversampling is computational inefﬁ-

ciency. However, for many learning algorithms, it is straightforward
to include weighted copies of data points at no cost. The idea is to
store only the unique data points and maintain a counter saying how
many times they are replicated. This is not easy to do for the percep-
tron (it can be done, but takes work), but it is easy for both decision
trees and KNN. For example, for decision trees (recall Algorithm 1.3),
the only changes are to: (1) ensure that line 1 computes the most fre-
quent weighted answer, and (2) change lines 10 and 11 to compute
weighted errors.

6.2 Multiclass Classiﬁcation

Multiclass classiﬁcation is a natural extension of binary classiﬁcation.
The goal is still to assign a discrete label to examples (for instance,
is a document about entertainment, sports, ﬁnance or world news?).
The difference is that you have K > 2 classes to choose from.

?

Modify the proof of optimality
for the subsampling algorithm so
that it applies to the oversampling
algorithm.

?

Why is it hard to change the per-
ceptron? (Hint: it has to do with the
fact that perceptron is online.)

?

How would you modify KNN to
take into account weights?

78 a course in machine learning

Algorithm 13 OneVersusAllTrain(Dmulticlass, BinaryTrain)
1: for i = 1 to K do
2: Dbin ← relabel Dmulticlass so class i is positive and ¬i is negative

fi ← BinaryTrain(Dbin)

3:
4: end for
5: return f1, . . . , fK

Algorithm 14 OneVersusAllTest( f1, . . . , fK, ˆx)
1: score ← (cid:104)0, 0, . . . , 0(cid:105)
2: for i = 1 to K do
3:

y ← fi(ˆx)
scorei ← scorei + y

4:
5: end for
6: return argmaxk scorek

// initialize K-many scores to zero

TASK: MULTICLASS CLASSIFICATION
Given:
1. An input space X and number of classes K
2. An unknown distribution D over X×[K]
3. A training set D sampled from D
Compute: A function f minimizing: E

(x,y)∼D(cid:2) f (x) (cid:54)= y(cid:3)

Note that this is identical to binary classiﬁcation, except for the

presence of K classes. (In the above, [K] = {1, 2, 3, . . . , K}.) In fact, if
you set K = 2 you exactly recover binary classiﬁcation.

The game we play is the same: someone gives you a binary classi-
ﬁer and you have to use it to solve the multiclass classiﬁcation prob-
lem. A very common approach is the one versus all technique (also
called OVA or one versus rest). To perform OVA, you train K-many
binary classiﬁers, f1, . . . , fK. Each classiﬁer sees all of the training
data. Classiﬁer fi receives all examples labeled class i as positives
and all other examples as negatives. At test time, whichever classiﬁer
predicts “positive” wins, with ties broken randomly.

The training and test algorithms for OVA are sketched in Algo-

rithms 6.2 and 6.2. In the testing procedure, the prediction of the ith
classiﬁer is added to the overall score for class i. Thus, if the predic-
tion is positive, class i gets a vote; if the prdiction is negative, every-
one else (implicitly) gets a vote. (In fact, if your learning algorithm
can output a conﬁdence, as discussed in Section ??, you can often do
better by using the conﬁdence as y, rather than a simple ±1.)

OVA is quite natural and easy to implement. It also works very

?

Suppose that you have N data
points in K classes, evenly divided.
How long does it take to train an
OVA classiﬁer, if the base binary
classiﬁer takes O(N) time to train?
What if the base classiﬁer takes
O(N2) time?

?

Why would using a conﬁdence
help?

beyond binary classification 79

well in practice, so long as you do a good job choosing a good binary
classiﬁcation algorithm tuning its hyperparameters well. Its weakness
is that it can be somewhat brittle. Intuitively, it is not particularly
robust to errors in the underlying classiﬁers. If one classiﬁer makes a
mistake, it is possible that the entire prediction is erroneous. In fact,
it is entirely possible that none of the K classiﬁers predicts positive
(which is actually the worst-case scenario from a theoretical perspec-
tive)! This is made explicit in the OVA error bound below.

Theorem 4 (OVA Error Bound). Suppose the average binary error of the
K binary classiﬁers is . Then the error rate of the OVA multiclass predictor
is at most (K − 1).
Proof of Theorem 4. The key question is how erroneous predictions
from the binary classiﬁers lead to multiclass errors. We break it down
into false negatives (predicting -1 when the truth is +1) and false
positives (predicting +1 when the truth is -1).

When a false negative occurs, then the testing procedure chooses
randomly between available options, which is all labels. This gives a
(K − 1)/K probability of multiclass error. Since only one binary error
is necessary to make this happen, the efﬁciency of this error mode is
[(K − 1)/K]/1 = (K − 1)/K.

Multiple false positives can occur simultaneously. Suppose there
are m false positives. If there is simultaneously a false negative, the
error is 1. In order for this to happen, there have to be m + 1 errors,
so the efﬁciency is 1/(M + 1). In the case that there is not a simulta-
neous false negative, the error probability is m/(m + 1). This requires
m errors, leading to an efﬁciency of 1/(m + 1).
The worse case, therefore, is the false negative case, which gives an
efﬁciency of (K − 1)/K. Since we have K-many opportunities to err,
we multiply this by K and get a bound of (K − 1).

The constants in this are relatively unimportant: the aspect that

matters is that this scales linearly in K. That is, as the number of
classes grows, so does your expected error.

To develop alternative approaches, a useful way to think about
turning multiclass classiﬁcation problems into binary classiﬁcation
problems is to think of them like tournaments (football, soccer–aka
football, cricket, tennis, or whatever appeals to you). You have K
teams entering a tournament, but unfortunately the sport they are
playing only allows two to compete at a time. You want to set up a
way of pairing the teams and having them compete so that you can
ﬁgure out which team is best. In learning, the teams are now the
classes and you’re trying to ﬁgure out which class is best.1

One natural approach is to have every team compete against ev-

ery other team. The team that wins the majority of its matches is

1 The sporting analogy breaks down
a bit for OVA: K games are played,
wherein each team will play simultane-
ously against all other teams.

80 a course in machine learning

Algorithm 15 AllVersusAllTrain(Dmulticlass, BinaryTrain)

fij ← ∅,∀1 ≤ i < j ≤ K

1:
2: for i = 1 to K-1 do
3: Dpos ← all x ∈ Dmulticlass labeled i

for j = i+1 to K do

Dneg ← all x ∈ Dmulticlass labeled j
Dbin ← {(x, +1) : x ∈ Dpos} ∪ {(x,−1) : x ∈ Dneg}
fij ← BinaryTrain(Dbin)

Algorithm 16 AllVersusAllTest(all fij, ˆx)
1: score ← (cid:104)0, 0, . . . , 0(cid:105)
2: for i = 1 to K-1 do
3:

// initialize K-many scores to zero

4:

5:

6:

7:

4:

5:

6:

end for

8:
9: end for
10: return all fijs

for j = i+1 to K do
y ← fij(ˆx)
scorei ← scorei + y
scorej ← scorej - y

end for

7:
8: end for
9: return argmaxk scorek

declared the winner. This is the all versus all (or AVA) approach
(sometimes called all pairs). The most natural way to think about it
2) classiﬁers. Say fij for 1 ≤ i < j ≤ k is the classiﬁer
is as training (K
that pits class i against class j. This classiﬁer receives all of the class i
examples as “positive” and all of the class j examples as “negative.”
When a test point arrives, it is run through all fij classiﬁers. Every
time fij predicts positive, class i gets a point; otherwise, class j gets a
point. After running all (K
2) classiﬁers, the class with the most votes
wins.

The training and test algorithms for AVA are sketched in Algo-

rithms 6.2 and 6.2. In theory, the AVA mapping is more complicated
than the weighted binary case. The result is stated below, but the
proof is omitted.

Theorem 5 (AVA Error Bound). Suppose the average binary error of
the (K
2) binary classiﬁers is . Then the error rate of the AVA multiclass
predictor is at most 2(K − 1).

At this point, you might be wondering if it’s possible to do bet-
ter than something linear in K. Fortunately, the answer is yes! The
solution, like so much in computer science, is divide and conquer.
The idea is to construct a binary tree of classiﬁers. The leaves of this
tree correspond to the K labels. Since there are only log2 K decisions
made to get from the root to a leaf, then there are only log2 K chances

?

Suppose that you have N data
points in K classes, evenly divided.
How long does it take to train an
AVA classiﬁer, if the base binary
classiﬁer takes O(N) time to train?
What if the base classiﬁer takes
O(N2) time? How does this com-
pare to OVA?

The bound for AVA is 2(K − 1); the
bound for OVA is (K − 1). Does
this mean that OVA is necessarily
better than AVA? Why or why not?

?

beyond binary classification 81

Figure 6.2: example classiﬁcation tree
for K = 8

to make an error.
An example of a classiﬁcation tree for K = 8 classes is shown in
Figure 6.2. At the root, you distinguish between classes {1, 2, 3, 4}
and classes {5, 6, 7, 8}. This means that you will train a binary clas-
siﬁer whose positive examples are all data points with multiclass
label {1, 2, 3, 4} and whose negative examples are all data points with
multiclass label {5, 6, 7, 8}. Based on what decision is made by this
classiﬁer, you can walk down the appropriate path in the tree. When
K is not a power of 2, the tree will not be full. This classiﬁcation tree
algorithm achieves the following bound.

Theorem 6 (Tree Error Bound). Suppose the average binary classiﬁers
error is . Then the error rate of the tree classiﬁer is at most (cid:100)log2 K(cid:101) .
Proof of Theorem 6. A multiclass error is made if any classiﬁer on
the path from the root to the correct leaf makes an error. Each has
probability  of making an error and the path consists of at most
(cid:100)log2 K(cid:101) binary decisions.

One thing to keep in mind with tree classiﬁers is that you have

control over how the tree is deﬁned. In OVA and AVA you have no
say in what classiﬁcation problems are created. In tree classiﬁers,
the only thing that matters is that, at the root, half of the classes are
considered positive and half are considered negative. You want to
split the classes in such a way that this classiﬁcation decision is as
easy as possible. You can use whatever you happen to know about
your classiﬁcation problem to try to separate the classes out in a
reasonable way.

Can you do better than (cid:100)log2 K(cid:101) ? It turns out the answer is yes,
but the algorithms to do so are relatively complicated. You can actu-
ally do as well as 2 using the idea of error-correcting tournaments.
Moreover, you can prove a lower bound that states that the best you
could possible do is /2. This means that error-correcting tourna-
ments are at most a factor of four worse than optimal.

6.3 Ranking

You start a new web search company called Goohooing. Like other
search engines, a user inputs a query and a set of documents is re-
trieved. Your goal is to rank the resulting documents based on rel-
evance to the query. The ranking problem is to take a collection of
items and sort them according to some notion of preference. One of
the trickiest parts of doing ranking through learning is to properly
deﬁne the loss function. Toward the end of this section you will see a
very general loss function, but before that let’s consider a few special
cases.

82 a course in machine learning

Algorithm 17 NaiveRankTrain(RankingData, BinaryTrain)
1: D ← [ ]
2: for n = 1 to N do
3:

for all i, j = 1 to M and i (cid:54)= j do

if i is prefered to j on query n then

4:

5:

6:

7:

8:

D ← D ⊕ (xnij, +1)
D ← D ⊕ (xnij,−1)

else if j is prefered to i on query n then

end if
end for

9:
10: end for
11: return BinaryTrain(D)

Continuing the web search example, you are given a collection of

queries. For each query, you are also given a collection of documents,
together with a desired ranking over those documents. In the follow-
ing, we’ll assume that you have N-many queries and for each query
you have M-many documents. (In practice, M will probably vary
by query, but for ease we’ll consider the simpliﬁed case.) The goal is
to train a binary classiﬁer to predict a preference function. Given a
query q and two documents di and dj, the classiﬁer should predict
whether di should be preferred to dj with respect to the query q.

As in all the previous examples, there are two things we have to
take care of: (1) how to train the classiﬁer that predicts preferences;
(2) how to turn the predicted preferences into a ranking. Unlike the
previous examples, the second step is somewhat complicated in the
ranking case. This is because we need to predict an entire ranking of
a large number of documents, somehow assimilating the preference
function into an overall permutation.

For notationally simplicity, let xnij denote the features associated
with comparing document i to document j on query n. Training is
fairly straightforward. For every n and every pair i (cid:54)= j, we will
create a binary classiﬁcation example based on features xnij. This
example is positive if i is preferred to j in the true ranking. It is neg-
ative if j is preferred to i. (In some cases the true ranking will not
express a preference between two objects, in which case we exclude
the i, j and j, i pair from training.)

Now, you might be tempted to evaluate the classiﬁcation perfor-

mance of this binary classiﬁer on its own. The problem with this
approach is that it’s impossible to tell—just by looking at its output
on one i, j pair—how good the overall ranking is. This is because
there is the intermediate step of turning these pairwise predictions
into a coherent ranking. What you need to do is measure how well
the ranking based on your predicted preferences compares to the true
ordering. Algorithms 6.3 and 6.3 show naive algorithms for training

Algorithm 18 NaiveRankTest( f , ˆx)
1: score ← (cid:104)0, 0, . . . , 0(cid:105)
2: for all i, j = 1 to M and i (cid:54)= j do

3:

4:

y ← f (ˆxij)
scorei ← scorei + y
scorej ← scorej - y

5:
6: end for
7: return argsort(score)

beyond binary classification 83

// initialize M-many scores to zero

// get predicted ranking of i and j

// return queries sorted by score

and testing a ranking function.

These algorithms actually work quite well in the case of bipartite
ranking problems. A bipartite ranking problem is one in which you
are only ever trying to predict a binary response, for instance “is this
document relevant or not?” but are being evaluated according to a
metric like AUC. This is essentially because the only goal in bipartite
problems is to ensure that all the relevant documents are ahead of
all the irrelevant documents. There is no notion that one relevant
document is more relevant than another.

For non-bipartite ranking problems, you can do better. First, when

the preferences that you get at training time are more nuanced than
“relevant or not,” you can incorporate these preferences at training
time. Effectively, you want to give a higher weight to binary prob-
lems that are very different in terms of preference than others. Sec-
ond, rather than producing a list of scores and then calling an arbi-
trary sorting algorithm, you can actually use the preference function
as the sorting function inside your own implementation of quicksort.
We can now formalize the problem. Deﬁne a ranking as a function

σ that maps the objects we are ranking (documents) to the desired
position in the list, 1, 2, . . . M. If σu < σv then u is preferred to v (i.e.,
appears earlier on the ranked document list). Given data with ob-
served rankings σ, our goal is to learn to predict rankings for new
objects, ˆσ. We deﬁne ΣM as the set of all ranking functions over M
objects. We also wish to express the fact that making a mistake on
some pairs is worse than making a mistake on others. This will be
encoded in a cost function ω (omega), where ω(i, j) is the cost for
accidentally putting something in position j when it should have
gone in position i. To be a valid cost function, ω must be (1) symmet-
ric, (2) monotonic and (3) satisfy the triangle inequality. Namely: (1)
ω(i, j) = ω(j, i); (2) if i < j < k or i > j > k then ω(i, j) ≤ ω(i, k);
(3) ω(i, j) + ω(j, k) ≥ ω(i, k). With these deﬁnitions, we can properly
deﬁne the ranking problem.

84 a course in machine learning

TASK: ω-RANKING
Given:
1. An input space X
2. An unknown distribution D over X×ΣM
3. A training set D sampled from D
(cid:35)
Compute: A function f : X → ΣM minimizing:

(cid:34)

E

(x,σ)∼D

[σu < σv] [ˆσv < ˆσu] ω(σu, σv)

∑
u(cid:54)=v

where ˆσ = f (x)

(6.7)

In this deﬁnition, the only complex aspect is the loss function 6.7.
This loss sums over all pairs of objects u and v. If the true ranking (σ)
prefers u to v, but the predicted ranking (ˆσ) prefers v to u, then you
incur a cost of ω(σu, σv).
Depending on the problem you care about, you can set ω to many
“standard” options. If ω(i, j) = 1 whenever i (cid:54)= j, then you achieve
the Kemeny distance measure, which simply counts the number of
pairwise misordered items. In many applications, you may only care
about getting the top K predictions correct. For instance, your web
search algorithm may only display K = 10 results to a user. In this
case, you can deﬁne:

ω(i, j) =

if min{i, j} ≤ K and i (cid:54)= j

1
0 otherwise

(6.8)

(cid:40)

In this case, only errors in the top K elements are penalized. Swap-
ping items 55 and 56 is irrelevant (for K < 55).

Finally, in the bipartite ranking case, you can express the area

under the curve (AUC) metric as:

 1

ω(i, j) =

(M
2 )

M+(M − M+)

×

if i ≤ M+ and j > M+
1 if j ≤ M+ and i > M+
0 otherwise

(6.9)

Here, M is the total number of objects to be ranked and M+ is the
number that are actually “good.” (Hence, M − M+ is the number
that are actually “bad,” since this is a bipartite problem.) You are
only penalized if you rank a good item in position greater than M+
or if you rank a bad item in a position less than or equal to M+.

In order to solve this problem, you can follow a recipe similar to

the naive approach sketched earlier. At training time, the biggest

beyond binary classification 85

Algorithm 19 RankTrain(Drank, ω, BinaryTrain)
1: Dbin ← [ ]
2: for all (x, σ) ∈ Drank do
for all u (cid:54)= v do
y ← sign(σv - σu)
w ← ω(σu, σv)
Dbin ← Dbin ⊕ (y, w, xuv)

3:

6:

4:

5:

end for

7:
8: end for
9: return BinaryTrain(Dbin)

// y is +1 if u is prefered to v
// w is the cost of misclassiﬁcation

Algorithm 20 RankTest( f , ˆx, obj)
1: if obj contains 0 or 1 elements then
2:
3: else
4:

return obj
p ← randomly chosen object in obj
left ← [ ]
right ← [ ]
for all u ∈ obj \{p} do

left ← left ⊕ u
right ← right ⊕ u

else

end if
end for
left ← RankTest( f , ˆx, left)
right ← RankTest( f , ˆx, right)
return left ⊕ (cid:104)p(cid:105) ⊕ right

17:
18: end if

5:

6:

7:

8:

9:

10:

11:

12:

13:

14:

15:

16:

// pick pivot
// elements that seem smaller than p
// elements that seem larger than p

ˆy ← f (xup)
if uniform random variable < ˆy then

// what is the probability that u precedes p

// sort earlier elements
// sort later elements

change is that you can weight each training example by how bad it
would be to mess it up. This change is depicted in Algorithm 6.3,
where the binary classiﬁcation data has weights w provided for saying
how important a given example is. These weights are derived from
the cost function ω.

At test time, instead of predicting scores and then sorting the list,
you essentially run the quicksort algorithm, using f as a comparison
function. At each step in Algorithm 6.3, a pivot p is chosen. Every
other object u is compared to p using f . If f thinks u is better, then it
is sorted on the left; otherwise it is sorted on the right. There is one
major difference between this algorithm and quicksort: the compar-
ison function is allowed to be probabilistic. If f outputs probabilities,
for instance it predicts that u has an 80% probability of being better
than p, then it puts it on the left with 80% probability and on the
right with 20% probability. (The pseudocode is written in such a way
that even if f just predicts −1, +1, the algorithm still works.)

86 a course in machine learning

This algorithm is better than the naive algorithm in at least two
ways. First, it only makes O(M log2 M) calls to f (in expectation),
rather than O(M2) calls in the naive case. Second, it achieves a better
error bound, shown below:

Theorem 7 (Rank Error Bound). Suppose the average binary error of f
is . Then the ranking algorithm achieves a test error of at most 2 in the
general case, and  in the bipartite case.

6.4 Further Reading

TODO further reading

7 | LINEAR MODELS

Learning Objectives:
• Deﬁne and plot four surrogate loss

functions: squared loss, logistic loss,
exponential loss and hinge loss.

• Compare and contrast the optimiza-

tion of 0/1 loss and surrogate loss
functions.

• Solve the optimization problem

for squared loss with a quadratic
regularizer in closed form.

• Implement and debug gradient

descent and subgradient descent.

Dependencies:

The essence of mathematics is not to make simple things compli-
cated, but to make complicated things simple.
– Stanley Gudder

In Chapter 4, you learned about the perceptron algorithm for
linear classiﬁcation. This was both a model (linear classiﬁer) and al-
gorithm (the perceptron update rule) in one. In this section, we will
separate these two, and consider general ways for optimizing lin-
ear models. This will lead us into some aspects of optimization (aka
mathematical programming), but not very far. At the end of this
chapter, there are pointers to more literature on optimization for
those who are interested.

The basic idea of the perceptron is to run a particular algorithm
until a linear separator is found. You might ask: are there better al-
gorithms for ﬁnding such a linear separator? We will follow this idea
and formulate a learning problem as an explicit optimization prob-
lem: ﬁnd me a linear separator that is not too complicated. We will
see that ﬁnding an “optimal” separator is actually computationally
prohibitive, and so will need to “relax” the optimality requirement.
This will lead us to a convex objective that combines a loss func-
tion (how well are we doing on the training data?) and a regularizer
(how complicated is our learned model?). This learning framework
is known as both Tikhonov regularization and structural risk mini-
mization.

7.1 The Optimization Framework for Linear Models

You have already seen the perceptron as a way of ﬁnding a weight
vector w and bias b that do a good job of separating positive train-
ing examples from negative training examples. The perceptron is a
model and algorithm in one. Here, we are interested in separating
these issues. We will focus on linear models, like the perceptron.
But we will think about other, more generic ways of ﬁnding good
parameters of these models.

The goal of the perceptron was to ﬁnd a separating hyperplane
for some training data set. For simplicity, you can ignore the issue
of overﬁtting (but just for now!). Not all data sets are linearly sepa-

You should remember the yw ·
trick from the perceptron discus-
sion. If not, re-convince yourself
that this is doing the right thing.

?

x

88 a course in machine learning

rable. In the case that your training data isn’t linearly separable, you
might want to ﬁnd the hyperplane that makes the fewest errors on
the training data. We can write this down as a formal mathematics
optimization problem as follows:

min
w,b

∑
n

1[yn(w · xn + b) > 0]

(7.1)

In this expression, you are optimizing over two variables, w and b.
The objective function is the thing you are trying to minimize. In
this case, the objective function is simply the error rate (or 0/1 loss) of
the linear classiﬁer parameterized by w, b. In this expression, 1[·] is
the indicator function: it is one when (·) is true and zero otherwise.

We know that the perceptron algorithm is guaranteed to ﬁnd

parameters for this model if the data is linearly separable. In other
words, if the optimum of Eq (7.1) is zero, then the perceptron will
efﬁciently ﬁnd parameters for this model. The notion of “efﬁciency”
depends on the margin of the data for the perceptron.

You might ask: what happens if the data is not linearly separable?

Is there an efﬁcient algorithm for ﬁnding an optimal setting of the
parameters? Unfortunately, the answer is no. There is no polynomial
time algorithm for solving Eq (7.1), unless P=NP. In other words,
this problem is NP-hard. Sadly, the proof of this is quite complicated
and beyond the scope of this book, but it relies on a reduction from a
variant of satisﬁability. The key idea is to turn a satisﬁability problem
into an optimization problem where a clause is satisﬁed exactly when
the hyperplane correctly separates the data.

You might then come back and say: okay, well I don’t really need

an exact solution. I’m willing to have a solution that makes one or
two more errors than it has to. Unfortunately, the situation is really
bad. Zero/one loss is NP-hard to even appproximately minimize. In
other words, there is no efﬁcient algorithm for even ﬁnding a solution
that’s a small constant worse than optimal. (The best known constant
at this time is 418/415 ≈ 1.007.)

However, before getting too disillusioned about this whole enter-
prise (remember: there’s an entire chapter about this framework, so
it must be going somewhere!), you should remember that optimizing
Eq (7.1) perhaps isn’t even what you want to do! In particular, all it
says is that you will get minimal training error. It says nothing about
what your test error will be like. In order to try to ﬁnd a solution that
will generalize well to test data, you need to ensure that you do not
overﬁt the data. To do this, you can introduce a regularizer over the
parameters of the model. For now, we will be vague about what this
regularizer looks like, and simply call it an arbitrary function R(w, b).

This leads to the following, regularized objective:

min
w,b

∑
n

1[yn(w · xn + b) > 0] + λR(w, b)

(7.2)

In Eq (7.2), we are now trying to optimize a trade-off between a so-
lution that gives low training error (the ﬁrst term) and a solution
that is “simple” (the second term). You can think of the maximum
depth hyperparameter of a decision tree as a form of regularization
for trees. Here, R is a form of regularization for hyperplanes. In this
formulation, λ becomes a hyperparameter for the optimization.

The key remaining questions, given this formalism, are:

• How can we adjust the optimization problem so that there are

efﬁcient algorithms for solving it?

• What are good regularizers R(w, b) for hyperplanes?

• Assuming we can adjust the optimization problem appropriately,
what algorithms exist for efﬁciently solving this regularized opti-
mization problem?

We will address these three questions in the next sections.

7.2 Convex Surrogate Loss Functions

You might ask: why is optimizing zero/one loss so hard? Intuitively,
one reason is that small changes to w, b can have a large impact on
the value of the objective function. For instance, if there is a positive
training example with w, x · +b = −0.0000001, then adjusting b up-
wards by 0.00000011 will decrease your error rate by 1. But adjusting
it upwards by 0.00000009 will have no effect. This makes it really
difﬁcult to ﬁgure out good ways to adjust the parameters.

To see this more clearly, it is useful to look at plots that relate

margin to loss. Such a plot for zero/one loss is shown in Figure 7.1.
In this plot, the horizontal axis measures the margin of a data point
and the vertical axis measures the loss associated with that margin.
For zero/one loss, the story is simple. If you get a positive margin
(i.e., y(w · x + b) > 0) then you get a loss of zero. Otherwise you get
a loss of one. By thinking about this plot, you can see how changes
to the parameters that change the margin just a little bit can have an
enormous effect on the overall loss.

You might decide that a reasonable way to address this problem is

to replace the non-smooth zero/one loss with a smooth approxima-
tion. With a bit of effort, you could probably concoct an “S”-shaped
function like that shown in Figure 7.2. The beneﬁt of using such an
S-function is that it is smooth, and potentially easier to optimize. The
difﬁculty is that it is not convex.

linear models

89

?

Assuming R does the “right thing,”
what value(s) of λ will lead to over-
ﬁtting? What value(s) will lead to
underﬁtting?

Figure 7.1: plot of zero/one versus
margin

Figure 7.2: plot of zero/one versus
margin and an S version of it

90 a course in machine learning

If you remember from calculus, a convex function is one that looks
like a happy face ((cid:94)). (On the other hand, a concave function is one
that looks like a sad face ((cid:95)); an easy mnemonic is that you can hide
under a concave function.) There are two equivalent deﬁnitions of
a convex function. The ﬁrst is that it’s second derivative is always
non-negative. The second, more geometric, deﬁtion is that any chord
of the function lies above it. This is shown in Figure 7.3. There you
can see a convex function and a non-convex function, both with two
chords drawn in. In the case of the convex function, the chords lie
above the function. In the case of the non-convex function, there are
parts of the chord that lie below the function.

Convex functions are nice because they are easy to minimize. Intu-
itively, if you drop a ball anywhere in a convex function, it will even-
tually get to the minimum. This is not true for non-convex functions.
For example, if you drop a ball on the very left end of the S-function
from Figure 7.2, it will not go anywhere.

This leads to the idea of convex surrogate loss functions. Since
zero/one loss is hard to optimize, you want to optimize something
else, instead. Since convex functions are easy to optimize, we want
to approximate zero/one loss with a convex function. This approxi-
mating function will be called a surrogate loss. The surrogate losses
we construct will always be upper bounds on the true loss function:
this guarantees that if you minimize the surrogate loss, you are also
pushing down the real loss.

There are four common surrogate loss functions, each with their

own properties: hinge loss, logistic loss, exponential loss and
squared loss. These are shown in Figure 7.4 and deﬁned below.
These are deﬁned in terms of the true label y (which is just {−1, +1})
and the predicted value ˆy = w · x + b.

Zero/one:
Hinge:

Logistic:

Exponential:
Squared:

(cid:96)(0/1)(y, ˆy) = 1[y ˆy ≤ 0]
(cid:96)(hin)(y, ˆy) = max{0, 1 − y ˆy}
(cid:96)(log)(y, ˆy) =
(cid:96)(exp)(y, ˆy) = exp[−y ˆy]
(cid:96)(sqr)(y, ˆy) = (y − ˆy)2

log 2

1

log (1 + exp[−y ˆy])

(7.3)
(7.4)
(7.5)

(7.6)
(7.7)

1
log 2 term out front is there sim-

In the deﬁnition of logistic loss, the
ply to ensure that (cid:96)(log)(y, 0) = 1. This ensures, like all the other
surrogate loss functions, that logistic loss upper bounds the zero/one
loss. (In practice, people typically omit this constant since it does not
affect the optimization.)

There are two big differences in these loss functions. The ﬁrst

difference is how “upset” they get by erroneous predictions. In the

Figure 7.3: plot of convex and non-
convex functions with two chords each

Figure 7.4: surrogate loss fns

linear models

91

case of hinge loss and logistic loss, the growth of the function as ˆy
goes negative is linear. For squared loss and exponential loss, it is
super-linear. This means that exponential loss would rather get a few
examples a little wrong than one example really wrong. The other
difference is how they deal with very conﬁdent correct predictions.
Once y ˆy > 1, hinge loss does not care any more, but logistic and
exponential still think you can do better. On the other hand, squared
loss thinks it’s just as bad to predict +3 on a positive example as it is
to predict −1 on a positive example.

7.3 Weight Regularization

In our learning objective, Eq (7.2), we had a term correspond to the
zero/one loss on the training data, plus a regularizer whose goal
was to ensure that the learned function didn’t get too “crazy.” (Or,
more formally, to ensure that the function did not overﬁt.) If you re-
place to zero/one loss with a surrogate loss, you obtain the following
objective:

min
w,b

∑
n

(cid:96)(yn, w · xn + b) + λR(w, b)

(7.8)

The question is: what should R(w, b) look like?

From the discussion of surrogate loss function, we would like

to ensure that R is convex. Otherwise, we will be back to the point
where optimization becomes difﬁcult. Beyond that, a common desire
is that the components of the weight vector (i.e., the wds) should be
small (close to zero). This is a form of inductive bias.

Why are small values of wd good? Or, more precisely, why do

small values of wd correspond to simple functions? Suppose that we
have an example x with label +1. We might believe that other ex-
amples, x(cid:48) that are nearby x should also have label +1. For example,
if I obtain x(cid:48) by taking x and changing the ﬁrst component by some
small value  and leaving the rest the same, you might think that the
classiﬁcation would be the same. If you do this, the difference be-
tween ˆy and ˆy(cid:48) will be exactly w1. So if w1 is reasonably small, this
is unlikely to have much of an effect on the classiﬁcation decision. On
the other hand, if w1 is large, this could have a large effect.
Another way of saying the same thing is to look at the derivative
of the predictions as a function of w1. The derivative of w · x + b with
respect to w1 is:
∂ [w · x + b]

∂ [∑d wdxd + b]

(7.9)

=

∂w1

∂w1

= x1

Interpreting the derivative as the rate of change, we can see that
the rate of change of the prediction function is proportional to the

92 a course in machine learning

(cid:113)

individual weights. So if you want the function to change slowly, you
want to ensure that the weights stay small.

One way to accomplish this is to simply use the norm of the

∑d w2

weight vector. Namely R(norm)(w, b) = ||w|| =
is convex and smooth, which makes it easy to minimize. In prac-
tice, it’s often easier to use the squared norm, namely R(sqr)(w, b) =
||w||2 = ∑d w2
remains convex. An alternative to using the sum of squared weights
is to use the sum of absolute weights: R(abs)(w, b) = ∑d |wd|. Both of
these norms are convex.

d because it removes the ugly square root term and

d. This function

In addition to small weights being good, you could argue that zero

weights are better. If a weight wd goes to zero, then this means that
feature d is not used at all in the classiﬁcation decision. If there are a
large number of irrelevant features, you might want as many weights
to go to zero as possible. This suggests an alternative regularizer:
R(cnt)(w, b) = ∑d 1[xd (cid:54)= 0].

This line of thinking leads to the general concept of p-norms.

(Technically these are called (cid:96)p (or “ell p”) norms, but this notation
clashes with the use of (cid:96) for “loss.”) This is a family of norms that all
have the same general ﬂavor. We write ||w||p to denote the p-norm of
w.

(cid:32)

(cid:33) 1

p

||w||p =

|wd|p

∑
d

(7.10)

You can check that the 2-norm exactly corresponds to the usual Eu-
clidean norm, and that the 1-norm corresponds to the “absolute”
regularizer described above.

When p-norms are used to regularize weight vectors, the interest-

ing aspect is how they trade-off multiple features. To see the behavior
of p-norms in two dimensions, we can plot their contour (or level-
set). Figure 7.5 shows the contours for the same p norms in two
dimensions. Each line denotes the two-dimensional vectors to which
this norm assignes a total value of 1. By changing the value of p, you
can interpolate between a square (the so-called “max norm”), down
to a circle (2-norm), diamond (1-norm) and pointy-star-shaped-thing
(p < 1 norm).

In general, smaller values of p “prefer” sparser vectors. You can

see this by noticing that the contours of small p-norms “stretch”
out along the axes. It is for this reason that small p-norms tend to
yield weight vectors with many zero entries (aka sparse weight vec-
tors). Unfortunately, for p < 1 the norm becomes non-convex. As
you might guess, this means that the 1-norm is a popular choice for
sparsity-seeking applications.

?

Why do we not regularize the bias
term b?

?

Why might you not want to use
R(cnt) as a regularizer?

?

You can actually identify the R(cnt)
regularizer with a p-norm as well.
Which value of p gives it to you?
(Hint: you may have to take a limit.)

Figure 7.5: loss:norms2d: level sets of
the same p-norms

?

The max norm corresponds to
limp→∞. Why is this called the max
norm?

linear models

93

MATH REVIEW | GRADIENTS
A gradient is a multidimensional generalization of a derivative. Suppose you have a function
: RD → R that takes a vector x = (cid:104)x1, x2, . . . , xD(cid:105) as input and produces a scalar value as output.
f
You can differentite this function according to any one of the inputs; for instance, you can compute ∂ f
∂x5
to get the derivative with respect to the ﬁfth input. The gradient of f is just the vector consisting of the
derivative f with respect to each of its input coordinates independently, and is denoted ∇ f , or, when
the input to f is ambiguous, ∇x f . This is deﬁned as:

∇x f =

,

∂ f
∂x2

,

. . .

,

∂ f
∂xD

(cid:29)

(cid:28) ∂ f
(cid:68)

∂x1

(7.11)

1 + 5x1x2 − 3x2x2

3. The gradient is:

For example, consider the function f (x1, x2, x3) = x3
∇x f =

1 + 5x2 , 5x1 − 3x2
3x2

3 , − 6x2x3

(cid:69)

(7.12)
Note that if f : RD → R, then ∇ f : RD → RD. If you evaluate ∇ f (x), this will give you the gradient at
x, a vector in RD. This vector can be interpreted as the direction of steepest ascent: namely, if you were
to travel an inﬁnitesimal amount in the direction of the gradient, you would go uphill (i.e., increase f )
the most.

7.4 Optimization with Gradient Descent

Figure 7.6:

Envision the following problem. You’re taking up a new hobby:
blindfolded mountain climbing. Someone blindfolds you and drops
you on the side of a mountain. Your goal is to get to the peak of the
mountain as quickly as possible. All you can do is feel the mountain
where you are standing, and take steps. How would you get to the
top of the mountain? Perhaps you would feel to ﬁnd out what direc-
tion feels the most “upward” and take a step in that direction. If you
do this repeatedly, you might hope to get the the top of the moun-
tain. (Actually, if your friend promises always to drop you on purely
concave mountains, you will eventually get to the peak!)

The idea of gradient-based methods of optimization is exactly the

same. Suppose you are trying to ﬁnd the maximum of a function
f (x). The optimizer maintains a current estimate of the parameter of
interest, x. At each step, it measures the gradient of the function it is
trying to optimize. This measurement occurs at the current location,
x. Call the gradient g. It then takes a step in the direction of the
gradient, where the size of the step is controlled by a parameter η
(eta). The complete step is x ← x + ηg. This is the basic idea of
gradient ascent.

The opposite of gradient ascent is gradient descent. All of our

94 a course in machine learning

Algorithm 21 GradientDescent(F, K, η1, . . . )
1: z(0) ← (cid:104)0, 0, . . . , 0(cid:105)
2: for k = 1 . . . K do
g(k) ← ∇zF|z(k-1)
3:
z(k) ← z(k-1) − η(k)g(k)

// initialize variable we are optimizing

// compute gradient at current location
// take a step down the gradient

4:
5: end for
6: return z(K)

learning problems will be framed as minimization problems (trying
to reach the bottom of a ditch, rather than the top of a hill). There-
fore, descent is the primary approach you will use. One of the major
conditions for gradient ascent being able to ﬁnd the true, global min-
imum, of its objective function is convexity. Without convexity, all is
lost.
The gradient descent algorithm is sketched in Algorithm 7.4.
The function takes as arguments the function F to be minimized,
the number of iterations K to run and a sequence of learning rates
η1, . . . , ηK. (This is to address the case that you might want to start
your mountain climbing taking large steps, but only take small steps
when you are close to the peak.)

The only real work you need to do to apply a gradient descent

method is be able to compute derivatives. For concreteness, suppose
that you choose exponential loss as a loss function and the 2-norm as
a regularizer. Then, the regularized objective function is:

exp(cid:2) − yn(w · xn + b)(cid:3) +

L(w, b) = ∑
n

||w||2

λ
2

(7.13)

The only “strange” thing in this objective is that we have replaced
λ with λ
2 . The reason for this change is just to make the gradients
cleaner. We can ﬁrst compute derivatives with respect to b:

∂L
∂b

exp(cid:2) − yn(w · xn + b)(cid:3) +
exp(cid:2) − yn(w · xn + b)(cid:3) + 0
(cid:19)
(cid:18) ∂
yn exp(cid:2) − yn(w · xn + b)(cid:3)

− yn(w · xn + b)

∂b

=

∑
n
∂
∂b

∂
∂b
= ∑
n
= ∑
n
= − ∑
n

∂
∂b

||w||2

λ
2

exp(cid:2) − yn(w · xn + b)(cid:3)

(7.14)

(7.15)

(7.16)

(7.17)

Before proceeding, it is worth thinking about what this says. From a
practical perspective, the optimization will operate by updating b ←
b − η ∂L
∂b . Consider positive examples: examples with yn = +1. We
would hope for these examples that the current prediction, w · xn + b,
is as large as possible. As this value tends toward ∞, the term in the
exp[] goes to zero. Thus, such points will not contribute to the step.

linear models

95

?

This considered the case of posi-
tive examples. What happens with
negative examples?

However, if the current prediction is small, then the exp[] term will
be positive and non-zero. This means that the bias term b will be
increased, which is exactly what you would want. Moreover, once all
points are very well classiﬁed, the derivative goes to zero.

Now that we have done the easy case, let’s do the gradient with

n

exp(cid:2) − yn(w · xn + b)(cid:3) + ∇w
(∇w − yn(w · xn + b)) exp(cid:2) − yn(w · xn + b)(cid:3) + λw
ynxn exp(cid:2) − yn(w · xn + b)(cid:3) + λw

||w||2

λ
2

(7.18)

(7.19)
(7.20)

respect to w.

∇wL = ∇w ∑

= ∑
n

= − ∑
n

Now you can repeat the previous exercise. The update is of the form
w ← w − η∇wL. For well classiﬁed points (ones that tend toward
yn∞), the gradient is near zero. For poorly classiﬁed points, the gra-
dient points in the direction −ynxn, so the update is of the form
w ← w + cynxn, where c is some constant. This is just like the per-
ceptron update! Note that c is large for very poorly classiﬁed points
and small for relatively well classiﬁed points.
By looking at the part of the gradient related to the regularizer,
the update says: w ← w − λw = (1 − λ)w. This has the effect of
shrinking the weights toward zero. This is exactly what we expect the
regulaizer to be doing!

The success of gradient descent hinges on appropriate choices
for the step size. Figure 7.7 shows what can happen with gradient
descent with poorly chosen step sizes. If the step size is too big, you
can accidentally step over the optimum and end up oscillating. If the
step size is too small, it will take way too long to get to the optimum.
For a well-chosen step size, you can show that gradient descent will
approach the optimal value at a fast rate. The notion of convergence
here is that the objective value converges to the true minimum.

Figure 7.7: good and bad step sizes

Theorem 8 (Gradient Descent Convergence). Under suitable condi-
tions1, for an appropriately chosen constant step size (i.e., η1 = η2,· · · =
η), the convergence rate of gradient descent is O(1/k). More speciﬁ-
cally, letting z∗ be the global minimum of F, we have: F (z(k)) − F (z∗) ≤
2||z(0)−z∗||2

ηk

.

1 Speciﬁcally the function to be opti-
mized needs to be strongly convex.
This is true for all our problems, pro-
vided λ > 0. For λ = 0 the rate could
be as bad as O(1/

√

k).

The proof of this theorem is a bit complicated because it makes

heavy use of some linear algebra. The key is to set the learning rate
to 1/L, where L is the maximum curvature of the function that is
being optimized. The curvature is simply the “size” of the second
derivative. Functions with high curvature have gradients that change

?

A naive reading of this theorem
seems to say that you should choose
huge values of η. It should be obvi-
ous that this cannot be right. What
is missing?

96 a course in machine learning

quickly, which means that you need to take small steps to avoid
overstepping the optimum.

This convergence result suggests a simple approach to decid-

ing when to stop optimizing: wait until the objective function stops
changing by much. An alternative is to wait until the parameters stop
changing by much. A ﬁnal example is to do what you did for percep-
tron: early stopping. Every iteration, you can check the performance
of the current model on some held-out data, and stop optimizing
when performance plateaus.

7.5 From Gradients to Subgradients

As a good exercise, you should try deriving gradient descent update
rules for the different loss functions and different regularizers you’ve
learned about. However, if you do this, you might notice that hinge
loss and the 1-norm regularizer are not differentiable everywhere! In
particular, the 1-norm is not differentiable around wd = 0, and the
hinge loss is not differentiable around y ˆy = 1.

The solution to this is to use subgradient optimization. One way
to think about subgradients is just to not think about it: you essen-
tially need to just ignore the fact that you forgot that your function
wasn’t differentiable, and just try to apply gradient descent anyway.
z}. This function is differentiable for z > 1 and differentiable for
z < 1, but not differentiable at z = 1. You can derive this using
differentiation by parts:

To be more concrete, consider the hinge function f (z) = max{0, 1−

∂
∂z

0
1 − z

(cid:40)
(cid:40) ∂
∂z 0
(cid:40)
∂z (1 − z)
∂
if z ≥ 1
0
−1 if z < 1

if z > 1
if z < 1

if z > 1
if z < 1

∂
∂z

f (z) =

=

=

(7.21)

(7.22)

(7.23)

Thus, the derivative is zero for z < 1 and −1 for z > 1, matching

intuition from the Figure. At the non-differentiable point, z = 1,
we can use a subderivative: a generalization of derivatives to non-
differentiable functions. Intuitively, you can think of the derivative
of f at z as the tangent line. Namely, it is the line that touches f at
z that is always below f (for convex functions). The subderivative,
denoted ∂∂∂ f , is the set of all such lines. At differentiable positions,
this set consists just of the actual derivative. At non-differentiable
positions, this contains all slopes that deﬁne lines that always lie
under the function and make contact at the operating point. This is

Figure 7.8: hinge loss with sub

linear models

97

,

Algorithm 22 HingeRegularizedGD(D, λ, MaxIter)
1: w ← (cid:104)0, 0, . . . 0(cid:105)
2: for iter = 1 . . . MaxIter do
g ← (cid:104)0, 0, . . . 0(cid:105)
,
3:
for all (x,y) ∈ D do

b ← 0
g ← 0
if y(w · x + b) ≤ 1 then

4:

// initialize weights and bias

// initialize gradient of weights and bias

5:

6:

7:

g ← g + y x
g ← g + y

9:

8:

10:

end if
end for
g ← g − λw
11: w ← w + ηg
b ← b + ηg

12:
13: end for
14: return w, b

// update weight gradient
// update bias derivative

// add in regularization term
// update weights
// update bias

shown pictorally in Figure 7.8, where example subderivatives are
shown for the hinge loss function. In the particular case of hinge loss,
any value between 0 and −1 is a valid subderivative at z = 0. In fact,
the subderivative is always a closed set of the form [a, b], where a and
b can be derived by looking at limits from the left and right.

This gives you a way of computing derivative-like things for non-
differentiable functions. Take hinge loss as an example. For a given
example n, the subgradient of hinge loss can be computed as:

(cid:40)

0
1 − yn(w · xn + b) otherwise

= ∂∂∂w

∂∂∂w max{0, 1 − yn(w · xn + b)}
(cid:40)
(cid:40)

∂∂∂w0
∂∂∂w1 − yn(w · xn + b) otherwise
0
−ynxn otherwise

if yn(w · xn + b) > 1

=

=

if yn(w · xn + b) > 1

if yn(w · xn + b) > 1

(7.24)

(7.25)

(7.26)

(7.27)

If you plug this subgradient form into Algorithm 7.4, you obtain
Algorithm 7.5. This is the subgradient descent for regularized hinge
loss (with a 2-norm regularizer).

7.6 Closed-form Optimization for Squared Loss

Although gradient descent is a good, generic optimization algorithm,
there are cases when you can do better. An example is the case of a
2-norm regularizer and squared error loss function. For this, you can
actually obtain a closed form solution for the optimal weights. How-
ever, to obtain this, you need to rewrite the optimization problem in
terms of matrix operations. For simplicity, we will only consider the

98 a course in machine learning

MATH REVIEW | MATRIX MULTIPLICATION AND INVERSION
If A and B are matrices, and A is N×K and B is K×M (the inner dimensions must match), then the ma-
trix product AB is a matrix C that is N× M, with Cn,m = ∑k An,kBk,m. If v is a vector in RD, we will
treat is as a column vector, or a matrix of size D×1. Thus, Av is well deﬁned if A is D×M, and the result-
ing product is a vector u with um = ∑d Ad,mvd.

Aside from matrix product, a fundamental matrix operation is inversion. We will often encounter a
form like Ax = y, where A and y are known and we want to solve for A. If A is square of size N×N,
then the inverse of A, denoted A−1, is also a square matrix of size N×N, such that AA−1 = IN = A−1A.
I.e., multiplying a matrix by its inverse (on either side) gives back the identity matrix. Using this, we
can solve Ax = y by multiplying both sides by A−1 on the left (recall that order matters in matrix mul-
tiplication), yielding A−1Ax = A−1y from which we can conclude x = A−1y. Note that not all square
matrices are invertible. For instance, the all zeros matrix does not have an inverse (in the same way
that 1/0 is not deﬁned for scalars). However, there are other matrices that do not have inverses; such
matrices are called singular.

Figure 7.9:

unbiased version, but the extension is Exercise ??. This is precisely the
linear regression setting.
You can think of the training data as a large matrix X of size N×D,

where Xn,d is the value of the dth feature on the nth example. You
can think of the labels as a column (“tall”) vector Y of dimension N.
Finally, you can think of the weights as a column vector w of size
D. Thus, the matrix-vector product a = Xw has dimension N. In
particular:

an = [Xw]n = ∑

d

Xn,dwd

(7.28)

This means, in particular, that a is actually the predictions of the
model. Instead of calling this a, we will call it ˆY. The squared error
∑n( ˆYn − Yn)2, which can be written
says that we should minimize 1
2
in vector form as a minimization of 1
2
This can be expanded visually as:

?

Verify that the squared error can
actually be written as this vector
norm.



(cid:124)

x1,1
x2,1
...
xN,1

. . .
. . .
...
. . .

x1,D
x2,D
...
xN,D

x1,2
x2,2
...
xN,2

(cid:123)(cid:122)

X

(cid:12)(cid:12)(cid:12)(cid:12) ˆY − Y(cid:12)(cid:12)(cid:12)(cid:12)2.



=

(cid:125)

(cid:124)

∑d x1,dwd
∑d x2,dwd

∑d xN,dwd

...
(cid:123)(cid:122)

ˆY



(cid:125)



(cid:124)

w1
w2
...
(cid:123)(cid:122)
wD
w



(cid:125)

≈





y1
y2
...
(cid:124) (cid:123)(cid:122) (cid:125)
yN

ˆY
(7.29)

linear models

99

So, compactly, our optimization problem can be written as:

min
w

L(w) =

1
2

||Xw − Y||2 +

||w||2

λ
2

(7.30)

If you recall from calculus, you can minimize a function by setting its
derivative to zero. We start with the weights w and take gradients:

∇wL(w) = X(cid:62) (Xw − Y) + λw
(cid:16)
= X(cid:62)Xw − X(cid:62)Y + λw
w − X(cid:62)Y
=

(cid:17)

X(cid:62)X + λI
(cid:17)
X(cid:62)X + λI
(cid:16)
X(cid:62)X + λID

(cid:17)
w − X(cid:62)Y = 0
w = X(cid:62)Y
X(cid:62)X + λID

(cid:17)−1X(cid:62)Y

We can equate this to zero and solve, yielding:

(cid:16)
⇐⇒ (cid:16)

⇐⇒ w =

(7.31)
(7.32)
(7.33)

(7.34)
(7.35)
(7.36)

?

For those who are keen on linear
algebra, you might be worried that
the matrix you must invert might
not be invertible. Is this actually a
problem?

Thus, the optimal solution of the weights can be computed by a few
matrix multiplications and a matrix inversion. As a sanity check,
you can make sure that the dimensions match. The matrix X(cid:62)X has
dimension D×D, and therefore so does the inverse term. The inverse
is D×D and X(cid:62) is D×N, so that product is D×N. Multiplying through
by the N×1 vector Y yields a D×1 vector, which is precisely what we
want for the weights.

Note that this gives an exact solution, modulo numerical innacu-

racies with computing matrix inverses. In contrast, gradient descent
will give you progressively better solutions and will “eventually”
converge to the optimum at a rate of 1/k. This means that if you
want an answer that’s within an accuracy of  = 10−4, you will need
something on the order of one thousand steps.
The question is whether getting this exact solution is always more
efﬁcient. To run gradient descent for one step will take O(ND) time,
with a relatively small constant. You will have to run K iterations,
yielding an overall runtime of O(KND). On the other hand, the
closed form solution requires constructing X(cid:62)X, which takes O(D2N)
time. The inversion take O(D3) time using standard matrix inver-
sion routines. The ﬁnal multiplications take O(ND) time. Thus, the
overall runtime is on the order O(D3 + D2N). In most standard cases
(though this is becoming less true over time), N > D, so this is domi-
nated by O(D2N).

Thus, the overall question is whether you will need to run more
than D-many iterations of gradient descent. If so, then the matrix
inversion will be (roughly) faster. Otherwise, gradient descent will
be (roughly) faster. For low- and medium-dimensional problems (say,

100 a course in machine learning

D ≤ 100), it is probably faster to do the closed form solution via
matrix inversion. For high dimensional problems (D ≥ 10, 000), it is
probably faster to do gradient descent. For things in the middle, it’s
hard to say for sure.

7.7 Support Vector Machines

At the beginning of this chapter, you may have looked at the convex
surrogate loss functions and asked yourself: where did these come
from?! They are all derived from different underlying principles,
which essentially correspond to different inductive biases.

Let’s start by thinking back to the original goal of linear classiﬁers:

to ﬁnd a hyperplane that separates the positive training examples
from the negative ones. Figure 7.10 shows some data and three po-
tential hyperplanes: red, green and blue. Which one do you like best?

Most likely you chose the green hyperplane. And most likely you
chose it because it was furthest away from the closest training points.
In other words, it had a large margin. The desire for hyperplanes
with large margins is a perfect example of an inductive bias. The data
does not tell us which of the three hyperplanes is best: we have to
choose one using some other source of information.

Following this line of thinking leads us to the support vector ma-

chine (SVM). This is simply a way of setting up an optimization
problem that attempts to ﬁnd a separating hyperplane with as large
a margin as possible. It is written as a constrained optimization
problem:

Figure 7.10: picture of data points with
three hyperplanes, RGB with G the best

1

γ(w, b)

min
w,b

subj. to yn (w · xn + b) ≥ 1

(7.37)

(∀n)

In this optimization, you are trying to ﬁnd parameters that maximize
the margin, denoted γ, (i.e., minimize the reciprocal of the margin)
subject to the constraint that all training examples are correctly classi-
ﬁed.

The “odd” thing about this optimization problem is that we re-

quire the classiﬁcation of each point to be greater than one rather than
simply greater than zero. However, the problem doesn’t fundamen-
tally change if you replace the “1” with any other positive constant
(see Exercise ??). As shown in Figure 7.11, the constant one can be
interpreted visually as ensuring that there is a non-trivial margin
between the positive points and negative points.

The difﬁculty with the optimization problem in Eq (7.37) is what
happens with data that is not linearly separable. In that case, there
is no set of parameters w, b that can simultaneously satisfy all the

Figure 7.11: hyperplane with margins
on sides

linear models

101

Figure 7.12: one bad point with slack

constraints. In optimization terms, you would say that the feasible
region is empty. (The feasible region is simply the set of all parame-
ters that satify the constraints.) For this reason, this is refered to as
the hard-margin SVM, because enforcing the margin is a hard con-
straint. The question is: how to modify this optimization problem so
that it can handle inseparable data.

The key idea is the use of slack parameters. The intuition behind
slack parameters is the following. Suppose we ﬁnd a set of param-
eters w, b that do a really good job on 9999 data points. The points
are perfectly classifed and you achieve a large margin. But there’s
one pesky data point left that cannot be put on the proper side of the
margin: perhaps it is noisy. (See Figure 7.12.) You want to be able
to pretend that you can “move” that point across the hyperplane on
to the proper side. You will have to pay a little bit to do so, but as
long as you aren’t moving a lot of points around, it should be a good
idea to do this. In this picture, the amount that you move the point is
denoted ξ (xi).

By introducing one slack parameter for each training example,
and penalizing yourself for having to use slack, you can create an
objective function like the following, soft-margin SVM:

+ C ∑
n

ξn

γ(w, b)

(cid:124) (cid:123)(cid:122) (cid:125)

(cid:124) (cid:123)(cid:122) (cid:125)
subj. to yn (w · xn + b) ≥ 1 − ξn

large margin

small slack

1

min
w,b,ξ

ξn ≥ 0

(7.38)

(∀n)
(∀n)

The goal of this objective function is to ensure that all points are
correctly classiﬁed (the ﬁrst constraint). But if a point n cannot be
correctly classiﬁed, then you can set the slack ξn to something greater
than zero to “move” it in the correct direction. However, for all non-
zero slacks, you have to pay in the objective function proportional to
the amount of slack. The hyperparameter C > 0 controls overﬁtting
versus underﬁtting. The second constraint simply says that you must
not have negative slack.

One major advantage of the soft-margin SVM over the original
hard-margin SVM is that the feasible region is never empty. That is,
there is always going to be some solution, regardless of whether your
training data is linearly separable or not.

It’s one thing to write down an optimization problem. It’s another

thing to try to solve it. There are a very large number of ways to
optimize SVMs, essentially because they are such a popular learning
model. Here, we will talk just about one, very simple way. More
complex methods will be discussed later in this book once you have a
bit more background.

?

What values of C will lead to over-
ﬁtting? What values will lead to
underﬁtting?

?

Suppose I give you a data set.
Without even looking at the data,
construct for me a feasible solution
to the soft-margin SVM. What is
the value of the objective for this
solution?

102 a course in machine learning

By this observation, there is some positive example that that lies

To make progress, you need to be able to measure the size of the
margin. Suppose someone gives you parameters w, b that optimize
the hard-margin SVM. We wish to measure the size of the margin.
The ﬁrst observation is that the hyperplane will lie exactly halfway
between the nearest positive point and nearest negative point. If not,
the margin could be made bigger by simply sliding it one way or the
other by adjusting the bias b.
exactly 1 unit from the hyperplane. Call it x+, so that w · x+ + b = 1.
Similarly, there is some negative example, x−, that lies exactly on
the other side of the margin: for which w · x− + b = −1. These two
points, x+ and x− give us a way to measure the size of the margin.
As shown in Figure 7.11, we can measure the size of the margin by
looking at the difference between the lengths of projections of x+
and x− onto the hyperplane. Since projection requires a normalized
vector, we can measure the distances as:

Figure 7.13: copy of ﬁgure from p5 of
cs544 svm tutorial

d+ =
d− = − 1

1

||w|| w · x+ + b − 1
||w|| w · x− − b + 1
(cid:2)d+ − d−(cid:3)
(cid:20) 1
||w|| w · x−(cid:21)
(cid:20) 1
||w|| w · x− − b + 1
||w|| w · x+ + b − 1 − 1
(cid:20) 1
(cid:21)
||w|| w · x+ − 1
||w|| (+1) − 1

||w|| (−1)

We can then compute the margin by algebra:

γ =

=

=

=

=

1
2
1
2
1
2
1
2
1
||w||

(cid:21)

(7.39)

(7.40)

(7.41)

(7.42)

(7.43)

(7.44)

(7.45)

This is a remarkable conclusion: the size of the margin is inversely
proportional to the norm of the weight vector. Thus, maximizing the
margin is equivalent to minimizing ||w||! This serves as an addi-
tional justiﬁcation of the 2-norm regularizer: having small weights
means having large margins!

However, our goal wasn’t to justify the regularizer: it was to un-
derstand hinge loss. So let us go back to the soft-margin SVM and
plug in our new knowledge about margins:

min
w,b,ξ

||w||2

(cid:124) (cid:123)(cid:122) (cid:125)

1
2
large margin

+ C ∑
n

(cid:124) (cid:123)(cid:122) (cid:125)

ξn

small slack

(7.46)

linear models

103

subj. to yn (w · xn + b) ≥ 1 − ξn

ξn ≥ 0

(∀n)
(∀n)

Now, let’s play a thought experiment. Suppose someone handed
you a solution to this optimization problem that consisted of weights
(w) and a bias (b), but they forgot to give you the slacks. Could you
recover the slacks from the information you have?

In fact, the answer is yes! For simplicity, let’s consider positive

examples. Suppose that you look at some positive example xn. You
need to ﬁgure out what the slack, ξn, would have been. There are two
cases. Either w · xn + b is at least 1 or it is not. If it’s large enough,
then you want to set ξn = 0. Why? It cannot be less than zero by the
second constraint. Moreover, if you set it greater than zero, you will
“pay” unnecessarily in the objective. So in this case, ξn = 0. Next,
suppose that w · xn + b = 0.2, so it is not big enough. In order to
satisfy the ﬁrst constraint, you’ll need to set ξn ≥ 0.8. But because
of the objective, you’ll not want to set it any larger than necessary, so
you’ll set ξn = 0.8 exactly.

Following this argument through for both positive and negative

points, if someone gives you solutions for w, b, you can automatically
compute the optimal ξ variables as:

(cid:40)

ξn =

0
1 − yn(w · xn + b) otherwise

if yn(w · xn + b) ≥ 1

(7.47)

In other words, the optimal value for a slack variable is exactly the
hinge loss on the corresponding example! Thus, we can write the
SVM objective as an unconstrained optimization problem:

min
w,b

||w||2

(cid:124) (cid:123)(cid:122) (cid:125)

1
2
large margin

+ C ∑
n

(cid:124)

(cid:125)
(cid:96)(hin)(yn, w · xn + b)

(cid:123)(cid:122)

small slack

(7.48)

Multiplying this objective through by λ/C, we obtain exactly the reg-
ularized objective from Eq (7.8) with hinge loss as the loss function
and the 2-norm as the regularizer!

7.8 Further Reading

TODO further reading

8 | BIAS AND FAIRNESS

Science and everyday life cannot
and should not be separated.

– Rosalind Franklin

Learning Objectives:
•

At the end of Chapter 1, you saw the “Russian Tank” example of
a biased data set leading to a classiﬁer that seemed like it was doing
well, but was really relying on some artifact of the data collection
process. As machine learning algorithms have a greater and greater
impact on the real world, it is crucially important to ensure that they
are making decisions based on the “right” aspects of the input, rather
than exploiting arbitrary idiosyncracies of a particular training set.
For the rest of this chapter, we will consider two real world ex-
amples of bias issues that have had signiﬁcant impact: the effect of
gender in speech recognition systems and the effect of race in pre-
dicting criminal recidivism (i.e., will a convicted criminal commit
further crimes if released).1 The gender issue is that early speech
recognition systems in cars failed to recognized the voices of many
people who were not men. The race issue is that a speciﬁc recidivism
predictor based on standard learning algorithms was biased against
minorities.

8.1 Train/Test Mismatch

One of the most common issues in bias is a mismatch between the
training distribution and the testing distribution. In the running
example of speech recognition failing to work on many non-men
speakers, a large part of this happened because most of the training
data on which the speech recognition system was trained was spoken
by men. The learning algorithm learned—very well—how to recog-
nize men’s speech, but its accuracy dropped signiﬁcantly when faced
with a different distribution of test data.

To understand why this happens, recall the Bayes Optimal clas-
siﬁer from Chapter 2. This was the classiﬁer than magically know
the data distribution D, and then when presented with an example x
predicted argmaxy D(x, y). This was optimal, but only because D was
the correct distribution. Even if one has access to the true distribu-
tion for male speakers, say D(male), the Bayes Optimal classiﬁer under

Dependencies: Chapter 1,Chap-
ter 3,Chapter 4,Chapter 5
1 See Autoblog and ProPublica for press
coverage of these two issues.

bias and fairness

105

D(male) will generally not be optimal under the distribution for any
other gender.

Another example occurs in sentiment analysis. It is common to

train sentiment analysis systems on data collected from reviews:
product reviews, restaurant reviews, movie reviews, etc. This data is
convenient because it includes both text (the review itself) and also
a rating (typically one to ﬁve stars). This yields a “free” dataset for
training a model to predict rating given text. However, one should
be wary when running such a sentiment classiﬁer on text other than
the types of reviews it was trained on. One can easily imagine that
a sentiment analyzer trained on movie reviews may not work so
well when trying to detect sentiment in a politician’s speech. Even
moving between one type of product and another can fail wildly:
“very small” typically expresses positive sentiment for USB drives,
but not for hotel rooms.

The issue of train/test mismatch has been widely studied under

many different names: covariate shift (in statistics, the input features
are called “covariates”), sample selection bias and domain adapta-
tion are the most common. We will refer to this problem simply as
adaptation. The adaptation challenge is: given training data from one
“old” distribution, learn a classiﬁer that does a good job on another
related, but different, “new” distribution.

It’s important to recognize that in general, adaptation is im-
possible. For example, even if the task remains the same (posi-
tive/negative sentiment), if the old distribution is text reviews and
the new distribution is images of text reviews, it’s hard to imagine
that doing well on the old distribution says anything about the new.
As a less extreme example, if the old distribution is movie reviews in
English and the new distribution is movie reviews in Mandarin, it’s
unlikely that adaptation will be easy.

These examples give rise to the tension in adaptation problems.

1. What does it mean for two distributions to be related? We might

believe that “reviews of DVDs” and “reviews of movies” are
“highly related” (though somewhat different: DVD reviews of-
ten discuss bonus features, quality, etc.); while “reviews of hotels”
and “reviews of political policies” are “less related.” But how can
we formalize this?

2. When two distributions are related, how can we build models that

effectively share information between them?

106 a course in machine learning

8.2 Unsupervised Adaptation

The ﬁrst type of adaptation we will cover is unsupervised adapta-
tion. The setting is the following. There are two distributions, Dold
and Dnew. We have labeled training data from Dold, say (x1, y1), . . . , (xN, yN)
totalling N examples. We also have M many unlabeled examples from
Dnew: z1, . . . , zM. We assume that the examples live in the same
space, RD. This is called unsupervised adaptation because we do not
have access to any labels in the new distribution.2
Our goal is to learn a classiﬁer f that achieves low expected loss
under the new distribution, Dnew. The challenge is that we do not have
access to any labeled data from Dnew. As a warm-up, let’s suppose
that we have a black box machine learning algorithm A that takes
in weighted examples and produces a classiﬁer. At the very least,
this can be achieved using either undersampling or oversampling
(see Section 6.1). We’re going to attempt to reweigh the (old distri-
bution) labeled examples based on how similar they are to the new
distribution. This is justiﬁed using the importance sampling trick for
switching expectations:

2 Sometimes this is called semi-super-
vised adaptation in the literature.

test loss
= E
= ∑
(x,y)
= ∑
(x,y)
= ∑
(x,y)

(x,y)∼Dnew [(cid:96)(y, f (x))]
Dnew(x, y)(cid:96)(y, f (x))
Dold(x, y)
Dold(x, y)
Dnew(x, y)
Dold(x, y)

Dnew(x, y)

Dold(x, y)

(cid:20)Dnew(x, y)

Dold(x, y)

= E

(x,y)∼Dold

deﬁnition

expand expectation

(8.1)
(8.2)
(8.3)

(cid:96)(y, f (x))

times one

(8.4)

(cid:96)(y, f (x))

(cid:21)

(cid:96)(y, f (x))

rearrange

(8.5)

deﬁnition

(8.6)

What we have achieved here is rewriting the test loss, which is an

expectation over Dnew, as an expectation over Dold instead.3 This
is useful because we have access to labeled examples from Dold
but not Dnew. The implicit suggested algorithm by this analysis
to to train a classiﬁer using our learning algorithm A, but where
each training example (xn, yn) is weighted according to the ratio
Dnew(xn, yn)/Dold(xn, yn). Intuitively, this makes sense: the classiﬁer
is being told to pay more attention to training examples that have
high probability under the new distribution, and less attention to
training that have low probability under the new distribution.
The problem with this approach is that we do not have access to
Dnew or Dold, so we cannot compute this ratio and therefore cannot
run this algorithm. One approach to this problem is to try to explic-

3 In this example, we assumed a discrete
distribution; if the distributions are con-
tinuous, the sums are simply replaced
with integrals.

bias and fairness

107

itly estimate these distributions, a task known as density estimation.
This is an incredibly difﬁcult problem; far harder than the original
adaptation problem.

A solution to this problem is to try to estimate the ratio directly,
rather than separately estimating the two probability distributions4.
The key idea is to think of the adaptation as follows. All examples
are drawn according to some ﬁxed base distribution Dbase. Some
of these are selected to go into the new distribution, and some of
them are selected to go into the old distribution. The mechanism for
deciding which ones are kept and which are thrown out is governed
by a selection variable, which we call s. The choice of selection-or-
not, s, is based only on the input example x and not on it’s label.
particular, we deﬁne:

In

4 Bickel et al. 2007

?

What could go wrong if s got to
look at the label, too?

Dold(x, y) ∝ Dbase(x, y)p(s = 1 | x)
(8.7)
Dnew(x, y) ∝ Dbase(x, y)p(s = 0 | x)
(8.8)
That is, the probability of drawing some pair (x, y) in the old distri-
bution is proportional to the probability of ﬁrst drawing that example
according to the base distribution, and then the probability of se-
lecting that particular example into the old distribution. If we can
successfully estimate p(s = 1 | x), then the ratio that we sought, then
we can compute the importance ratio as:

Dnew(x, y)
Dold(x, y)

=

=

= Z

= Z

= Z

1

1

1

1

Znew Dbase(x, y)p(s = 0 | x)
Zold Dbase(x, y)p(s = 1 | x)
Znew p(s = 0 | x)
Zold p(s = 1 | x)
p(s = 0 | x)
p(s = 1 | x)
1 − p(s = 1 | x)
(cid:20)
p(s = 1 | x)
p(s = 1 | x)

− 1

(cid:21)

1

deﬁnition

(8.9)

cancel base (8.10)

consolidate (8.11)

binary selection (8.12)

rearrange (8.13)

This means that if we can estimate the selection probability p(s =
1 | x), we’re done. We can therefore use 1/p(s = 1 | xn) − 1 as an
example weight on example (xn, yn) when feeding these examples
into our learning algorithm A.
The remaining question is how to estimate p(s = 1 | xn). Recall
that s = 1 denotes the case that x is selected into the old distribution
and s = 0 denotes the case that x is selected into the new distribution.
This means that predicting s is exactly a binary classiﬁcation problem,
where the “positive” class is the set of N examples from the old
distribution and the “negative” class is the set of M examples from
the new distribution.

?

As a check: make sure that these
weights are always non-negative.
Furthermore, why is it okay to
ignore the Z factor?

108 a course in machine learning

Algorithm 23 SelectionAdaptation((cid:104)(xn, yn)(cid:105)N
1: Ddist ← (cid:104)(xn, +1)(cid:105)N
n=1

(cid:83) (cid:104)(zm,−1)(cid:105)M
m=1
(cid:69)N
ˆp ← train logistic regression on Ddist

3: Dweighted ←(cid:68)

2:

1

ˆp(xn) − 1)

n=1

(xn, yn,
4: return A(Dweighted)

n=1, (cid:104)zm(cid:105)M

m=1, A)

// assemble data for distinguishing
// between old and new distributions

// assemble weight classiﬁcation
// data using selector
// train classiﬁer

This analysis gives rise to Algorithm 8.2, which consists of essen-
tially two steps. The ﬁrst is to train a logistic regression classiﬁer5 to
distinguish between old and new distributions. The second is to use
that classiﬁer to produce weights on the labeled examples from the
old distribution and then train whatever learning algorithm you wish
on that.

In terms of the questions posed at the beginning of this chapter,
this approach to adaptation measures nearness of the two distribu-
tions by the degree to which the selection probability is constant. In
particular, if the selection probability is independent of x, then the
two distributions are identical. If the selection probabilities vary sigi-
ﬁcantly as x changes, then the two distributions are considered very
different. More generally, if it is easy to train a classiﬁer to distin-
guish between the old and new distributions, then they are very
different.

In the case of speech recognition failing as a function of gender, a
core issue is that speech from men was massively over-represented
in the training data but not the test data. When the selection logistic
regression is trained, it is likely to say “old” on speech from men and
“new” on other speakers, thereby downweighting the signiﬁcance of
male speakers and upweighting the signiﬁcance of speakers of other
genders on the ﬁnal learned model. This would (hopefully) address
many of the issues confounding that system.

8.3 Supervised Adaptation

Unsupervised adaptation is very challenging because we never get to
see try labels in the new distribution. In many ways, unsupervised
adaptation attempts to guard against bad things happening. That is,
if an old distribution training example looks very unlike the new
distribution, it (and consequently it’s features) are downweighted so
much as to be ignored. In supervised adaptation, we can hope for
more: we can hope to actually do better on the new distribution than
the old because we have labeled data there.

The typical setup is similar to the unsupervised case. There are

5 The use of logistic regression is arbi-
trary: it need only be a classiﬁcation
algorithm that can produce probabili-
ties.

?

Make up percentages for fraction
of speakers who are male in the
old and new distributions; estimate
(you’ll have to make some assump-
tions) what the importance weights
would look like in this case.

bias and fairness

109

6 Daumé III 2007

(cid:69)N
Algorithm 24 EasyAdapt((cid:104)(x(old)
n

1: D ←(cid:68)

, 0(cid:105), y(old)

, x(old)

)

n

n

, y(old)

n

(cid:83)(cid:68)

)(cid:105)N
n=1, (cid:104)(x(new)
((cid:104)x(new)
m , 0, x(new)

n=1

((cid:104)x(old)
n
2: return A(D)

(cid:69)M
m )(cid:105)M
m=1, A)
m , y(new)
m (cid:105), y(new)
// union
m )
// of transformed data
// train classiﬁer

m=1

two distributions, Dold and Dnew, and our goal is to learn a classi-
ﬁer that does well in expectation on Dnew. However, now we have
labeled data from both distributions: N labeled examples from Dold
(cid:105)N
and M labeled examples from Dnew. Call them (cid:104)x(old)
n=1 from
n
Dold and (cid:104)x(new)
m=1 from Dnew. Again, suppose that both x(old)
n
and x(new)

m (cid:105)M
m , y(new)
both live in RD.

, y(old)

n

m

One way of answer the question of “how do we share informa-

tion between the two distributions” is to say: when the distributions
agree on the value of a feature, let them share it, but when they dis-
agree, allow them to learn separately. For instance, in a sentiment
analysis task, Dold might be reviews of electronics and Dnew might
be reviews of hotel rooms. In both cases, if the review contains the
word “awesome” then it’s probably a positive review, regardless of
which distribution we’re in. We would want to share this information
across distributions. On the other hand, “small” might be positive
in electronics and negative in hotels, and we would like the learning
algorithm to be able to learn separate information for that feature.

A very straightforward way to accomplish this is the feature aug-
mentation approach6. This is a simple preprocessing step after which
one can apply any learning algorithm. The idea is to create three ver-
sions of every feature: one that’s shared (for words like “awesome”),
one that’s old-distribution-speciﬁc and one that’s new-distribution-
speciﬁc. The mapping is:

new-only

(cid:123)(cid:122)

(cid:125)

D-many

, 0, 0, . . . , 0

(cid:124)

(cid:69)
(cid:69)

shared
x(old)
n

old-only
, x(old)

n

x(new)
m

, 0, 0, . . . , 0

, x(new)

m

(cid:124)

(cid:123)(cid:122)

D-many

(cid:125)

(cid:55)→(cid:68)
(cid:55)→(cid:68)

x(old)
n

x(new)
m

(8.14)

(8.15)

Once you’ve applied this transformation, you can take the union
of the (transformed) old and new labeled examples and feed the en-
tire set into your favorite classiﬁcation algorithm. That classiﬁcation
algorithm can then choose to share strength between the two distri-
butions by using the “shared” features, if possible; or, if not, it can
learn distribution-speciﬁc properties on the old-only or new-only
parts. This is summarized in Algorithm 8.3.

Note that this algorithm can be combined with the instance weight-

?

Why is it crucial that the separator
be trained on the untransformed
data?

110 a course in machine learning

ing (unsupervised) learning algorithm. In this case, the logistic re-
gression separator should be trained on the untransformed data, and
then weights can be used exactly as in Algorithm 8.2. This is particu-
larly useful if you have access to way more old distribution data than
new distribution data, and you don’t want the old distribution data
to “wash out” the new distribution data.

Although this approach is general, it is most effective when the

two distributions are “not too close but not too far”:

• If the distributions are too far, and there’s little information to

share, you’re probably better off throwing out the old distribution
data and training just on the (untransformed) new distribution
data.

• If the distributions are too close, then you might as well just take
the union of the (untransformed) old and new distribution data,
and training on that.

In general, the interplay between how far the distributions are and
how much new distribution data you have is complex, and you
should always try “old only” and “new only” and “simple union”
as baselines.

8.4 Fairness and Data Bias

Almost any data set in existence is biased in some way, in the sense
that it captures an imperfect view of the world. The degree to which
this bias is obvious can vary greatly:

• There might be obvious bias in the labeling. For instance, in crimi-
nology, learning to predict sentence lengths by predicting the sen-
tences assigned by judges will simply learn to reproduce whatever
bias already exists in judicial sentencing.

• There might be sample selection bias, as discussed early. In the
same criminology example, the only people for which we have
training data are those that have already been arrested, charged
with and convicted of a crime; these processes are inherantly bi-
ased, and so any model learned on this data may exhibit similar
biases.

• The task itself might be biased because the designers had blindspots.

An intelligent billboard that predicts the gender of the person
walking toward it so as to show “better” advertisements may be
trained as a binary classiﬁer between male/female and thereby
excludes anyone who does not fall in the gender binary. A similar
example holds for a classiﬁer that predicts political afﬁliation in

bias and fairness

111

7 For instance, many languages have
verbal marking that agrees with the
gender of the subject. In such cases,
“the doctor treats . . . ” puts masculine
markers on the translation of “treats”
but “the nurse treats . . . ” uses feminine
markers.

8 ACM Code of Ethics

the US as Democrat/Republican, when in fact there are far more
possibilities.

• There might be bias in the features or model structure. Machine

translation systems often exhibit incorrect gender stereotypes7
because the relevant context, which would tell them the correct
gender, is not encoded in the feature representation. Alone, or
coupled with biased data, this leads to errors.

• The loss function may favor certain types of errors over others.
You’ve already seen such an example: using zero/one loss on
a highly imbalanced class problem will often lead to a learned
model that ignores the minority class entirely.

• A deployed system creates feedback loops when it begins to con-

sume it’s own output as new input. For instance, once a spam
ﬁlter is in place, spammers will adjust their strategies, leading to
distribution shift in the inputs. Or a car guidance system for pre-
dicting which roads are likely to be unoccupied may ﬁnd those
roads now occupied by other cars that it directed there.

These are all difﬁcult questions, none of which has easy answers.
Nonetheless, it’s important to be aware of how our systems may
fail, especially as they take over more and more of our lives. Most
computing, engineering and mathematical societies (like the ACM,
IEEE, BCS, etc.) have codes of ethics, all of which include a statement
about avoiding harm; the following is taken from the ACM code8:

To minimize the possibility of indirectly harming others, computing
professionals must minimize malfunctions by following generally
accepted standards for system design and testing. Furthermore, it is
often necessary to assess the social consequences of systems to project
the likelihood of any serious harm to others.

In addition to ethical questions, there are often related legal ques-
tions. For example, US law prohibits discrimination by race and gen-
der (among other “protected attributes”) in processes like hiring and
housing. The current legal mechanism for measuring discimination is
disparate impact and the 80% rule. Informally, the 80% rule says that
your rate of hiring women (for instance) must be at least 80% of your
rate of hiring men. Formally, the rule states:

Pr(y = +1 | G (cid:54)= male) ≥ 0.8× Pr(y = +1 | G = male)

(8.16)

Of course, gender/male can be replaced with any other protected
attribute.

One non-solution to the disparate impact problem is to simply

throw out protected attributes from your dataset. Importantly, yet un-
fortunately, this is not sufﬁcient. Many other features often correlate

112 a course in machine learning

strongly with gender, race, and other demographic information, and
just because you’ve removed explicit encodings of these factors does
not imply that a model trained as such would satisfy the 80% rule. A
natural question to ask is: can we build machine learning algorithms
that have high accuracy but simultaneously avoid disparate impact?

Disparate impact is an imperfect measure of (un)fairness, and

there are alternatives, each with it’s own pros and cons9. All of these
rely on predeﬁned categories of protected attributes, and a natural
question is where these come from if not governmental regulation.
Regardless of the measure you choose, the most important thing to
keep in mind is that just because something comes from data, or is
algorithmically implemented, does not mean it’s fair.

8.5 How Badly can it Go?

9 Friedler et al. 2016, Hardt et al. 2016

To help better understand how badly things can go when the distri-
bution over inputs changes, it’s worth thinking about how to analyze
this situation formally. Suppose we have two distributions Dold and
Dnew, and let’s assume that the only thing that’s different about these
is the distribution they put on the inputs X and not the outputs Y.
(We will return later to the usefulness of this assumption.) That is:
Dold(x, y) = Dold(x)D(y | x) and Dnew(x, y) = Dnew(x)D(y | x),
where D(y | x) is shared between them.
Dold and achieves some test error of (old). That is:

Let’s say that you’ve learned a classiﬁer f that does really well on

(8.17)

(cid:2)1[ f (x) (cid:54)= y](cid:3)

(old) = E

x∼Dold
y∼D(· | x)

The question is: how badly can f do on the new distribution?

We can calculate this directly.

(cid:2)1[ f (x) (cid:54)= y](cid:3)

(new)
= E x∼Dnew
y∼D(· | x)

(cid:90)
(cid:90)

=

X

(cid:90)
(cid:16)Dnew(x) − Dold(x) + Dold(x)

Dnew(x)D(y | x)1[ f (x) (cid:54)= y]dydx

(cid:17)×

Y

Y

X

=

(cid:90)
= (old)+(cid:90)
(cid:90)

X

Y

D(y | x)1[ f (x) (cid:54)= y]dydx

(cid:16)Dnew(x) − Dold(x)

(cid:17)×

D(y | x)1[ f (x) (cid:54)= y]dydx

(8.18)

def. of E (8.19)

add zero (8.20)

def. old

(8.21)

(cid:90)

≤ (old) +

= (old) + 2

(cid:12)(cid:12)(cid:12)Dnew(x) − Dold(x)
(cid:12)(cid:12)(cid:12)Dnew − Dold(cid:12)(cid:12)(cid:12)Var

X

(cid:17)

(cid:12)(cid:12)(cid:12)(cid:16)

1

dx

worst case

(cid:90)
def. |·|Var

Y (8.22)
(8.23)

bias and fairness

113

Here, |·|Var is the total variation distance (or variational distance)
between two probability distributions, deﬁned as:

|P − Q|Var = sup

e

|P(e) − Q(e)| =

1
2

|P(x) − Q(x)| dx

(8.24)

X

(cid:90)

Is a standard measure of dissimilarity between probability distribu-
tions. In particular, the variational distance is the largest difference
in probability that P and Q assign to the same event (in this case, the
event is an example x).

The bound tells us that we might not be able to hope for very

good error on the new distribution, even if we have very good error
on the old distribution, when Dold and Dnew are very different (as-
sign very different probabilities to the same event). Of course, this is
an upper bound, and possibly a very loose one.
The second observation is that we barely used the assumption that
Dnew and Dold share the same label distribution D(y | x) in the above
analysis. (In fact, as an exercise, repeat the analysis without this as-
sumption. It will still go through.) In general, this assumption buys
us very little. In an extreme case, Dnew and Dold can essentially “en-
code” which distribution a given x came from in one of the features.
Once the origin distribution is completely encoded in a feature, then
D(y | x) could look at the encoding, and completely ﬂip the label
based on which distribution it’s from. How could Dnew and Dold
encode the distribution? One way would be to set the 29th decimal
digit of feature 1 to an odd value in the old distribution and an even
value in the new distribution. This tiny change will be essentially im-
perceptible if one looks at the data, but would give D(y | x) enough
power to make our lives miserable.

If we want a way out of this dilemma, we need more technology.
The core idea is that if we’re learning a function f from some hypoth-
esis class F, and this hypothesis class isn’t rich enough to peek at the
29th decimal digit of feature 1, then perhaps things are not as bad
as they could be. This motivates the idea of looking at a measure of
distance between probability distributions that depends on the hypoth-
esis class. A popular measure is the dA-distance or the discrepancy.
The discrepancy measure distances between probability distributions
based on how much two function f and f (cid:48) in the hypothesis class can
disagree on their labels. Let:

(cid:104)

(cid:105)

P( f , f (cid:48)) = Ex∼P

1[ f (x) (cid:54)= f (cid:48)(x)]

(8.25)

114 a course in machine learning

You can think of P( f , f (cid:48)) as the error of f (cid:48) when the ground truth is
given by f , where the error is taken with repsect to examples drawn
from P. Given a hypothesis class F, the discrepancy between P and
Q is deﬁned as:

(cid:12)(cid:12)P( f , f (cid:48)) − Q( f , f (cid:48))(cid:12)(cid:12)

dA(P, Q) = max
f , f (cid:48)∈F

(8.26)

The discrepancy very much has the ﬂavor of a classiﬁer: if you think
of f as providing the ground truth labeling, then the discrepancy is
large whenever there exists a function f (cid:48) that agrees strongly with f
on distribution P but disagrees strongly with f on Q. This feels natu-
ral: if all functions behave similarly on P and Q, then the discrepancy
will be small, and we also expect to be able to generalize across these
two distributions easily.
One very attractive property of the discrepancy is that you can
estimate it from ﬁnite unlabeled samples from Dold and Dnew. Al-
though not obvious at ﬁrst, the discrepancy is very closely related
to a quantity we saw earlier in unsupervised adaptation: a classiﬁer
that distinguishes between Dold and Dnew. In fact, the discrepancy is
precisely twice the accuracy of the best classiﬁer from H at separating
Dold from Dnew.

How does this work in practice? Exactly as in the section on un-
supervised adaptation, we train a classiﬁer to distinguish between
Dold and Dnew. It needn’t be a probabilistic classiﬁer; any binary
classiﬁer is ﬁne. This classiﬁer, the “domain separator,” will have
some (heldout) accuracy, call it acc. The discrepancy is then exactly
dA = 2(acc − 0.5).

Intuitively the accuracy of the domain separator is a natural mea-

One can, in fact, prove a generalization bound—generalizing from

sure of how different the two distributions are. If the two distribu-
tions are identical, you shouldn’t expect to get very good accuracy at
separating them. In particular, you expect the accuracy to be around
0.5, which puts the discrepancy at zero. On the other hand, if the two
distributions are really far apart, separation is easy, and you expect
an accuracy of about 1, yielding a discrepancy also of about 1.
ﬁnite samples from Dold to expected loss on Dnew—based on the
discrepancy10.
Theorem 9 (Unsupervised Adaptation Bound). Given a ﬁxed rep-
resentation and a ﬁxed hypothesis space F, let f ∈ F and let (best) =
min f ∗∈F 1
(cid:124)
2
(new)( f )
error on Dnew
In this bound, (best) denotes the error rate of the best possible
classiﬁer from F, where the error rate is measured as the average

(cid:2)(old)( f ∗) + (new)( f ∗)(cid:3), then, for all f ∈ F:
(cid:123)(cid:122)
(cid:125)

(cid:124) (cid:123)(cid:122) (cid:125)
≤ (old)( f )
error on Dold

(cid:125)
(cid:124)
+ dA(Dold,Dnew)

distance

(cid:123)(cid:122)

(cid:124)(cid:123)(cid:122)(cid:125)

(best)

+

minimal avg error

(8.27)

10 Ben-David et al. 2007

bias and fairness

115

error rate on Dnew and Dold; this term ensures that at least some
good classiﬁer exists that does well on both distributions.

The main practical use of this result is that it suggests a way to
look for representations that are good for adaptation: on the one
hand, we should try to get our training error (on Dold) as low as
possible; on the other hand, we want to make sure that it is hard to
distinguish between Dold and Dnew in this representation.

8.6 Further Reading

TODO further reading

9 | PROBABILISTIC MODELING

Learning Objectives:
• Deﬁne the generative story for a

naive Bayes classiﬁer.

• Derive relative frequency as the so-
lution to a constrained optimization
problem.

• Compare and contrast generative,

conditional and discriminative
learning.

• Explain when generative models are

likely to fail.

• Derive logistic loss with an (cid:96)2

regularizer from a probabilistic
perspective.

Dependencies:

The world is noisy and messy. You need to deal with the noise
and uncertainty.

– Daphne Koller

Many of the models and algorithms you have learned about
thus far are relatively disconnected. There is an alternative view of
machine learning that unites and generalizes much of what you have
already learned. This is the probabilistic modeling framework, in
which you will explicitly think of learning as a problem of statistical
inference.

In this chapter, you will learn about two ﬂavors of probabilistic

models: generative and conditional. You will see that many of the ap-
proaches (both supervised and unsupervised) we have seen already
can be cast as probabilistic models. Through this new view, you will
be able to develop learning algorithms that have inductive biases
closer to what you, as a designer, believe. Moreover, the two chap-
ters that follow will make heavy use of the probabilistic modeling
approach to open doors to other learning problems.

9.1 Classiﬁcation by Density Estimation

Recall from Chapter 2 that if we had access to the underlying prob-
ability distribution D, then we could form a Bayes optimal classiﬁer
as:

f (BO)( ˆx) = arg max

ˆy∈Y D( ˆx, ˆy)

(9.1)

Unfortunately, no one gave you this distribution, but the optimality
of this approach suggests that good way to build a classiﬁer is to
try to estimate D. In other words, you try to learn a distribution ˆD,
which you hope to very similar to D, and then use this distribution
for classiﬁcation. Just as in the preceding chapters, you can try to
form your estimate of D based on a ﬁnite training set.

The most direct way that you can attempt to construct such a

probability distribution is to select a family of parametric distribu-
tions. For instance, a Gaussian (or Normal) distribution is parametric:
it’s parameters are its mean and covariance. The job of learning is

probabilistic modeling 117

MATH REVIEW | RULES OF PROBABILITY
A probability distribution p speciﬁes the likelihood of an event e, where p(e) ∈ [0, 1]. It’s often con-
venient to think of events as “conﬁgurations of the world”, so p(e) says “how likely is it that the
world is in conﬁguration e.” Often world conﬁgurations are built up of smaller pieces, for instance you
might say “e = the conﬁguration in which it is rainy, windy and cold.” Formally, we might write this as
“e = {Weather = rainy, Wind = windy, Temperature = cold}”, where we’ve used a convention that
random variables (like Temperature) are capitalized and their instantiations (like cold) are lower case.
Considering this event, we want to evaluate p(Weather = rainy, Wind = windy, Temperature = cold),
or more generally p(A = a, B = b, C = c) for some random variables A, B and C, and some instantia-
tions of those random variables a, b and c respectively.

There are a few standard rules of probability that we will use regularly:

sum-to-one: if you sum over all possible conﬁgurations of the world, p sums to one: ∑e p(E = e) = 1.
marginalization: you can sum out one random variable to remove it from the world: ∑a p(A = a, B =
b) = p(B = b).
chain rule: if a world conﬁguration consists of two or more random variables, you can evaluate the
likelihood of the world one step at a time: p(A = a, B = b) = p(A = a)p(B = b | A = a). Events are
unordered, so you can also get p(A = a, B = b) = p(B = b)p(A = a | B = b).
Bayes rule: combining the two chain rule equalities and dividing, we can relate a conditional proba-
bility in one direction with that in the other direction: p(A = a | B = b) = p(A = a)p(B = b | A =
a)/p(B = b).

Figure 9.1:

then to infer which parameters are “best” as far as the observed train-
ing data is concerned, as well as whatever inductive bias you bring.
A key assumption that you will need to make is that the training data
you have access to is drawn independently from D. In particular, as
you draw examples (x1, y1) ∼ D then (x2, y2) ∼ D and so on, the
nth draw (xn, yn) is drawn from D and does not otherwise depend
on the previous n − 1 samples. This assumption is usually false, but
is also usually sufﬁciently close to being true to be useful. Together
with the assumption that all the training data is drawn from the same
distribution D leads to the i.i.d. assumption or independently and
identically distributed assumption. This is a key assumption in al-
most all of machine learning.

9.2 Statistical Estimation

Suppose you need to model a coin that is possibly biased (you can
think of this as modeling the label in a binary classiﬁcation problem),
and that you observe data HHTH (where H means a ﬂip came up heads

118 a course in machine learning

and T means it came up tails). You can assume that all the ﬂips came
from the same coin, and that each ﬂip was independent (hence, the
data was i.i.d.). Further, you may choose to believe that the coin has
a ﬁxed probability β of coming up heads (and hence 1 − β of coming
up tails). Thus, the parameter of your model is simply the scalar β.

The most basic computation you might perform is maximum like-

lihood estimation: namely, select the paramter β the maximizes the
probability of the data under that parameter. In order to do so, you
need to compute the probability of the data:

pβ(D) = pβ(HHTH)

= pβ(H)pβ(H)pβ(T)pβ(H)
= ββ(1 − β)β
= β3(1 − β)
= β3 − β4

deﬁnition of D
data is independent

(9.2)
(9.3)
(9.4)
(9.5)
(9.6)

?

Describe a case in which at least
one of the assumptions we are
making about the coin ﬂip is false.

Thus, if you want the parameter β that maximizes the probability of
the data, you can take the derivative of β3 − β4 with respect to β, set
it equal to zero and solve for β:

(9.7)

(9.8)
(9.9)
(9.10)

(cid:104)

β3 − β4(cid:105)

∂
∂β

= 3β2 − 4β3
4β3 = 3β2

⇐⇒4β = 3
3
⇐⇒β =
4

Thus, the maximum likelihood β is 0.75, which is probably what
you would have selected by intuition. You can solve this problem
more generally as follows. If you have H-many heads and T-many
tails, the probability of your data sequence is βH(1 − β)T. You can
try to take the derivative of this with respect to β and follow the
same recipe, but all of the products make things difﬁcult. A more
friendly solution is to work with the log likelihood or log proba-
bility instead. The log likelihood of this data sequence is H log β +
T log(1 − β). Differentiating with respect to β, you get H/β − T/(1 −
β). To solve, you obtain H/β = T/(1 − β) so H(1 − β) = Tβ.
Thus H − Hβ = Tβ and so H = (H + T)β, ﬁnally yeilding that
β = H/(H + T) or, simply, the fraction of observed data that came up
heads. In this case, the maximum likelihood estimate is nothing but
the relative frequency of observing heads!

Now, suppose that instead of ﬂipping a coin, you’re rolling a K-

sided die (for instance, to pick the label for a multiclass classiﬁcation
problem). You might model this by saying that there are parameters
θ1, θ2, . . . , θK specifying, respectively, the probabilities that any given

?

How do you know that the solution
of β = H/(H + T) is actually a
maximum?

probabilistic modeling 119

side comes up on a role. Since these are themselves probabilities,
each θk should be at least zero, and the sum of the θks should be one.
Given a data set that consists of x1 rolls of 1, x2 rolls of 2 and so on,
the probability of this data is ∏k θ
∑k xk log θk. If you pick some particular parameter, say θ3, the deriva-
tive of this with respect to θ3 is x3/θ3, which you want to equate to
zero. This leads to. . . θ3 → ∞.

xk
k , yielding a log probability of

This is obviously “wrong.” From the mathematical formulation,
xk
k

it’s correct: in fact, setting all of the θks to ∞ does maximize ∏k θ
for
any (non-negative) xks. The problem is that you need to constrain the
θs to sum to one. In particular, you have a constraint that ∑k θk = 1
that you forgot to enforce. A convenient way to enforce such con-
straints is through the technique of Lagrange multipliers. To make
this problem consistent with standard minimization problems, it is
convenient to minimize negative log probabilities, instead of maxi-
mizing log probabilities. Thus, the constrainted optimization problem
is:

− ∑
k

xk log θk
θk − 1 = 0

min

θ

subj. to ∑
k

(9.11)

The Lagrange multiplier approach involves adding a new variable λ
to the problem (called the Lagrange variable) corresponding to the
constraint, and to use that to move the constraint into the objective.
The result, in this case, is:

(cid:32)

(cid:33)

max

λ

min

θ

xk log θk − λ

− ∑
k

θk − 1

∑
k

(9.12)

Turning a constrained optimization problem into it’s corresponding
Lagrangian is straightforward. The mystical aspect is why it works.
In this case, the idea is as follows. Think of λ as an adversary: λ is
trying to maximize this function (you’re trying to minimize it). If
you pick some parameters θ that actually satisfy the constraint, then
the green term in Eq (9.12) goes to zero, and therefore λ does not
matter: the adversary cannot do anything. On the other hand, if the
constraint is even slightly unsatisﬁed, then λ can tend toward +∞
or −∞ to blow up the objective. So, in order to have a non-inﬁnite
objective value, the optimizer must ﬁnd values of θ that satisfy the
constraint.

If we solve the inner optimization of Eq (9.12) by differentiating

with respect to θ1, we get x1/θ1 = λ, yielding θ1 = x1/λ. In general,
the solution is θk = xk/λ. Remembering that the goal of λ is to
enforce the sums-to-one constraint, we can set λ = ∑k xk and verify

120 a course in machine learning

that this is a solution. Thus, our optimal θk = xk/ ∑k xk, which again
completely corresponds to intuition.

9.3 Naive Bayes Models

Now, consider the binary classiﬁcation problem. You are looking for
a parameterized probability distribution that can describe the training
data you have. To be concrete, your task might be to predict whether
a movie review is positive or negative (label) based on what words
(features) appear in that review. Thus, the probability for a single data
point can be written as:

pθ((y, x)) = pθ(y, x1, x2, . . . , xD)

(9.13)

The challenge in working with a probability distribution like Eq (9.13)
is that it’s a distribution over a lot of variables. You can try to sim-
plify it by applying the chain rule of probabilities:

pθ(x1, x2, . . . , xD, y) = pθ(y)pθ(x1 | y)pθ(x2 | y, x1)pθ(x3 | y, x1, x2)
(9.14)
(9.15)

· · · pθ(xD | y, x1, x2, . . . , xD−1)
pθ(xd | y, x1, . . . , xd−1)

= pθ(y) ∏

d

At this point, this equality is exact for any probability distribution.
However, it might be difﬁcult to craft a probability distribution for
the 10000th feature, given the previous 9999. Even if you could, it
might be difﬁcult to accurately estimate it. At this point, you can
make assumptions. A classic assumption, called the naive Bayes as-
sumption, is that the features are independent, conditioned on the label.
In the movie review example, this is saying that once you know that
it’s a positive review, the probability that the word “excellent” appears
is independent of whether “amazing” also appeared. (Note that
this does not imply that these words are independent when you
don’t know the label—they most certainly are not.) Formally this
assumption states that:

Assumption:

p(xd | y, xd(cid:48) ) = p(xd | y)

,

∀d (cid:54)= d(cid:48)

(9.16)

Under this assumption, you can simplify Eq (9.15) to:

pθ((y, x)) = pθ(y) ∏

d

pθ(xd | y)

naive Bayes assumption

(9.17)

At this point, you can start parameterizing p. Suppose, for now,
that your labels are binary and your features are also binary. In this
case, you could model the label as a biased coin, with probability of
heads (e.g., positive review) given by θ0. Then, for each label, you

probabilistic modeling 121

can imagine having one (biased) coin for each feature. So if there are
D-many features, you’ll have 1 + 2D total coins: one for the label
(call it θ0) and one for each label/feature combination (call these θ+1
and as θ−1). In the movie review example, we might expect θ0 ≈ 0.4
(forty percent of movie reviews are positive) and also that θ+1 might
give high probability to words like “excellent” and “amazing” and
“good” and θ−1 might give high probability to words like “terrible”
and “boring” and “hate”. You can rewrite the probability of a single
example as follows, eventually leading to the log probability of the
entire data set:

pθ((y, x)) = pθ(y) ∏

pθ(xd | y)

(cid:16)

=

[y=+1]
0

θ

d

(1 − θ0)[y=−1](cid:17) ∏

naive Bayes assumption

[xd=1]

(y),d (1 − θ(y),d)[xd=0]

θ

(9.18)

(9.19)

model assumptions

d

Solving for θ0 is identical to solving for the biased coin case from
before: it is just the relative frequency of positive labels in your data
(because θ0 doesn’t depend on x at all). For the other parameters,
you can repeat the same exercise as before for each of the 2D coins
independently. This yields:

ˆθ0 =

ˆθ(+1),d =

ˆθ(−1),d =

∑
n

[yn = +1]

1
N
∑n[yn = +1 ∧ xn,d = 1]
∑n[yn = −1 ∧ xn,d = 1]

∑n[yn = +1]
∑n[yn = −1]

(9.20)

(9.21)

(9.22)

In the case that the features are not binary, you need to choose a dif-
ferent model for p(xd | y). The model we chose here is the Bernouilli
distribution, which is effectively a distribution over independent
coin ﬂips. For other types of data, other distributions become more
appropriate. The die example from before corresponds to a discrete
distribution. If the data is continuous, you might choose to use a
Gaussian distribution (aka Normal distribution). The choice of dis-
tribution is a form of inductive bias by which you can inject your
knowledge of the problem into the learning algorithm.

9.4 Prediction

Consider the predictions made by the naive Bayes model with Bernoulli
features in Eq (9.18). You can better understand this model by con-
sidering its decision boundary. In the case of probabilistic models,

122 a course in machine learning

MATH REVIEW | COMMON PROBABILITY DISTRIBUTIONS
There are a few common probability distributions that we use in this book. The ﬁrst is the Bernouilli
distribution, which models binary outcomes (like coin ﬂips). A Bernouilli distribution, Ber(θ) is pa-
rameterized by a single scalar value θ ∈ [0, 1] that represents the probability of heads. The likelihood
function is Ber(x | θ) = θx(1 − θ)1−x. The generalization of the Bernouilli to more than two possible
outcomes (like rolls of a die) is the Discrete distribution, Disc(th). If the die has K sides, then θ ∈ RK
with all entries non-negative and ∑k θk = 1. θk is the probabability that the die comes up on side k.
The likelihood function is Disc(x | θ) = ∏k θ
. The Binomial distribution is just like the Bernouilli
Bin(k | n,θ)=n
kθk(1−θ)n−k ), where n
distribution but for multiple ﬂips of the rather than a single ﬂip; it’s likelihood is (
is the number of ﬂips and k is the number of heads. The Multinomial distribution extends the Discrete
distribution also to multiple rolls; it’s likelihood is Mult(x | n, θ) =
xk
k , where n is the total
number of rolls and xk is the number of times the die came up on side k (so ∑k xk = n). The preceding
distributions are all discrete.

1[x=k]
k

∏k θ

∏k xk!

n!

There are two common continuous distributions we need. The ﬁrst is the Uniform distribution,
b−a 1[x ∈
Uni(a, b) which is uniform over the closed range [a, b]. It’s density function is Uni(x | a, b) = 1
[a, b]]. Finally, the Gaussian distribution is parameterized by a mean µ and variance σ2 and has density
Nor(x | µ, σ2) = (2πσ2)− 1

(cid:104)− 1
2σ2 (x − µ)2(cid:105)

2 exp

.

the decision boundary is the set of inputs for which the likelihood of
y = +1 is precisely 50%. Or, in other words, the set of inputs x for
which p(y = +1 | x)/p(y = −1 | x) = 1. In order to do this, the
ﬁrst thing to notice is that p(y | x) = p(y, x)/p(x). In the ratio, the
p(x) terms cancel, leaving p(y = +1, x)/p(y = −1, x). Instead of
computing this ratio, it is easier to compute the log-likelihood ratio
(or LLR), log p(y = +1, x) − log p(y = −1, x), computed below:

(cid:34)

θ0 ∏
(cid:34)

d

LLR = log

[xd=1]

(+1),d (1 − θ(+1),d)[xd=0]

θ

− log

(1 − θ0) ∏

[xd=1]

(−1),d (1 − θ(−1),d)[xd=0]

θ

(cid:35)

(cid:35)

(cid:16)

d

(cid:16)

= log θ0 − log(1 − θ0) + ∑

[xd = 1]

log θ(+1),d − log θ(−1),d

+ ∑
d

[xd = 0]

d

log(1 − θ(+1),d) − log(1 − θ(−1),d)

(9.23)

(cid:17)

(cid:17)

= ∑
d

xd log

θ(+1),d
θ(−1),d

+ ∑
d

(1 − xd) log

1 − θ(+1),d
1 − θ(−1),d

(9.24)

+ log

θ0
1 − θ0

(9.25)

Figure 9.2:

model assumptions

take logs and rearrange

simplify log terms

(cid:34)

xd

log

= ∑
d

θ(+1),d
θ(−1),d

− log

1 − θ(+1),d
1 − θ(−1),d

(cid:35)

+ ∑
d

log

1 − θ(+1),d
1 − θ(−1),d

probabilistic modeling 123

+ log

θ0
1 − θ0

group x-terms

= x · w + b

wd = log

θ(+1),d(1 − θ(−1),d)
θ(−1),d(1 − θ(+1),d)

,

b = ∑
d

log

1 − θ(+1),d
1 − θ(−1),d

(9.26)
(9.27)

+ log

θ0
1 − θ0
(9.28)

The result of the algebra is that the naive Bayes model has precisely
the form of a linear model! Thus, like perceptron and many of the
other models you’ve previous studied, the decision boundary is
linear.

9.5 Generative Stories

A useful way to develop probabilistic models is to tell a generative
story. This is a ﬁctional story that explains how you believe your
training data came into existence. To make things interesting, con-
sider a multiclass classiﬁcation problem, with continuous features
modeled by independent Gaussians. Since the label can take values
1 . . . K, you can use a discrete distribution (die roll) to model it (as
opposed to the Bernoilli distribution from before):
1. For each example n = 1 . . . N:
(a) Choose a label yn ∼ Disc(θ)
(b) For each feature d = 1 . . . D:

i. Choose feature value xn,d ∼ Nor(µyn,d, σ2

yn,d)

This generative story can be directly translated into a likelihood
function by replacing the “for each”s with products:

(cid:122)

∏
n

p(D) =

for each example

(cid:34)

(cid:125)(cid:124)

exp

1(cid:113)
(cid:124)

2πσ2

yn,d

θyn(cid:124)(cid:123)(cid:122)(cid:125)

choose label

∏
d

(cid:124)

(xn,d − µyn,d)2

yn,d

− 1
2σ2

(cid:123)(cid:122)
(cid:123)(cid:122)

choose feature value

for each feature

(cid:123)
(cid:35)
(cid:125)
(cid:125)

(cid:34)

You can take logs to arrive at the log-likelihood:

log p(D) = ∑
n

log θyn + ∑

d

− 1
2

log(σ2

yn,d) − 1
2σ2

yn,d

(9.29)

(cid:35)

+ const

(xn,d − µyn,d)2

(9.30)

124 a course in machine learning

To optimize for θ, you need to add a “sums to one” constraint as
before. This leads to the previous solution where the θks are propor-
tional to the number of examples with label k. In the case of the µs
you can take a derivative with respect to, say µk,i and obtain:

∂ log p(D)

∂µk,i

=

∂

∂µk,i

− ∑
n

∑
d

1
2σ2

yn,d

(xn,d − µyn,d)2

=

∂

∂µk,i

− ∑
n:yn=k

1
2σ2
k,d

(xn,i − µk,i)2

= ∑
n:yn=k

1
σ2
k,d

(xn,i − µk,i)

Setting this equal to zero and solving yields:

µk,i =

∑n:yn=k xn,i
∑n:yn=k 1

ignore irrelevant terms

(9.31)

ignore irrelevant terms

(9.32)

take derivative

(9.33)

(9.34)

Namely, the sample mean of the ith feature of the data points that fall
in class k. A similar analysis for σ2

k,i yields:

(cid:35)

∂ log p(D)

∂σ2
k,i

=

∂
∂σ2
k,i

− ∑
y:yn=k

1
2

log(σ2

k,i) +

1
2σ2
k,i

(xn,i − µk,i)2

(cid:34)

(cid:34)

(cid:104)

(cid:35)

(cid:105)

= − ∑
y:yn=k

1
2σ2
k,i

−

1
2(σ2
k,i)2

(xn,i − µk,i)2

=

1
2σ4
k,i

∑
y:yn=k

(xn,i − µk, i)2 − σ2

k,i

ignore irrelevant terms

take derivative

simplify

(9.35)

(9.36)

(9.37)

(9.38)

You can now set this equal to zero and solve, yielding:

σ2
k,i =

∑n:yn=k(xn,i − µk,i)2

∑n:yn=k 1

Which is just the sample variance of feature i for class k.

9.6 Conditional Models

In the foregoing examples, the task was formulated as attempting to
model the joint distribution of (x, y) pairs. This may seem wasteful:
at prediction time, all you care about is p(y | x), so why not model it
directly?

?

What would the estimate be if you
decided that, for a given class k, all
features had equal variance? What
if you assumed feature i had equal
variance for each class? Under what
circumstances might it be a good
idea to make such assumptions?

probabilistic modeling 125

Starting with the case of regression is actually somewhat simpler
than starting with classiﬁcation in this case. Suppose you “believe”
that the relationship between the real value y and the vector x should
be linear. That is, you expect that y = w · x + b should hold for some
parameters (w, b). Of course, the data that you get does not exactly
obey this: that’s ﬁne, you can think of deviations from y = w · x +
b as noise. To form a probabilistic model, you must assume some
distribution over noise; a convenient choice is zero-mean Gaussian
noise. This leads to the following generative story:
1. For each example n = 1 . . . N:
(a) Compute tn = w · xn + b
(b) Choose noise en ∼ Nor(0, σ2)
(c) Return yn = tn + en

In this story, the variable tn stands for “target.” It is the noiseless
variable that you do not get to observe. Similarly en is the error
(noise) on example n. The value that you actually get to observe is
yn = tn + en. See Figure 9.3.
A basic property of the Gaussian distribution is additivity. Namely,
that if a ∼ Nor(µ, σ2) and b = a + c, then b ∼ Nor(µ + c, σ2). Given
this, from the generative story above, you can derive a shorter gener-
ative story:
1. For each example n = 1 . . . N:

(a) Choose yn ∼ Nor(w · xn + b, σ2)

Figure 9.3: pictorial view of targets
versus labels

Reading off the log likelihood of a dataset from this generative story,
you obtain:

(cid:20)

(cid:21)

log p(D) = ∑
n

− 1
2

log(σ2) − 1

2σ2 (w · xn + b − yn)2

= − 1

2σ2 ∑

n

(w · xn + b − yn)2 + const

model assumptions

(9.39)

remove constants

(9.40)

This is precisely the linear regression model you encountered in
Section 7.6! To minimizing the negative log probability, you need only
solve for the regression coefﬁcients w, b as before.

In the case of binary classiﬁcation, using a Gaussian noise model

does not make sense. Switching to a Bernoulli model, which de-
scribes binary outcomes, makes more sense. The only remaining
difﬁculty is that the parameter of a Bernoulli is a value between zero
and one (the probability of “heads”) so your model must produce

126 a course in machine learning

such values. A classic approach is to produce a real-valued target, as
before, and then transform this target into a value between zero and
one, so that −∞ maps to 0 and +∞ maps to 1. A function that does
this is the logistic function1, deﬁned below and plotted in Figure 9.4:

Logistic function: σ(z) =

1

1 + exp[−z]

=

exp z

1 + exp z

(9.41)

The logistic function has several nice properties that you can verify
for yourself: σ(−z) = 1 − σ(z) and ∂σ/∂z = zσ2(z).

Using the logistic function, you can write down a generative story

1 Also called the sigmoid function
because of it’s “S”-shape.

Figure 9.4: sketch of logistic function

for binary classiﬁcation:

1. For each example n = 1 . . . N:

(a) Compute tn = σ (w · xn + b)
(b) Compute zn ∼ Ber(tn)
(c) Return yn = 2zn − 1 (to make it ±1)

The log-likelihood for this model is:
log p(D) = ∑
n

(cid:104)
[yn = +1] log σ (w · xn + b)
+ [yn = −1] log σ (−w · xn + b)

(cid:105)

log σ (yn (w · xn + b))

= ∑
n

= − ∑
n

= − ∑
n

log [1 + exp (−yn (w · xn + b))]

(cid:96)(log)(yn, w · xn + b)

model and properties of σ

(9.42)

join terms

(9.43)
deﬁnition of σ
(9.44)

deﬁnition of (cid:96)(log)

(9.45)

As you can see, the log-likelihood is precisely the negative of (a

scaled version of) the logistic loss from Chapter 7. This model is the
logistic regression model, and this is where logisitic loss originally
derived from.

TODO: conditional versus joint

9.7 Regularization via Priors

In the foregoing discussion, parameters of the model were selected
according to the maximum likelihood criteria: ﬁnd the parameters
θ that maximize pθ(D). The trouble with this approach is easy to

probabilistic modeling 127

see even in a simple coin ﬂipping example. If you ﬂip a coin twice
and it comes up heads both times, the maximum likelihood estimate
for the bias of the coin is 100%: it will always come up heads. This is
true even if you had only ﬂipped it once! If course if you had ﬂipped
it one million times and it had come up heads every time, then you
might ﬁnd this to be a reasonable solution.

This is clearly undesirable behavior, especially since data is expen-
sive in a machine learning setting. One solution (there are others!) is
to seek parameters that balance a tradeoff between the likelihood of
the data and some prior belief you have about what values of those
parameters are likely. Taking the case of the logistic regression, you
might a priori believe that small values of w are more likely than
large values, and choose to represent this as a Gaussian prior on each
component of w.

The maximum a posteriori principle is a method for incoporat-

ing both data and prior beliefs to obtain a more balanced parameter
estimate. In abstract terms, consider a probabilistic model over data
D that is parameterized by parameters θ. If you think of the pa-
rameters as just another random variable, then you can write this
model as p(D | θ), and maximum likelihood amounts to choosing θ
to maximize p(D | θ). However, you might instead with to maximize
the probability of the parameters, given the data. Namely, maximize
p(θ | D). This term is known as the posterior distribution on θ, and
can be computed by Bayes’ rule:

prior
p(θ)

(cid:122)
(cid:122)(cid:125)(cid:124)(cid:123)
(cid:125)(cid:124)
(cid:123)
p(D | θ)
(cid:124)(cid:123)(cid:122)(cid:125)
p(D)

(cid:124)
(cid:123)(cid:122)
(cid:125)
p(θ | D)

posterior

=

likelihood

evidence

(cid:90)

, where

p(D) =

dθp(θ)p(D | θ)

(9.46)

This reads: the posterior is equal to the prior times the likelihood di-
vided by the evidence.2 The evidence is a scary-looking term (it has
an integral!) but note that from the perspective of seeking parameters
θ than maximize the posterior, the evidence is just a constant (it does
not depend on θ) and therefore can be ignored.

Returning to the logistic regression example with Gaussian priors

on the weights, the log posterior looks like:

2 The evidence is sometimes called the
marginal likelihood.

log p(θ | D) = − ∑
n

(cid:96)(log)(yn, w · xn + b) − ∑

d

1
2σ2 w2

d + const

= − ∑
n

(cid:96)(log)(yn, w · xn + b) − 1

2σ2 ||w||2

and therefore reduces to a regularized logistic function, with a

model deﬁnition

(9.47)
(9.48)

128 a course in machine learning

squared 2-norm regularizer on the weights. (A 1-norm regularizer
can be obtained by using a Laplace prior on w rather than a Gaussian
prior on w.)

9.8 Further Reading

TODO

10 | NEURAL NETWORKS

TODO

–

The first learning models you learned about (decision trees
and nearest neighbor models) created complex, non-linear decision
boundaries. We moved from there to the perceptron, perhaps the
most classic linear model. At this point, we will move back to non-
linear learning models, but using all that we have learned about
linear learning thus far.

This chapter presents an extension of perceptron learning to non-
linear decision boundaries, taking the biological inspiration of neu-
rons even further. In the perceptron, we thought of the input data
point (e.g., an image) as being directly connected to an output (e.g.,
label). This is often called a single-layer network because there is one
layer of weights. Now, instead of directly connecting the inputs to
the outputs, we will insert a layer of “hidden” nodes, moving from
a single-layer network to a multi-layer network. But introducing
a non-linearity at inner layers, this will give us non-linear decision
boundaires. In fact, such networks are able to express almost any
function we want, not just linear functions. The trade-off for this ﬂex-
ibility is increased complexity in parameter tuning and model design.

10.1 Bio-inspired Multi-Layer Networks

One of the major weaknesses of linear models, like perceptron and
the regularized linear models from the previous chapter, is that they
are linear! Namely, they are unable to learn arbitrary decision bound-
aries. In contrast, decision trees and KNN could learn arbitrarily
complicated decision boundaries.

One approach to doing this is to chain together a collection of

perceptrons to build more complex neural networks. An example of
a two-layer network is shown in Figure 10.1. Here, you can see ﬁve
inputs (features) that are fed into two hidden units. These hidden
units are then fed in to a single output unit. Each edge in this ﬁgure
corresponds to a different weight. (Even though it looks like there are
three layers, this is called a two-layer network because we don’t count

Learning Objectives:
• Explain the biological inspiration for

multi-layer neural networks.

• Construct a two-layer network that

can solve the XOR problem.

• Implement the back-propogation
algorithm for training multi-layer
networks.

• Explain the trade-off between depth

and breadth in network structure.
• Contrast neural networks with ra-
dial basis functions with k-nearest
neighbor learning.

Dependencies:

Figure 10.1: picture of a two-layer
network with 5 inputs and two hidden
units

130 a course in machine learning

the inputs as a real layer. That is, it’s two layers of trained weights.)
Prediction with a neural network is a straightforward generaliza-
tion of prediction with a perceptron. First you compute activations
of the nodes in the hidden unit based on the inputs and the input
weights. Then you compute activations of the output unit given the
hidden unit activations and the second layer of weights.

The only major difference between this computation and the per-

ceptron computation is that the hidden units compute a non-linear
function of their inputs. This is usually called the activation function
or link function. More formally, if wi,d is the weights on the edge
connecting input d to hidden unit i, then the activation of hidden unit
i is computed as:
hi = f (wi · x)

(10.1)

Where f is the link function and wi refers to the vector of weights
feeding in to node i.
One example link function is the sign function. That is, if the
incoming signal is negative, the activation is −1. Otherwise the
activation is +1. This is a potentially useful activiation function,
but you might already have guessed the problem with it: it is non-
differentiable.

EXPLAIN BIAS!!!
A more popular link function is the hyperbolic tangent function,
tanh. A comparison between the sign function and the tanh function
is in Figure 10.2. As you can see, it is a reasonable approximation
to the sign function, but is convenient in that it is differentiable.1
Because it looks like an “S” and because the Greek character for “S”
is “Sigma,” such functions are usually called sigmoid functions.

Assuming for now that we are using tanh as the link function, the

overall prediction made by a two-layer network can be computed
using Algorithm 10.1. This function takes a matrix of weights W
corresponding to the ﬁrst layer weights and a vector of weights v cor-
responding to the second layer. You can write this entire computation
out in one line as:

vi tanh(wi · ˆx)

ˆy = ∑
i
= v · tanh(Wˆx)

(10.2)

(10.3)

Where the second line is short hand assuming that tanh can take a
vector as input and product a vector as output.

Figure 10.2: picture of sign versus tanh
1 It’s derivative is just 1 − tanh2(x).

?

Is it necessary to use a link function
at all? What would happen if you
just used the identify function as a
link?

neural networks

131

x0

x1

x2
y
+1 +1 +1 +1
+1 +1
-1
-1
-1 +1 +1
-1
-1 +1
-1 +1
Table 10.1: Small XOR data set.

?

Verify that these output weights
will actually give you XOR.

?

This shows how to create an “or”
function. How can you create an
“and” function?

Algorithm 25 TwoLayerNetworkPredict(W, v, ˆx)
1: for i = 1 to number of hidden units do
2:
3: end for
4: return v · h

hi ← tanh(wi · ˆx)

// compute activation of hidden unit i

// compute output unit

The claim is that two-layer neural networks are more expressive

than single layer networks (i.e., perceptrons). To see this, you can
construct a very small two-layer network for solving the XOR prob-
lem. For simplicity, suppose that the data set consists of four data
points, given in Table 10.1. The classiﬁcation rule is that y = +1 if an
only if x1 = x2, where the features are just ±1.

To achieve the “or” behavior, you can start by setting the bias to

You can solve this problem using a two layer network with two
hidden units. The key idea is to make the ﬁrst hidden unit compute
an “or” function: x1 ∨ x2. The second hidden unit can compute an
“and” function: x1 ∧ x2. The the output can combine these into a
single prediction that mimics XOR. Once you have the ﬁrst hidden
unit activate for “or” and the second for “and,” you need only set the
output weights as −2 and +1, respectively.
−0.5 and the weights for the two “real” features as both being 1. You
can check for yourself that this will do the “right thing” if the link
function were the sign function. Of course it’s not, it’s tanh. To get
tanh to mimic sign, you need to make the dot product either really
really large or really really small. You can accomplish this by set-
ting the bias to −500, 000 and both of the two weights to 1, 000, 000.
Now, the activation of this unit will be just slightly above −1 for
x = (cid:104)−1,−1(cid:105) and just slightly below +1 for the other three examples.

At this point you’ve seen that one-layer networks (aka percep-
trons) can represent any linear function and only linear functions.
You’ve also seen that two-layer networks can represent non-linear
functions like XOR. A natural question is: do you get additional
representational power by moving beyond two layers? The answer
is partially provided in the following Theorem, due originally to
George Cybenko for one particular type of link function, and ex-
tended later by Kurt Hornik to arbitrary link functions.

Theorem 10 (Two-Layer Networks are Universal Function Approx-
imators). Let F be a continuous function on a bounded subset of D-
dimensional space. Then there exists a two-layer neural network ˆF with a
ﬁnite number of hidden units that approximate F arbitrarily well. Namely,

for all x in the domain of F,(cid:12)(cid:12)F(x) − ˆF(x)(cid:12)(cid:12) < .

Or, in colloquial terms “two-layer networks can approximate any

132 a course in machine learning

function.”

This is a remarkable theorem. Practically, it says that if you give

me a function F and some error tolerance parameter , I can construct
a two layer network that computes F. In a sense, it says that going
from one layer to two layers completely changes the representational
capacity of your model.

When working with two-layer networks, the key question is: how

many hidden units should I have? If your data is D dimensional
and you have K hidden units, then the total number of parameters
is (D + 2)K. (The ﬁrst +1 is from the bias, the second is from the
second layer of weights.) Following on from the heuristic that you
should have one to two examples for each parameter you are trying
to estimate, this suggests a method for choosing the number of hid-
den units as roughly (cid:98) N
D(cid:99). In other words, if you have tons and tons
of examples, you can safely have lots of hidden units. If you only
have a few examples, you should probably restrict the number of
hidden units in your network.

The number of units is both a form of inductive bias and a form
of regularization. In both view, the number of hidden units controls
how complex your function will be. Lots of hidden units ⇒ very
complicated function. As the number increases, training performance
continues to get better. But at some point, test performance gets
worse because the network has overﬁt the data.

10.2 The Back-propagation Algorithm

The back-propagation algorithm is a classic approach to training
neural networks. Although it was not originally seen this way, based
on what you know from the last chapter, you can summarize back-
propagation as:

back-propagation = gradient descent + chain rule

(10.4)

More speciﬁcally, the set up is exactly the same as before. You are
going to optimize the weights in the network to minimize some ob-
jective function. The only difference is that the predictor is no longer
linear (i.e., ˆy = w · x + b) but now non-linear (i.e., v · tanh(Wˆx)).
The only question is how to do gradient descent on this more compli-
cated objective.

For now, we will ignore the idea of regularization. This is for two
reasons. The ﬁrst is that you already know how to deal with regular-
ization, so everything you’ve learned before applies. The second is
that historically, neural networks have not been regularized. Instead,
people have used early stopping as a method for controlling overﬁt-
ting. Presently, it’s not obvious which is a better solution: both are

valid options.

neural networks

133

To be completely explicit, we will focus on optimizing squared
error. Again, this is mostly for historic reasons. You could easily
replace squared error with your loss function of choice. Our overall
objective is:

(cid:32)

(cid:33)2

min
W,v

∑
n

1
2

yn − ∑

i

vi f (wi · xn)

(10.5)

Here, f is some link function like tanh.

The easy case is to differentiate this with respect to v: the weights

for the output unit. Without even doing any math, you should be
able to guess what this looks like. The way to think about it is that
from vs perspective, it is just a linear model, attempting to minimize
squared error. The only “funny” thing is that its inputs are the activa-
tions h rather than the examples x. So the gradient with respect to v
is just as for the linear case.

To make things notationally more convenient, let en denote the

error on the nth example (i.e., the blue term above), and let hn denote
the vector of hidden unit activations on that example. Then:

∇v = − ∑

n

enhn

(10.6)

This is exactly like the linear case. One way of interpreting this is:
how would the output weights have to change to make the prediction
better? This is an easy question to answer because they can easily
measure how their changes affect the output.

The more complicated aspect to deal with is the weights corre-

sponding to the ﬁrst layer. The reason this is difﬁcult is because the
weights in the ﬁrst layer aren’t necessarily trying to produce speciﬁc
values, say 0 or 5 or −2.1. They are simply trying to produce acti-
vations that get fed to the output layer. So the change they want to
make depends crucially on how the output layer interprets them.

Thankfully, the chain rule of calculus saves us. Ignoring the sum

over data points, we can compute:

(cid:33)2

L(W) =

vi f (wi · x)

(cid:32)

=

1
y − ∑
2
i
∂L
(cid:32)
∂ fi
= −

∂ fi
∂wi
y − ∑
i

= f (cid:48)(wi · x)x

∂L
∂wi
∂L
∂ fi
∂ fi
∂wi

(cid:33)

vi = −evi

vi f (wi · x)

(10.7)

(10.8)

(10.9)

(10.10)

134 a course in machine learning

Algorithm 26 TwoLayerNetworkTrain(D, η, K, MaxIter)
1: W ← D×K matrix of small random values
2: v ← K-vector of small random values
3: for iter = 1 . . . MaxIter do
4: G ← D×K matrix of zeros
g ← K-vector of zeros
for all (x,y) ∈ D do
for i = 1 to K do
ai ← wi · ˆx
hi ← tanh(ai)

5:

6:

9:

// initialize input layer weights
// initialize output layer weights

// initialize input layer gradient
// initialize output layer gradient

7:

8:

10:

11:

12:

13:

14:

15:

16:

end for

17:

18: W ← W − ηG

end for
v ← v − ηg

19:
20: end for
21: return W, v

end for
ˆy ← v · h
e ← y − ˆy
g ← g − eh
for i = 1 to K do

Gi ← Gi − evi(1 − tanh2(ai))x

// compute activation of hidden unit i

// compute output unit
// compute error
// update gradient for output layer

// update gradient for input layer

// update input layer weights
// update output layer weights

Putting this together, we get that the gradient with respect to wi is:

∇wi = −evi f (cid:48)(wi · x)x

(10.11)

Intuitively you can make sense of this. If the overall error of the
predictor (e) is small, you want to make small steps. If vi is small
for hidden unit i, then this means that the output is not particularly
sensitive to the activation of the ith hidden unit. Thus, its gradient
should be small. If vi ﬂips sign, the gradient at wi should also ﬂip
signs. The name back-propagation comes from the fact that you
propagate gradients backward through the network, starting at the
end.

The complete instantiation of gradient descent for a two layer

network with K hidden units is sketched in Algorithm 10.2. Note that
this really is exactly a gradient descent algorithm; the only different is
that the computation of the gradients of the input layer is moderately
complicated.

As a bit of practical advice, implementing the back-propagation

algorithm can be a bit tricky. Sign errors often abound. A useful trick
is ﬁrst to keep W ﬁxed and work on just training v. Then keep v
ﬁxed and work on training W. Then put them together.

?

What would happen to this algo-
rithm if you wanted to optimize
exponential loss instead of squared
error? What if you wanted to add in
weight regularization?

?

If you like matrix calculus, derive
the same algorithm starting from
Eq (10.3).

10.3

Initialization and Convergence of Neural Networks

neural networks

135

Based on what you know about linear models, you might be tempted
to initialize all the weights in a neural network to zero. You might
also have noticed that in Algorithm 10.2, this is not what’s done:
they’re initialized to small random values. The question is why?

The answer is because an initialization of W = 0 and v = 0 will

lead to “uninteresting” solutions. In other words, if you initialize the
model in this way, it will eventually get stuck in a bad local optimum.
To see this, ﬁrst realize that on any example x, the activation hi of the
hidden units will all be zero since W = 0. This means that on the ﬁrst
iteration, the gradient on the output weights (v) will be zero, so they
will stay put. Furthermore, the gradient w1,d for the dth feature on
the ith unit will be exactly the same as the gradient w2,d for the same
feature on the second unit. This means that the weight matrix, after
a gradient step, will change in exactly the same way for every hidden
unit. Thinking through this example for iterations 2 . . . , the values of
the hidden units will always be exactly the same, which means that
the weights feeding in to any of the hidden units will be exactly the
same. Eventually the model will converge, but it will converge to a
solution that does not take advantage of having access to the hidden
units.

This shows that neural networks are sensitive to their initialization.
In particular, the function that they optimize is non-convex, meaning
that it might have plentiful local optima. (One of which is the trivial
local optimum described in the preceding paragraph.) In a sense,
neural networks must have local optima. Suppose you have a two
layer network with two hidden units that’s been optimized. You have
weights w1 from inputs to the ﬁrst hidden unit, weights w2 from in-
puts to the second hidden unit and weights (v1, v2) from the hidden
units to the output. If I give you back another network with w1 and
w2 swapped, and v1 and v2 swapped, the network computes exactly
the same thing, but with a markedly different weight structure. This
phenomena is known as symmetric modes (“mode” referring to an
optima) meaning that there are symmetries in the weight space. It
would be one thing if there were lots of modes and they were all
symmetric: then ﬁnding one of them would be as good as ﬁnding
any other. Unfortunately there are additional local optima that are
not global optima.

Random initialization of the weights of a network is a way to

address both of these problems. By initializing a network with small
random weights (say, uniform between −0.1 and 0.1), the network is
unlikely to fall into the trivial, symmetric local optimum. Moreover,
by training a collection of networks, each with a different random

Figure 10.3: convergence of randomly
initialized networks

136 a course in machine learning

initialization, you can often obtain better solutions that with just
one initialization. In other words, you can train ten networks with
different random seeds, and then pick the one that does best on held-
out data. Figure 10.3 shows prototypical test-set performance for ten
networks with different random initialization, plus an eleventh plot
for the trivial symmetric network initialized with zeros.

One of the typical complaints about neural networks is that they

are ﬁnicky. In particular, they have a rather large number of knobs to
tune:
1. The number of layers
2. The number of hidden units per layer
3. The gradient descent learning rate η
4. The initialization
5. The stopping iteration or weight regularization

The last of these is minor (early stopping is an easy regularization
method that does not require much effort to tune), but the others
are somewhat signiﬁcant. Even for two layer networks, having to
choose the number of hidden units, and then get the learning rate
and initialization “right” can take a bit of work. Clearly it can be
automated, but nonetheless it takes time.

Another difﬁculty of neural networks is that their weights can
be difﬁcult to interpret. You’ve seen that, for linear networks, you
can often interpret high weights as indicative of positive examples
and low weights as indicative of negative examples. In multilayer
networks, it becomes very difﬁcult to try to understand what the
different hidden units are doing.

10.4 Beyond Two Layers

The deﬁnition of neural networks and the back-propagation algo-
rithm can be generalized beyond two layers to any arbitrary directed
acyclic graph. In practice, it is most common to use a layered net-
work like that shown in Figure 10.4 unless one has a very strong
reason (aka inductive bias) to do something different. However, the
view as a directed graph sheds a different sort of insight on the back-
propagation algorithm.

Suppose that your network structure is stored in some directed
acyclic graph, like that in Figure 10.5. We index nodes in this graph
as u, v. The activation before applying non-linearity at a node is au
and after non-linearity is hu. The graph has a single sink, which is
the output node y with activation ay (no non-linearity is performed

Figure 10.4: multi-layer network

Figure 10.5: DAG network

neural networks

137

hu ← corresponding feature of x

Algorithm 27 ForwardPropagation(x)
1: for all input nodes u do
2:
3: end for
4: for all nodes v in the network whose parent’s are computed do
5:

av ← ∑u∈par(v) w(u,v)hu
hv ← tanh(av)

6:
7: end for
8: return ay

Algorithm 28 BackPropagation(x, y)
1: run ForwardPropagation(x) to compute activations
2: ey ← y − ay
3: for all nodes v in the network whose error ev is computed do
4:

for all u ∈ par(v) do

// compute overall network error

5:

6:

gu,v ← −evhu
// compute gradient of this edge
eu ← eu + evwu,v(1 − tanh2(au)) // compute the “error” of the parent node

end for

7:
8: end for
9: return all gradients ge

on the output unit). The graph has D-many inputs (i.e., nodes with
no parent), whose activations hu are given by an input example. An
edge (u, v) is from a parent to a child (i.e., from an input to a hidden
unit, or from a hidden unit to the sink). Each edge has a weight wu,v.
We say that par(u) is the set of parents of u.

There are two relevant algorithms: forward-propagation and back-

propagation. Forward-propagation tells you how to compute the
activation of the sink y given the inputs. Back-propagation computes
derivatives of the edge weights for a given input.

The key aspect of the forward-propagation algorithm is to iter-
atively compute activations, going deeper and deeper in the DAG.
Once the activations of all the parents of a node u have been com-
puted, you can compute the activation of node u. This is spelled out
in Algorithm 10.4. This is also explained pictorially in Figure 10.6.
Back-propagation (see Algorithm 10.4) does the opposite: it com-

putes gradients top-down in the network. The key idea is to compute
an error for each node in the network. The error at the output unit is
the “true error.” For any input unit, the error is the amount of gradi-
ent that we see coming from our children (i.e., higher in the network).
These errors are computed backwards in the network (hence the
name back-propagation) along with the gradients themselves. This is
also explained pictorially in Figure 10.7.

Given the back-propagation algorithm, you can directly run gradi-

ent descent, using it as a subroutine for computing the gradients.

Figure 10.6: picture of forward prop

Figure 10.7: picture of back prop

138 a course in machine learning

10.5 Breadth versus Depth

At this point, you’ve seen how to train two-layer networks and how
to train arbitrary networks. You’ve also seen a theorem that says
that two-layer networks are universal function approximators. This
begs the question: if two-layer networks are so great, why do we care
about deeper networks?

To understand the answer, we can borrow some ideas from CS
theory, namely the idea of circuit complexity. The goal is to show
that there are functions for which it might be a “good idea” to use a
deep network. In other words, there are functions that will require a
huge number of hidden units if you force the network to be shallow,
but can be done in a small number of units if you allow it to be deep.
The example that we’ll use is the parity function which, ironically
enough, is just a generalization of the XOR problem. The function is
deﬁned over binary inputs as:

xd mod 2

(10.12)

parity(x) = ∑
d

(cid:40)

=

1 if the number of 1s in x is odd
0 if the number of 1s in x is even

(10.13)
It is easy to deﬁne a circuit of depth O(log2 D) with O(D)-many
gates for computing the parity function. Each gate is an XOR, ar-
ranged in a complete binary tree, as shown in Figure 10.8. (If you
want to disallow XOR as a gate, you can ﬁx this by allowing the
depth to be doubled and replacing each XOR with an AND, OR and
NOT combination, like you did at the beginning of this chapter.)

This shows that if you are allowed to be deep, you can construct a
circuit with that computes parity using a number of hidden units that
is linear in the dimensionality. So can you do the same with shallow
circuits? The answer is no. It’s a famous result of circuit complexity
that parity requires exponentially many gates to compute in constant
depth. The formal theorem is below:
Theorem 11 (Parity Function Complexity). Any circuit of depth K <
log2 D that computes the parity function of D input bits must contain OeD
gates.

This is a very famous result because it shows that constant-depth
circuits are less powerful that deep circuits. Although a neural net-
work isn’t exactly the same as a circuit, the is generally believed that
the same result holds for neural networks. At the very least, this
gives a strong indication that depth might be an important considera-
tion in neural networks.

One way of thinking about the issue of breadth versus depth has

to do with the number of parameters that need to be estimated. By

Figure 10.8: nnet:paritydeep: deep
function for computing parity

?

What is it about neural networks
that makes it so that the theorem
about circuits does not apply di-
rectly?

neural networks

139

?

While these small derivatives might
make training difﬁcult, they might
be good for other reasons: what
reasons?

the heuristic that you need roughly one or two examples for every
parameter, a deep model could potentially require exponentially
fewer examples to train than a shallow model!

This now ﬂips the question: if deep is potentially so much better,

why doesn’t everyone use deep networks? There are at least two
answers. First, it makes the architecture selection problem more
signiﬁcant. Namely, when you use a two-layer network, the only
hyperparameter to choose is how many hidden units should go in
the middle layer. When you choose a deep network, you need to
choose how many layers, and what is the width of all those layers.
This can be somewhat daunting.

A second issue has to do with training deep models with back-
propagation. In general, as back-propagation works its way down
through the model, the sizes of the gradients shrink. You can work
this out mathematically, but the intuition is simpler. If you are the
beginning of a very deep network, changing one single weight is
unlikely to have a signiﬁcant effect on the output, since it has to
go through so many other units before getting there. This directly
implies that the derivatives are small. This, in turn, means that back-
propagation essentially never moves far from its initialization when
run on very deep networks.

Finding good ways to train deep networks is an active research
area. There are two general strategies. The ﬁrst is to attempt to ini-
tialize the weights better, often by a layer-wise initialization strategy.
This can be often done using unlabeled data. After this initializa-
tion, back-propagation can be run to tweak the weights for whatever
classiﬁcation problem you care about. A second approach is to use a
more complex optimization procedure, rather than gradient descent.
You will learn about some such procedures later in this book.

10.6 Basis Functions

At this point, we’ve seen that: (a) neural networks can mimic linear
functions and (b) they can learn more complex functions. A rea-
sonable question is whether they can mimic a KNN classiﬁer, and
whether they can do it efﬁciently (i.e., with not-too-many hidden
units).

A natural way to train a neural network to mimic a KNN classiﬁer

is to replace the sigmoid link function with a radial basis function
(RBF). In a sigmoid network (i.e., a network with sigmoid links),
the hidden units were computed as hi = tanh(wi, x·). In an RBF
network, the hidden units are computed as:

(10.14)

(cid:104)−γi ||wi − x||2(cid:105)

hi = exp

140 a course in machine learning

In other words, the hidden units behave like little Gaussian “bumps”

centered around locations speciﬁed by the vectors wi. A one-dimensional
example is shown in Figure 10.9. The parameter γi speciﬁes the width
of the Gaussian bump. If γi is large, then only data points that are
really close to wi have non-zero activations. To distinguish sigmoid
networks from RBF networks, the hidden units are typically drawn
with sigmoids or with Gaussian bumps, as in Figure 10.10.

Training RBF networks involves ﬁnding good values for the Gas-
sian widths, γi, the centers of the Gaussian bumps, wi and the con-
nections between the Gaussian bumps and the output unit, v. This
can all be done using back-propagation. The gradient terms for v re-
main unchanged from before, the the derivates for the other variables
differ (see Exercise ??).

One of the big questions with RBF networks is: where should

the Gaussian bumps be centered? One can, of course, apply back-
propagation to attempt to ﬁnd the centers. Another option is to spec-
ify them ahead of time. For instance, one potential approach is to
have one RBF unit per data point, centered on that data point. If you
carefully choose the γs and vs, you can obtain something that looks
nearly identical to distance-weighted KNN by doing so. This has the
added advantage that you can go futher, and use back-propagation
to learn good Gaussian widths (γ) and “voting” factors (v) for the
nearest neighbor algorithm.

10.7 Further Reading

TODO further reading

Figure 10.9: nnet:rbfpicture: a one-D
picture of RBF bumps

Figure 10.10: nnet:unitsymbols: picture
of nnet with sigmoid/rbf units

?

Consider an RBF network with
one hidden unit per training point,
centered at that point. What bad
thing might happen if you use back-
propagation to estimate the γs and
v on this data if you’re not careful?
How could you be careful?

11 | KERNEL METHODS

Learning Objectives:
• Explain how kernels generalize

both feature combinations and basis
functions.

• Contrast dot products with kernel

products.

• Implement kernelized perceptron.
• Derive a kernelized version of

regularized least squares regression.

• Implement a kernelized version of

the perceptron.

• Derive the dual formulation of the

support vector machine.

Dependencies:

Many who have had an opportunity of knowing any more about
mathematics confuse it with arithmetic, and consider it an arid
science. In reality, however, it is a science which requires a great
amount of imagination.

– Soﬁa Kovalevskaya

Linear models are great because they are easy to understand
and easy to optimize. They suffer because they can only learn very
simple decision boundaries. Neural networks can learn more com-
plex decision boundaries, but lose the nice convexity properties of
many linear models.

One way of getting a linear model to behave non-linearly is to

transform the input. For instance, by adding feature pairs as addi-
tional inputs. Learning a linear model on such a representation is
convex, but is computationally prohibitive in all but very low dimen-
sional spaces. You might ask: instead of explicitly expanding the fea-
ture space, is it possible to stay with our original data representation
and do all the feature blow up implicitly? Surprisingly, the answer is
often “yes” and the family of techniques that makes this possible are
known as kernel approaches.

11.1 From Feature Combinations to Kernels

In Section 5.4, you learned one method for increasing the expressive
power of linear models: explode the feature space. For instance,
a “quadratic” feature explosion might map a feature vector x =
(cid:104)x1, x2, x3, . . . , xD(cid:105) to an expanded version denoted φ(x):

φ(x) = (cid:104)1, 2x1, 2x2, 2x3, . . . , 2xD,
x2
1, x1x2, x1x3, . . . , x1xD,
x2x1, x2
2, x2x3, . . . , x2xD,
x3x1, x3x2, x2
3, . . . , x2xD,
. . . ,
D(cid:105)
xDx1, xDx2, xDx3, . . . , x2

(11.1)

(Note that there are repetitions here, but hopefully most learning
algorithms can deal well with redundant features; in particular, the
2x1 terms are due to collapsing some repetitions.)

142 a course in machine learning

You could then train a classiﬁer on this expanded feature space.
There are two primary concerns in doing so. The ﬁrst is computa-
tional: if your learning algorithm scales linearly in the number of fea-
tures, then you’ve just squared the amount of computation you need
to perform; you’ve also squared the amount of memory you’ll need.
The second is statistical: if you go by the heuristic that you should
have about two examples for every feature, then you will now need
quadratically many training examples in order to avoid overﬁtting.
This chapter is all about dealing with the computational issue. It

will turn out in Chapter 12 that you can also deal with the statistical
issue: for now, you can just hope that regularization will be sufﬁcient
to attenuate overﬁtting.

The key insight in kernel-based learning is that you can rewrite
many linear models in a way that doesn’t require you to ever ex-
plicitly compute φ(x). To start with, you can think of this purely
as a computational “trick” that enables you to use the power of a
quadratic feature mapping without actually having to compute and
store the mapped vectors. Later, you will see that it’s actually quite a
bit deeper. Most algorithms we discuss involve a product of the form
w · φ(x), after performing the feature mapping. The goal is to rewrite
these algorithms so that they only ever depend on dot products be-
tween two examples, say x and z; namely, they depend on φ(x) · φ(z).
To understand why this is helpful, consider the quadratic expansion
from above, and the dot-product between two vectors. You get:

φ(x) · φ(z) = 1 + x1z1 + x2z2 + · · · + xDzD + x2
1 + · · · + x1xDz1zD+
1z2
· · · + xDx1zDz1 + xDx2zDz2 + · · · + x2
(11.2)
Dz2
D
= 1 + 2 ∑
xdzd + ∑
∑
(11.3)
e
d
d
= 1 + 2x · z + (x · z)2
= (1 + x · z)2

(11.4)
(11.5)

xdxezdze

Thus, you can compute φ(x) · φ(z) in exactly the same amount of
time as you can compute x · z (plus the time it takes to perform an
addition and a multiply, about 0.02 nanoseconds on a circa 2011
processor).

The rest of the practical challenge is to rewrite your algorithms so
that they only depend on dot products between examples and not on
any explicit weight vectors.

11.2 Kernelized Perceptron

Consider the original perceptron algorithm from Chapter 4, re-

peated in Algorithm 11.2 using linear algebra notation and using fea-
ture expansion notation φ(x). In this algorithm, there are two places

kernel methods

143

// initialize weights and bias

Algorithm 29 PerceptronTrain(D, MaxIter)
1: w ← 0, b ← 0
2: for iter = 1 . . . MaxIter do
3:

// compute activation for this example

// update weights
// update bias

for all (x,y) ∈ D do
a ← w · φ(x) + b
if ya ≤ 0 then
w ← w + y φ(x)
b ← b + y

4:

5:

6:

7:

8:

end if
end for

9:
10: end for
11: return w, b

MATH REVIEW | SPANS
If U = {ui}I
linear combinations of uis; namely: span(U ) = {∑i aiui
linearly independent, then the dimension of span(U ) is I; in particular, if there are D-many linearly
independent vectors then they span RD.

i=1 is a set of vectors in RD, then the span of U is the set of vectors that can be written as
: a1 ∈ R, . . . , aI ∈ R}. If all of the uis are

Figure 11.1:

where φ(x) is used explicitly. The ﬁrst is in computing the activation
(line 4) and the second is in updating the weights (line 6). The goal is
to remove the explicit dependence of this algorithm on φ and on the
weight vector.

To do so, you can observe that at any point in the algorithm, the
weight vector w can be written as a linear combination of expanded
training data. In particular, at any point, w = ∑n αnφ(xn) for some
parameters α. Initially, w = 0 so choosing α = 0 yields this. If the
ﬁrst update occurs on the nth training example, then the resolution
weight vector is simply ynφ(xn), which is equivalent to setting αn =
yn. If the second update occurs on the mth training example, then all
you need to do is update αm ← αm + ym. This is true, even if you
make multiple passes over the data. This observation leads to the
following representer theorem, which states that the weight vector of
the perceptron lies in the span of the training data.

Theorem 12 (Perceptron Representer Theorem). During a run of
the perceptron algorithm, the weight vector w is always in the span of the
(assumed non-empty) training data, φ(x1), . . . , φ(xN).
Proof of Theorem 12. By induction. Base case: the span of any non-
empty set contains the zero vector, which is the initial weight vec-
tor. Inductive case: suppose that the theorem is true before the kth
update, and suppose that the kth update happens on example n.
By the inductive hypothesis, you can write w = ∑i αiφ(xi) before

144 a course in machine learning

Algorithm 30 KernelizedPerceptronTrain(D, MaxIter)
1: α ← 0, b ← 0
2: for iter = 1 . . . MaxIter do
for all (xn,yn) ∈ D do
3:

// initialize coefﬁcients and bias

a ← ∑m αmφ(xm) · φ(xn) + b
if yna ≤ 0 then
αn ← αn + yn
b ← b + y

// compute activation for this example

// update coefﬁcients
// update bias

4:

5:

6:

7:

8:

end if
end for

9:
10: end for
11: return α, b

the update. The new weight vector is [∑i αiφ(xi)] + ynφ(xn) =
∑i(αi + yn[i = n])φ(xi), which is still in the span of the training
data.

Now that you know that you can always write w = ∑n αnφ(xn) for

some αis, you can additionall compute the activations (line 4) as:

(cid:32)

(cid:33)

w · φ(x) + b =

∑
n

αnφ(xn)

· φ(x) + b
(cid:105)

+ b

(cid:104)

= ∑
n

αn

φ(xn) · φ(x)

deﬁnition of w

(11.6)

dot products are linear

(11.7)

This now depends only on dot-products between data points, and
never explicitly requires a weight vector. You can now rewrite the
entire perceptron algorithm so that it never refers explicitly to the
weights and only ever depends on pairwise dot products between
examples. This is shown in Algorithm 11.2.

The advantage to this “kernelized” algorithm is that you can per-

form feature expansions like the quadratic feature expansion from
the introduction for “free.” For example, for exactly the same cost as
the quadratic features, you can use a cubic feature map, computed
¨φ(x)φ(z) = (1 + x · z)3, which corresponds to three-way inter-
as
actions between variables. (And, in general, you can do so for any
polynomial degree p at the same computational complexity.)

11.3 Kernelized K-means

For a complete change of pace, consider the K-means algorithm from
Section 3. This algorithm is for clustering where there is no notion of
“training labels.” Instead, you want to partition the data into coher-
ent clusters. For data in RD, it involves randomly initializing K-many

kernel methods

145

cluster means µ(1), . . . , µ(K). The algorithm then alternates between the
following two steps until convergence, with x replaced by φ(x) since
that is the eventual goal:

1. For each example n, set cluster label zn = arg mink
2. For each cluster k, update µ(k) = 1
Nk

∑n:zn=k φ(xn), where Nk is the

number of n with zn = k.

(cid:12)(cid:12)(cid:12)(cid:12)φ(xn) − µ(k)(cid:12)(cid:12)(cid:12)(cid:12)2.

The question is whether you can perform these steps without ex-
plicitly computing φ(xn). The representer theorem is more straight-
forward here than in the perceptron. The mean of a set of data is,
almost by deﬁnition, in the span of that data (choose the ais all to be
equal to 1/N). Thus, so long as you initialize the means in the span
of the data, you are guaranteed always to have the means in the span
of the data. Given this, you know that you can write each mean as an
(k)
expansion of the data; say that µ(k) = ∑n α
n φ(xn) for some parame-
ters α

n (there are N×K-many such parameters).

Given this expansion, in order to execute step (1), you need to

(k)

compute norms. This can be done as follows:

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)φ(xn) − µ(k)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)φ(xn) − ∑
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

||φ(xn)||2 +

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)∑

m

m

α

zn = arg min

k

= arg min

k

= arg min

k

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2

(k)
m φ(xm)

(cid:34)

+ φ(xn) ·

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2

(11.9)

(cid:35)

(k)
m φ(xm)

α

∑
m

(k)
m φ(xm)

α

(11.8)

deﬁnition of zn

deﬁnition of µ(k)

expand quadratic term

linearity and constant

k

α

(k)

(k)
m α

∑
m

∑
m(cid:48)

= arg min

m(cid:48) φ(xm) · φ(xm(cid:48) ) + ∑

(11.10)
m φ(xm) · φ(xn) + const
(11.11)
This computation can replace the assignments in step (1) of K-means.
The mean updates are more direct in step (2):

(k)

m

α

(cid:40) 1

Nk
0

if zn = k
otherwise

(11.12)

µ(k) =

1
Nk

∑
n:zn=k

φ(xn) ⇐⇒ α

(k)
n =

11.4 What Makes a Kernel

A kernel is just a form of generalized dot product. You can also
think of it as simply shorthand for φ(x) · φ(z), which is commonly
written Kφ(x, z). Or, when φ is clear from context, simply K(x, z).

146 a course in machine learning

This is often refered to as the kernel product between x and z (under
the mapping φ).

In this view, what you’ve seen in the preceding two sections is

that you can rewrite both the perceptron algorithm and the K-means
algorithm so that they only ever depend on kernel products between data
points, and never on the actual datapoints themselves. This is a very pow-
erful notion, as it has enabled the development of a large number of
non-linear algorithms essentially “for free” (by applying the so-called
kernel trick, that you’ve just seen twice).

This raises an interesting question. If you have rewritten these
algorithms so that they only depend on the data through a function
K : X×X → R, can you stick any function K in these algorithms,
or are there some K that are “forbidden?” In one sense, you “could”
use any K, but the real question is: for what types of functions K do
these algorithms retain the properties that we expect them to have
(like convergence, optimality, etc.)?
One way to answer this question is to say that K(·,·) is a valid
kernel if it corresponds to the inner product between two vectors.
That is, K is valid if there exists a function φ such that K(x, z) =
φ(x) · φ(z). This is a direct deﬁnition and it should be clear that if K
satisﬁes this, then the algorithms go through as expected (because
this is how we derived them).

You’ve already seen the general class of polynomial kernels,

which have the form:

K(poly)
d

(x, z) =

1 + x · z

(cid:16)

(cid:17)d

(11.13)

where d is a hyperparameter of the kernel. These kernels correspond
to polynomial feature expansions.
There is an alternative characterization of a valid kernel function
that is more mathematical. It states that K : X×X → R is a kernel if
K is positive semi-definite (or, in shorthand, psd). This property is
also sometimes called Mercer’s condition. In this context, this means

the for all functions f that are square integrable (i.e.,(cid:82) f (x)2dx < ∞),
(cid:90)(cid:90)

other than the zero function, the following property holds:

f (x)K(x, z) f (z)dxdz > 0

(11.14)

This likely seems like it came out of nowhere. Unfortunately, the
connection is well beyond the scope of this book, but is covered well
is external sources. For now, simply take it as a given that this is an
equivalent requirement. (For those so inclined, the appendix of this
book gives a proof, but it requires a bit of knowledge of function
spaces to understand.)

The question is: why is this alternative characterization useful? It
is useful because it gives you an alternative way to construct kernel

functions. For instance, using it you can easily prove the following,
which would be difﬁcult from the deﬁnition of kernels as inner prod-
ucts after feature mappings.

Theorem 13 (Kernel Addition). If K1 and K2 are kernels, the K deﬁned
by K(x, z) = K1(x, z) + K2(x, z) is also a kernel.
Proof of Theorem 13. You need to verify the positive semi-deﬁnite
property on K. You can do this as follows:

(cid:90)(cid:90)

f (x)K(x, z) f (z)dxdz =

=

f (x) [K1(x, z) + K2(x, z)] f (z)dxdz
(11.15)

f (x)K1(x, z) f (z)dxdz

kernel methods

147

deﬁnition of K

(cid:90)(cid:90)
(cid:90)(cid:90)
(cid:90)(cid:90)

+

f (x)K2(x, z) f (z)dxdz

distributive rule

(11.16)

(11.17)

K1 and K2 are psd

> 0 + 0

More generally, any positive linear combination of kernels is still a
kernel. Speciﬁcally, if K1, . . . , KM are all kernels, and α1, . . . , αM ≥ 0,
then K(x, z) = ∑m αmKm(x, z) is also a kernel.

You can also use this property to show that the following Gaus-

sian kernel (also called the RBF kernel) is also psd:

(cid:104)−γ ||x − z||2(cid:105)

K(RBF)
γ

(x, z) = exp

(11.18)

Here γ is a hyperparameter that controls the width of this Gaussian-
like bumps. To gain an intuition for what the RBF kernel is doing,
consider what prediction looks like in the perceptron:

f (x) = ∑
n
= ∑
n

αnK(xn, x) + b

(cid:104)−γ ||xn − z||2(cid:105)

αn exp

(11.19)

(11.20)

In this computation, each training example is getting to “vote” on the
label of the test point x. The amount of “vote” that the nth training
example gets is proportional to the negative exponential of the dis-
tance between the test point and itself. This is very much like an RBF
neural network, in which there is a Gaussian “bump” at each training
example, with variance 1/(2γ), and where the αns act as the weights
connecting these RBF bumps to the output.

Showing that this kernel is positive deﬁnite is a bit of an exercise

in analysis (particularly, integration by parts), but otherwise not
difﬁcult. Again, the proof is provided in the appendix.

148 a course in machine learning

So far, you have seen two bsaic classes of kernels: polynomial
kernels (K(x, z) = (1 + x · z)d), which includes the linear kernel
(K(x, z) = x · z) and RBF kernels (K(x, z) = exp[−γ ||x − z||2]). The
former have a direct connection to feature expansion; the latter to
RBF networks. You also know how to combine kernels to get new
kernels by addition. In fact, you can do more than that: the product
of two kernels is also a kernel.

As far as a “library of kernels” goes, there are many. Polynomial
and RBF are by far the most popular. A commonly used, but techni-
cally invalid kernel, is the hyperbolic-tangent kernel, which mimics
the behavior of a two-layer neural network. It is deﬁned as:

K(tanh) = tanh(1 + x · z)

Warning: not psd

(11.21)

A ﬁnal example, which is not very common, but is nonetheless
interesting, is the all-subsets kernel. Suppose that your D features
are all binary: all take values 0 or 1. Let A ⊆ {1, 2, . . . D} be a subset

of features, and let fA(x) = (cid:86)

d∈A xd be the conjunction of all the
features in A. Let φ(x) be a feature vector over all such As, so that
there are 2D features in the vector φ. You can compute the kernel
associated with this feature mapping as:

(cid:16)

(cid:17)

K(subs)(x, z) = ∏
d

1 + xdzd

(11.22)

Verifying the relationship between this kernel and the all-subsets
feature mapping is left as an exercise (but closely resembles the ex-
pansion for the quadratic kernel).

11.5 Support Vector Machines

Kernelization predated support vector machines, but SVMs are def-
initely the model that popularized the idea. Recall the deﬁnition of
the soft-margin SVM from Chapter 7.7 and in particular the opti-
mization problem (7.38), which attempts to balance a large margin
(small ||w||2) with a small loss (small ξns, where ξn is the slack on
the nth training example). This problem is repeated below:

ξn

(11.23)

min
w,b,ξ

1
2

||w||2 + C ∑
n

subj. to yn (w · xn + b) ≥ 1 − ξn

ξn ≥ 0

(∀n)
(∀n)

Previously, you optimized this by explicitly computing the slack
variables ξn, given a solution to the decision boundary, w and b.
However, you are now an expert with using Lagrange multipliers

kernel methods

149

to optimize constrained problems! The overall goal is going to be to
rewrite the SVM optimization problem in a way that it no longer ex-
plicitly depends on the weights w and only depends on the examples
xn through kernel products.

There are 2N constraints in this optimization, one for each slack

constraint and one for the requirement that the slacks are non-
negative. Unlike the last time, these constraints are now inequalities,
which require a slightly different solution. First, you rewrite all the
inequalities so that they read as something ≥ 0 and then add cor-
responding Lagrange multipliers. The main difference is that the
Lagrange multipliers are now constrained to be non-negative, and
their sign in the augmented objective function matters.
The second set of constraints is already in the proper form; the
ﬁrst set can be rewritten as yn (w · xn + b) − 1 + ξn ≥ 0. You’re now
ready to construct the Lagrangian, using multipliers αn for the ﬁrst
set of constraints and βn for the second set.

L(w, b, ξ, α, β) =

1
2

ξn − ∑

βnξn

||w||2 + C ∑
n
− ∑
n

n

αn [yn (w · xn + b) − 1 + ξn]

The new optimization problem is:

min
w,b,ξ

max
α≥0

max
β≥0

L(w, b, ξ, α, β)

(11.24)

(11.25)

(11.26)

The intuition is exactly the same as before. If you are able to ﬁnd a
solution that satisﬁes the constraints (e.g., the purple term is prop-
erly non-negative), then the βns cannot do anything to “hurt” the
solution. On the other hand, if the purple term is negative, then the
corresponding βn can go to +∞, breaking the solution.

You can solve this problem by taking gradients. This is a bit te-

dious, but and important step to realize how everything ﬁts together.
Since your goal is to remove the dependence on w, the ﬁrst step is to
take a gradient with respect to w, set it equal to zero, and solve for w
in terms of the other variables.

∇wL = w − ∑

n

αnynxn = 0 ⇐⇒ w = ∑

n

αnynxn

(11.27)

At this point, you should immediately recognize a similarity to the
kernelized perceptron: the optimal weight vector takes exactly the
same form in both algorithms.
You can now take this new expression for w and plug it back in to
the expression for L, thus removing w from consideration. To avoid
subscript overloading, you should replace the n in the expression for

150 a course in machine learning

w with, say, m. This yields:

L(b, ξ, α, β) =

1
2

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)∑

m
− ∑
n

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
(cid:32)(cid:34)

∑
m

αmymxm

(cid:34)

+ C ∑
n

ξn − ∑
(cid:35)

n

βnξn

(cid:33)

αn

yn

αmymxm

· xn + b

− 1 + ξn

(11.28)

(cid:35)

(11.29)

(11.31)
(11.32)

(11.33)

At this point, it’s convenient to rewrite these terms; be sure you un-
derstand where the following comes from:

L(b, ξ, α, β) =

1
2

∑
∑
n
m
− ∑
n

αnαmynymxn · xm + ∑
αnαmynymxn · xm − ∑
∑
m

n

n

(C − βn)ξn

(11.30)

αn (ynb − 1 + ξn)

= − 1
αnαmynymxn · xm + ∑
∑
∑
2
n
m
−b ∑
αnyn − ∑
n

αn(ξn − 1)

n

n

(C − βn)ξn

Things are starting to look good: you’ve successfully removed the de-
pendence on w, and everything is now written in terms of dot prod-
ucts between input vectors! This might still be a difﬁcult problem to
solve, so you need to continue and attempt to remove the remaining
variables b and ξ.

The derivative with respect to b is:
∂L
∂b

= − ∑
n

αnyn = 0

(11.34)

This doesn’t allow you to substitute b with something (as you did
with w), but it does mean that the fourth term (b ∑n αnyn) goes to
zero at the optimum.

The last of the original variables is ξn; the derivatives in this case

look like:

∂L
∂ξn

= C − βn − αn ⇐⇒ C − βn = αn

(11.35)

Again, this doesn’t allow you to substitute, but it does mean that you
can rewrite the second term, which as ∑n(C − βn)ξn as ∑n αnξn. This
then cancels with (most of) the ﬁnal term. However, you need to be
careful to remember something. When we optimize, both αn and βn
are constrained to be non-negative. What this means is that since we
are dropping β from the optimization, we need to ensure that αn ≤ C,
otherwise the corresponding β will need to be negative, which is not

kernel methods

151

allowed. You ﬁnally wind up with the following, where xn · xm has
been replaced by K(xn, xm):

L(α) = ∑
n

αn − 1
2

∑
n

∑
m

αnαmynymK(xn, xm)

(11.36)

If you are comfortable with matrix notation, this has a very compact
form. Let 1 denote the N-dimensional vector of all 1s, let y denote
the vector of labels and let G be the N×N matrix, where Gn,m =
ynymK(xn, xm), then this has the following form:

(cid:62)1 − 1
2 α

(cid:62)Gα

L(α) = α

(11.37)
The resulting optimization problem is to maximize L(α) as a function
of α, subject to the constraint that the αns are all non-negative and
less than C (because of the constraint added when removing the β
variables). Thus, your problem is:

min

1
− L(α) =
2
subj. to 0 ≤ αn ≤ C

α

∑
n

∑
m

αnαmynymK(xn, xm) − ∑

n

αn

(11.38)
(∀n)

One way to solve this problem is gradient descent on α. The only
complication is making sure that the αs satisfy the constraints. In
this case, you can use a projected gradient algorithm: after each
gradient update, you adjust your parameters to satisfy the constraints
by projecting them into the feasible region. In this case, the projection
is trivial: if, after a gradient step, any αn < 0, simply set it to 0; if any
αn > C, set it to C.

11.6 Understanding Support Vector Machines

The prior discussion involved quite a bit of math to derive a repre-
sentation of the support vector machine in terms of the Lagrange
variables. This mapping is actually sufﬁciently standard that every-
thing in it has a name. The original problem variables (w, b, ξ) are
called the primal variables; the Lagrange variables are called the
dual variables. The optimization problem that results after removing
all of the primal variables is called the dual problem.

A succinct way of saying what you’ve done is: you found that after

converting the SVM into its dual, it is possible to kernelize.

To understand SVMs, a ﬁrst step is to peek into the dual formula-
tion, Eq (11.38). The objective has two terms: the ﬁrst depends on the
data, and the second depends only on the dual variables. The ﬁrst
thing to notice is that, because of the second term, the αs “want” to

152 a course in machine learning

get as large as possible. The constraint ensures that they cannot ex-
ceed C, which means that the general tendency is for the αs to grow
as close to C as possible.

To further understand the dual optimization problem, it is useful

to think of the kernel as being a measure of similarity between two
data points. This analogy is most clear in the case of RBF kernels,
but even in the case of linear kernels, if your examples all have unit
norm, then their dot product is still a measure of similarity. Since you
can write the prediction function as f (ˆx) = sign(∑n αnynK(xn, ˆx)), it
is natural to think of αn as the “importance” of training example n,
where αn = 0 means that it is not used at all at test time.

Consider two data points that have the same label; namely, yn =

ym. This means that ynym = +1 and the objective function has a term
that looks like αnαmK(xn, xm). Since the goal is to make this term
small, then one of two things has to happen: either K has to be small,
or αnαm has to be small. If K is already small, then this doesn’t affect
the setting of the corresponding αs. But if K is large, then this strongly
encourages at least one of αn or αm to go to zero. So if you have two
data points that are very similar and have the same label, at least one
of the corresponding αs will be small. This makes intuitive sense: if
you have two data points that are basically the same (both in the x
and y sense) then you only need to “keep” one of them around.
Suppose that you have two data points with different labels:
ynym = −1. Again, if K(xn, xm) is small, nothing happens. But if
it is large, then the corresponding αs are encouraged to be as large as
possible. In other words, if you have two similar examples with dif-
ferent labels, you are strongly encouraged to keep the corresponding
αs as large as C.

An alternative way of understanding the SVM dual problem is
geometrically. Remember that the whole point of introducing the
variable αn was to ensure that the nth training example was correctly
classiﬁed, modulo slack. More formally, the goal of αn is to ensure
that yn(w · xn + b) − 1 + ξn ≥ 0. Suppose that this constraint it
not satisﬁed. There is an important result in optimization theory,
called the Karush-Kuhn-Tucker conditions (or KKT conditions, for
short) that states that at the optimum, the product of the Lagrange
multiplier for a constraint, and the value of that constraint, will equal
zero. In this case, this says that at the optimum, you have:

yn (w · xn + b) − 1 + ξn

αn

= 0

(11.39)

(cid:104)

(cid:105)

In order for this to be true, it means that (at least) one of the follow-
ing must be true:

αn = 0

or

yn (w · xn + b) − 1 + ξn = 0

(11.40)

kernel methods

153

A reasonable question to ask is: under what circumstances will αn
be non-zero? From the KKT conditions, you can discern that αn can
be non-zero only when the constraint holds exactly; namely, that
yn (w · xn + b) − 1 + ξn = 0. When does that constraint hold ex-
actly? It holds exactly only for those points precisely on the margin of
the hyperplane.

In other words, the only training examples for which αn (cid:54)= 0

are those that lie precisely 1 unit away from the maximum margin
decision boundary! (Or those that are “moved” there by the corre-
sponding slack.) These points are called the support vectors because
they “support” the decision boundary. In general, the number of sup-
port vectors is far smaller than the number of training examples, and
therefore you naturally end up with a solution that only uses a subset
of the training data.

From the ﬁrst discussion, you know that the points that wind up
being support vectors are exactly those that are “confusable” in the
sense that you have to examples that are nearby, but have different la-
bels. This is a completely in line with the previous discussion. If you
have a decision boundary, it will pass between these “confusable”
points, and therefore they will end up being part of the set of support
vectors.

11.7 Further Reading

TODO further reading

12 | LEARNING THEORY

Learning Objectives:
• Explain why inductive bias is

necessary.

• Deﬁne the PAC model and explain

why both the “P” and “A” are
necessary.

• Explain the relationship between

complexity measures and regulariz-
ers.

• Identify the role of complexity in

generalization.

• Formalize the relationship between

margins and complexity.

Dependencies:

The Universe is under no obligation to make sense to you.
Neil deGrasse Tyson

–

By now, you are an expert at building learning algorithms. You
probably understand how they work, intuitively. And you under-
stand why they should generalize. However, there are several basic
questions you might want to know the answer to. Is learning always
possible? How many training examples will I need to do a good job
learning? Is my test performance going to be much worse than my
training performance? The key idea that underlies all these answer is
that simple functions generalize well.

The amazing thing is that you can actually prove strong results

that address the above questions. In this chapter, you will learn
some of the most important results in learning theory that attempt
to answer these questions. The goal of this chapter is not theory for
theory’s sake, but rather as a way to better understand why learning
models work, and how to use this theory to build better algorithms.
As a concrete example, we will see how 2-norm regularization prov-
ably leads to better generalization performance, thus justifying our
common practice!

12.1 The Role of Theory

In contrast to the quote at the start of this chapter, a practitioner
friend once said “I would happily give up a few percent perfor-
mance for an algorithm that I can understand.” Both perspectives
are completely valid, and are actually not contradictory. The second
statement is presupposing that theory helps you understand, which
hopefully you’ll ﬁnd to be the case in this chapter.

Theory can serve two roles. It can justify and help understand

why common practice works. This is the “theory after” view. It can
also serve to suggest new algorithms and approaches that turn out to
work well in practice. This is the “theory before” view. Often, it turns
out to be a mix. Practitioners discover something that works surpris-
ingly well. Theorists ﬁgure out why it works and prove something
about it. And in the process, they make it better or ﬁnd new algo-

learning theory

155

1 In 2008, Corinna Cortes and Vladimir
Vapnik won it for support vector
machines.

rithms that more directly exploit whatever property it is that made
the theory go through.

Theory can also help you understand what’s possible and what’s
not possible. One of the ﬁrst things we’ll see is that, in general, ma-
chine learning can not work. Of course it does work, so this means
that we need to think harder about what it means for learning algo-
rithms to work. By understanding what’s not possible, you can focus
our energy on things that are.

Probably the biggest practical success story for theoretical machine

learning is the theory of boosting, which you won’t actually see in
this chapter. (You’ll have to wait for Chapter 13.) Boosting is a very
simple style of algorithm that came out of theoretical machine learn-
ing, and has proven to be incredibly successful in practice. So much
so that it is one of the de facto algorithms to run when someone gives
you a new data set. In fact, in 2004, Yoav Freund and Rob Schapire
won the ACM’s Paris Kanellakis Award for their boosting algorithm
AdaBoost. This award is given for theoretical accomplishments that
have had a signiﬁcant and demonstrable effect on the practice of
computing.1

12.2

Induction is Impossible

One nice thing about theory is that it forces you to be precise about
what you are trying to do. You’ve already seen a formal deﬁnition
of binary classiﬁcation in Chapter 6. But let’s take a step back and
re-analyze what it means to learn to do binary classiﬁcation.
From an algorithmic perspective, a natural question is whether
there is an “ultimate” learning algorithm, Aawesome, that solves the
Binary Classiﬁcation problem above. In other words, have you been
wasting your time learning about KNN and Perceptron and decision
trees, when Aawesome is out there.

What would such an ultimate learning algorithm do? You would

like it to take in a data set D and produce a function f . No matter
what D looks like, this function f should get perfect classiﬁcation on
all future examples drawn from the same distribution that produced
D.

A little bit of introspection should demonstrate that this is impos-
sible. For instance, there might be label noise in our distribution. As
a very simple example, let X = {−1, +1} (i.e., a one-dimensional,
binary distribution. Deﬁne the data distribution as:

D((cid:104)+1(cid:105), +1) = 0.4
D((cid:104)+1(cid:105),−1) = 0.1

D((cid:104)−1(cid:105),−1) = 0.4
D((cid:104)−1(cid:105), +1) = 0.1

(12.1)
(12.2)

In other words, 80% of data points in this distrubtion have x = y

156 a course in machine learning

and 20% don’t. No matter what function your learning algorithm
produces, there’s no way that it can do better than 20% error on this
data.
Given this, it seems hopeless to have an algorithm Aawesome that
always achieves an error rate of zero. The best that we can hope is
that the error rate is not “too large.”

Unfortunately, simply weakening our requirement on the error
rate is not enough to make learning possible. The second source of
difﬁculty comes from the fact that the only access we have to the
data distribution is through sampling. In particular, when trying to
learn about a distribution like that in 12.1, you only get to see data
points drawn from that distribution. You know that “eventually” you
will see enough data points that your sample is representative of the
distribution, but it might not happen immediately. For instance, even
though a fair coin will come up heads only with probability 1/2, it’s
completely plausible that in a sequence of four coin ﬂips you never
see a tails, or perhaps only see one tails.
Aawesome will always work. In particular, if we happen to get a lousy
sample of data from D, we need to allow Aawesome to do something
completely unreasonable.
Thus, we cannot hope that Aawesome will do perfectly, every time.
We cannot even hope that it will do pretty well, all of the time. Nor
can we hope that it will do perfectly, most of the time. The best best
we can reasonably hope of Aawesome is that it it will do pretty well,
most of the time.

So the second thing that we have to give up is the hope that

12.3 Probably Approximately Correct Learning

Probably Approximately Correct (PAC) learning is a formalism
of inductive learning based on the realization that the best we can
hope of an algorithm is that it does a good job (i.e., is approximately
correct), most of the time (i.e., it is probably appoximately correct).2

Consider a hypothetical learning algorithm. You run it on ten dif-
ferent binary classiﬁcation data sets. For each one, it comes back with
functions f1, f2, . . . , f10. For some reason, whenever you run f4 on a
test point, it crashes your computer. For the other learned functions,
their performance on test data is always at most 5% error. If this
situtation is guaranteed to happen, then this hypothetical learning
algorithm is a PAC learning algorithm. It satisﬁes “probably” because
it only failed in one out of ten cases, and it’s “approximate” because
it achieved low, but non-zero, error on the remainder of the cases.

This leads to the formal deﬁnition of an (, δ) PAC-learning algo-

rithm. In this deﬁnition,  plays the role of measuring accuracy (in

?

It’s clear that if your algorithm pro-
duces a deterministic function that
it cannot do better than 20% error.
What if it produces a stochastic (aka
randomized) function?

2 Leslie Valiant invented the notion
of PAC learning in 1984. In 2011,
he received the Turing Award, the
highest honor in computing for his
work in learning theory, computational
complexity and parallel systems.

learning theory

157

the previous example,  = 0.05) and δ plays the role of measuring
failure (in the previous, δ = 0.1).
Deﬁnitions 1. An algorithm A is an (, δ)-PAC learning algorithm if, for
all distributions D: given samples from D, the probability that it returns a
“bad function” is at most δ; where a “bad” function is one with test error
rate more than  on D.

There are two notions of efﬁciency that matter in PAC learning. The
ﬁrst is the usual notion of computational complexity. You would prefer
an algorithm that runs quickly to one that takes forever. The second
is the notion of sample complexity: the number of examples required
for your algorithm to achieve its goals. Note that the goal of both
of these measure of complexity is to bound how much of a scarse
resource your algorithm uses. In the computational case, the resource
is CPU cycles. In the sample case, the resource is labeled examples.
Deﬁnition: An algorithm A is an efﬁcient (, δ)-PAC learning al-
gorithm if it is an (, δ)-PAC learning algorithm whose runtime is
polynomial in 1

 and 1
δ .

In other words, suppose that you want your algorithm to achieve
4% error rate rather than 5%. The runtime required to do so should
no go up by an exponential factor.

12.4 PAC Learning of Conjunctions

To get a better sense of PAC learning, we will start with a completely
irrelevant and uninteresting example. The purpose of this example is
only to help understand how PAC learning works.
The setting is learning conjunctions. Your data points are binary
vectors, for instance x = (cid:104)0, 1, 1, 0, 1(cid:105). Someone guarantees for you
that there is some boolean conjunction that deﬁnes the true labeling
of this data. For instance, x1 ∧ ¬x2 ∧ x5 (“or” is not allowed). In
formal terms, we often call the true underlying classiﬁcation function
the concept. So this is saying that the concept you are trying to learn
is a conjunction. In this case, the boolean function would assign a
negative label to the example above.

Since you know that the concept you are trying to learn is a con-
junction, it makes sense that you would represent your function as
a conjunction as well. For historical reasons, the function that you
learn is often called a hypothesis and is often denoted h. However,
in keeping with the other notation in this book, we will continue to
denote it f .
Formally, the set up is as follows. There is some distribution DX
over binary data points (vectors) x = (cid:104)x1, x2, . . . , xD(cid:105). There is a ﬁxed

158 a course in machine learning

concept conjunction c that we are trying to learn. There is no noise,
so for any example x, its true label is simply y = c(x).

What is a reasonable algorithm in this case? Suppose that you

observe the example in Table 12.1. From the ﬁrst example, we know
that the true formula cannot include the term x1. If it did, this exam-
ple would have to be negative, which it is not. By the same reason-
ing, it cannot include x2. By analogous reasoning, it also can neither
include the term ¬x3 nor the term ¬x4.

This suggests the algorithm in Algorithm 12.4, colloquially the

y
+1
+1
-1

x1
0
0
1

x2
0
1
1

x3
1
1
0

x4
1
1
1

Table 12.1: Data set for learning con-
junctions.

?

Verify that Algorithm 12.4 main-
tains an invariant that it always errs
on the side of classifying examples
negative and never errs the other
way.

“Throw Out Bad Terms” algorithm. In this algorithm, you begin with
a function that includes all possible 2D terms. Note that this function
will initially classify everything as negative. You then process each
example in sequence. On a negative example, you do nothing. On
a positive example, you throw out terms from f that contradict the
given positive example.

If you run this algorithm on the data in Table 12.1, the sequence of

f s that you cycle through are:

f 0(x) = x1 ∧ ¬x1 ∧ x2 ∧ ¬x2 ∧ x3 ∧ ¬x3 ∧ x4 ∧ ¬x4
f 1(x) = ¬x1 ∧ ¬x2 ∧ x3 ∧ x4
f 2(x) = ¬x1 ∧ x3 ∧ x4
f 3(x) = ¬x1 ∧ x3 ∧ x4

(12.3)
(12.4)
(12.5)
(12.6)

The ﬁrst thing to notice about this algorithm is that after processing
an example, it is guaranteed to classify that example correctly. This
observation requires that there is no noise in the data.

The second thing to notice is that it’s very computationally ef-
ﬁcient. Given a data set of N examples in D dimensions, it takes
O(ND) time to process the data. This is linear in the size of the data
set.

However, in order to be an efﬁcient (, δ)-PAC learning algorithm,
you need to be able to get a bound on the sample complexity of this
algorithm. Sure, you know that its run time is linear in the number
of example N. But how many examples N do you need to see in order
to guarantee that it achieves an error rate of at most  (in all but δ-
many cases)? Perhaps N has to be gigantic (like 22D/) to (probably)
guarantee a small error.

The goal is to prove that the number of samples N required to
(probably) achieve a small error is not-too-big. The general proof
technique for this has essentially the same ﬂavor as almost every PAC
learning proof around. First, you deﬁne a “bad thing.” In this case,
a “bad thing” is that there is some term (say ¬x8) that should have
been thrown out, but wasn’t. Then you say: well, bad things happen.
Then you notice that if this bad thing happened, you must not have

learning theory

159

// initialize function

Algorithm 31 BinaryConjunctionTrain(D)

f ← x1 ∧ ¬x1 ∧ x2 ∧ ¬x2 ∧ · · · ∧ xD ∧ ¬xD
1:
2: for all positive examples (x,+1) in D do
3:

for d = 1 . . . D do
if xd = 0 then

else

f ← f without term “xd”
f ← f without term “¬xd”

4:

5:

6:

7:

8:

end if
end for

9:
10: end for
11: return f

seen any positive training examples with x8 = 0. So example with
x8 = 0 must have low probability (otherwise you would have seen
them). So bad things must not be that common.
Theorem 14. With probability at least (1 − δ): Algorithm 12.4 requires at
most N = . . . examples to achieve an error rate ≤ .

Proof of Theorem 14. Let c be the concept you are trying to learn and
let D be the distribution that generates the data.

A learned function f can make a mistake if it contains any term t
that is not in c. There are initially 2D many terms in f , and any (or
all!) of them might not be in c. We want to ensure that the probability
that f makes an error is at most . It is sufﬁcient to ensure that

For a term t (e.g., ¬x5), we say that t “negates” an example x if

t(x) = 0. Call a term t “bad” if (a) it does not appear in c and (b) has
probability at least /2D of appearing (with respect to the unknown
distribution D over data points).

First, we show that if we have no bad terms left in f , then f has an

error rate at most .

We know that f contains at most 2D terms, since is begins with 2D

terms and throws them out.

The algorithm begins with 2D terms (one for each variable and

one for each negated variable). Note that f will only make one type
of error: it can call positive examples negative, but can never call a
negative example positive. Let c be the true concept (true boolean
formula) and call a term “bad” if it does not appear in c. A speciﬁc
bad term (e.g., ¬x5) will cause f to err only on positive examples
that contain a corresponding bad value (e.g., x5 = 1). TODO... ﬁnish
this

What we’ve shown in this theorem is that: if the true underly-

ing concept is a boolean conjunction, and there is no noise, then the
“Throw Out Bad Terms” algorithm needs N ≤ . . . examples in order

160 a course in machine learning

to learn a boolean conjunction that is (1 − δ)-likely to achieve an er-
ror of at most . That is to say, that the sample complexity of “Throw
Out Bad Terms” is . . . . Moreover, since the algorithm’s runtime is
linear in N, it is an efﬁcient PAC learning algorithm.

12.5 Occam’s Razor: Simple Solutions Generalize

The previous example of boolean conjunctions is mostly just a warm-
up exercise to understand PAC-style proofs in a concrete setting.
In this section, you get to generalize the above argument to a much
larger range of learning problems. We will still assume that there is
no noise, because it makes the analysis much simpler. (Don’t worry:
noise will be added eventually.)

William of Occam (c. 1288 – c. 1348) was an English friar and

philosopher is is most famous for what later became known as Oc-
cam’s razor and popularized by Bertrand Russell. The principle ba-
sically states that you should only assume as much as you need. Or,
more verbosely, “if one can explain a phenomenon without assuming
this or that hypothetical entity, then there is no ground for assuming
it i.e. that one should always opt for an explanation in terms of the
fewest possible number of causes, factors, or variables.” What Occam
actually wrote is the quote that began this chapter.

In a machine learning context, a reasonable paraphrase is “simple
solutions generalize well.” In other words, you have 10, 000 features
you could be looking at. If you’re able to explain your predictions
using just 5 of them, or using all 10, 000 of them, then you should just
use the 5.

The Occam’s razor theorem states that this is a good idea, theo-
retically. It essentially states that if you are learning some unknown
concept, and if you are able to ﬁt your training data perfectly, but you
don’t need to resort to a huge class of possible functions to do so,
then your learned function will generalize well. It’s an amazing theo-
rem, due partly to the simplicity of its proof. In some ways, the proof
is actually easier than the proof of the boolean conjunctions, though it
follows the same basic argument.

In order to state the theorem explicitly, you need to be able to

think about a hypothesis class. This is the set of possible hypotheses
that your algorithm searches through to ﬁnd the “best” one. In the
case of the boolean conjunctions example, the hypothesis class, H,
is the set of all boolean formulae over D-many variables. In the case
of a perceptron, your hypothesis class is the set of all possible linear
classiﬁers. The hypothesis class for boolean conjunctions is ﬁnite; the
hypothesis class for linear classiﬁers is inﬁnite. For Occam’s razor, we
can only work with ﬁnite hypothesis classes.

learning theory

161

Figure 12.1: thy:dt: picture of full
decision tree

Theorem 15 (Occam’s Bound). Suppose A is an algorithm that learns
a function f from some ﬁnite hypothesis class H. Suppose the learned
function always gets zero error on the training data. Then, the sample com-
plexity of f is at most log|H|.

TODO COMMENTS

Proof of Theorem 15. TODO

This theorem applies directly to the “Throw Out Bad Terms” algo-
rithm, since (a) the hypothesis class is ﬁnite and (b) the learned func-
tion always achieves zero error on the training data. To apply Oc-
cam’s Bound, you need only compute the size of the hypothesis class
H of boolean conjunctions. You can compute this by noticing that
there are a total of 2D possible terms in any formula in H. Moreover,
each term may or may not be in a formula. So there are 22D = 4D
possible formulae; thus, |H| = 4D. Applying Occam’s Bound, we see
that the sample complexity of this algorithm is N ≤ . . . .

Of course, Occam’s Bound is general enough to capture other
learning algorithms as well. In particular, it can capture decision
trees! In the no-noise setting, a decision tree will always ﬁt the train-
ing data perfectly. The only remaining difﬁculty is to compute the
size of the hypothesis class of a decision tree learner.

For simplicity’s sake, suppose that our decision tree algorithm
always learns complete trees: i.e., every branch from root to leaf
is length D. So the number of split points in the tree (i.e., places
where a feature is queried) is 2D−1. (See Figure 12.1.) Each split
point needs to be assigned a feature: there D-many choices here.
This gives D2D−1 trees. The last thing is that there are 2D leaves
of the tree, each of which can take two possible values, depending
on whether this leaf is classiﬁed as +1 or −1: this is 2×2D = 2D+1
possibilities. Putting this all togeter gives a total number of trees
|H| = D2D−12D+1 = D22D = D4D. Applying Occam’s Bound, we see
that TODO examples is enough to learn a decision tree!

12.6 Complexity of Inﬁnite Hypothesis Spaces

Occam’s Bound is a fantastic result for learning over ﬁnite hypothesis
spaces. Unfortunately, it is completely useless when |H| = ∞. This is
because the proof works by using each of the N training examples to
“throw out” bad hypotheses until only a small number are left. But if
|H| = ∞, and you’re throwing out a ﬁnite number at each step, there
will always be an inﬁnite number remaining.

This means that, if you want to establish sample complexity results
for inﬁnite hypothesis spaces, you need some new way of measuring

162 a course in machine learning

their “size” or “complexity.” A prototypical way of doing this is to
measure the complexity of a hypothesis class as the number of different
things it can do.

As a silly example, consider boolean conjunctions again. Your

input is a vector of binary features. However, instead of representing
your hypothesis as a boolean conjunction, you choose to represent
it as a conjunction of inequalities. That is, instead of writing x1 ∧
¬x2 ∧ x5, you write [x1 > 0.2] ∧ [x2 < 0.77] ∧ [x5 < π/4]. In this
representation, for each feature, you need to choose an inequality
(< or >) and a threshold. Since the thresholds can be arbitrary real
values, there are now inﬁnitely many possibilities: |H| = 2D×∞ = ∞.
However, you can immediately recognize that on binary features,
there really is no difference between [x2 < 0.77] and [x2 < 0.12] and
any other number of inﬁnitely many possibilities. In other words,
even though there are inﬁnitely many hypotheses, there are only ﬁnitely
many behaviors.

The Vapnik-Chernovenkis dimension (or VC dimension) is a

classic measure of complexity of inﬁnite hypothesis classes based on
this intuition3. The VC dimension is a very classiﬁcation-oriented no-
tion of complexity. The idea is to look at a ﬁnite set of unlabeled ex-
amples, such as those in Figure 12.2. The question is: no matter how
these points were labeled, would we be able to ﬁnd a hypothesis that
correctly classiﬁes them. The idea is that as you add more points,
being able to represent an arbitrary labeling becomes harder and
harder. For instance, regardless of how the three points are labeled,
you can ﬁnd a linear classiﬁer that agrees with that classiﬁcation.
However, for the four points, there exists a labeling for which you
cannot ﬁnd a perfect classiﬁer. The VC dimension is the maximum
number of points for which you can always ﬁnd such a classiﬁer.
You can think of VC dimension as a game between you and an

adversary. To play this game, you choose K unlabeled points however
you want. Then your adversary looks at those K points and assigns
binary labels to them them however they want. You must then ﬁnd
a hypothesis (classiﬁer) that agrees with their labeling. You win if
you can ﬁnd such a hypothesis; they win if you cannot. The VC
dimension of your hypothesis class is the maximum number of points
K so that you can always win this game. This leads to the following
formal deﬁnition, where you can interpret there exists as your move
and for all as adversary’s move.

Deﬁnitions 2. For data drawn from some space X , the VC dimension of
a hypothesis space H over X is the maximal K such that: there exists a set
X ⊆ X of size |X| = K, such that for all binary labelings of X, there exists
a function f ∈ H that matches this labeling.

Figure 12.2: thy:vcex: ﬁgure with three
and four examples
3 Yes, this is the same Vapnik who
is credited with the creation of the
support vector machine.

?

What is that labeling? What is it’s
name?

learning theory

163

In general, it is much easier to show that the VC dimension is at
least some value; it is much harder to show that it is at most some
value. For example, following on the example from Figure 12.2, the
image of three points (plus a little argumentation) is enough to show
that the VC dimension of linear classiﬁers in two dimension is at least
three.

To show that the VC dimension is exactly three it sufﬁces to show
that you cannot ﬁnd a set of four points such that you win this game
against the adversary. This is much more difﬁcult. In the proof that
the VC dimension is at least three, you simply need to provide an
example of three points, and then work through the small number of
possible labelings of that data. To show that it is at most three, you
need to argue that no matter what set of four point you pick, you
cannot win the game.

12.7 Further Reading

TODO

13 | ENSEMBLE METHODS

Learning Objectives:
• Implement bagging and explain how

it reduces variance in a predictor.
• Explain the difference between a

weak learner and a strong learner.

• Derive the AdaBoost algorithm.
• Understand the relationship between
boosting decision stumps and linear
classiﬁcation.

Dependencies:

This is the central illusion in life: that randomness is a risk, that it
is a bad thing. . .

– Nassim Nicholas Taleb

Groups of people can often make better decisions than
individuals, especially when group members each come in with
their own biases. The same is true in machine learning. Ensemble
methods are learning models that achieve performance by combining
the opinions of multiple learners. In doing so, you can often get away
with using much simpler learners and still achieve great performance.
Moreover, ensembles are inherantly parallel, which can make them
much more efﬁcient at training and test time, if you have access to
multiple processors.

In this chapter, you will learn about various ways of combining
base learners into ensembles. One of the shocking results we will
see is that you can take a learning model that only ever does slightly
better than chance, and turn it into an arbitrarily good learning
model, though a technique known as boosting. You will also learn
how ensembles can decrease the variance of predictors as well as
perform regularization.

13.1 Voting Multiple Classiﬁers

All of the learning algorithms you have seen so far are deterministic.
If you train a decision tree multiple times on the same data set, you
will always get the same tree back. In order to get an effect out of
voting multiple classiﬁers, they need to differ. There are two primary
ways to get variability. You can either change the learning algorithm
or change the data set.

Building an emsemble by training different classiﬁers is the most

straightforward approach. As in single-model learning, you are given
a data set (say, for classiﬁcation). Instead of learning a single classiﬁer
(e.g., a decision tree) on this data set, you learn multiple different
classiﬁers. For instance, you might train a decision tree, a perceptron,
a KNN, and multiple neural networks with different architectures.
Call these classiﬁers f1, . . . , fM. At test time, you can make a predic-
tion by voting. On a test example ˆx, you compute ˆy1 = f1( ˆx), . . . ,

ensemble methods

165

?

Which of the classiﬁers you’ve
learned about so far have high
variance?

Figure 13.1: picture of sampling with
replacement
1 To sample with replacement, imagine
putting all items from D in a hat. To
draw a single sample, pick an element
at random from that hat, write it down,
and then put it back.

ˆyM = fM( ˆx). If there are more +1s in the list (cid:104)y1, . . . , yM then you
predict +1; otherwise you predict −1.

The main advantage of ensembles of different classiﬁers is that it
is unlikely that all classiﬁers will make the same mistake. In fact, as
long as every error is made by a minority of the classiﬁers, you will
achieve optimal classiﬁcation! Unfortunately, the inductive biases of
different learning algorithms are highly correlated. This means that
different algorithms are prone to similar types of errors. In particular,
ensembles tend to reduce the variance of classiﬁers. So if you have
a classiﬁcation algorithm that tends to be very sensitive to small
changes in the training data, ensembles are likely to be useful.

Note that the voting scheme naturally extends to multiclass clas-
siﬁcation. However, it does not make sense in the contexts of regres-
sion, ranking or collective classiﬁcation. This is because you will
rarely see the same exact output predicted twice by two different
regression models (or ranking models or collective classiﬁcation mod-
els). For regression, a simple solution is to take the mean or median
prediction from the different models. For ranking and collective clas-
siﬁcation, different approaches are required.

Instead of training different types of classiﬁers on the same data

set, you can train a single type of classiﬁer (e.g., decision tree) on
multiple data sets. The question is: where do these multiple data sets
come from, since you’re only given one at training time?

One option is to fragment your original data set. For instance, you
could break it into 10 pieces and build decision trees on each of these
pieces individually. Unfortunately, this means that each decision tree
is trained on only a very small part of the entire data set and is likely
to perform poorly.

A better solution is to use bootstrap resampling. This is a tech-
nique from the statistics literature based on the following observa-
tion. The data set we are given, D, is a sample drawn i.i.d. from an
unknown distribution D. If we draw a new data set ˜D by random
sampling from D with replacement1, then ˜D is also a sample from D.
Figure 13.1 shows the process of bootstrap resampling of ten objects.
Applying this idea to ensemble methods yields a technique known

as bagging. You start with a single data set D that contains N train-
ing examples. From this single data set, you create M-many “boot-
strapped training sets” ˜D1, . . . ˜DM. Each of these bootstrapped sets
also contains N training examples, drawn randomly from D with
replacement. You can then train a decision tree (or other model)
seperately on each of these data sets to obtain classiﬁers f1, . . . , fM.
As before, you can use these classiﬁers to vote on new test points.

Note that the bootstrapped data sets will be similar. However, they
will not be too similar. For example, if N is large then the number of

Figure 13.2: graph depicting overﬁtting
using regularization versus bagging

166 a course in machine learning

examples that are not present in any particular bootstrapped sample
is relatively large. The probability that the ﬁrst training example is
not selected once is (1 − 1/N). The probability that it is not selected
at all is (1 − 1/N)N. As N → ∞, this tends to 1/e ≈ 0.3679. (Already
for N = 1000 this is correct to four decimal points.) So only about
63% of the original training examples will be represented in any
given bootstrapped set.

Since bagging tends to reduce variance, it provides an alternative
approach to regularization. That is, even if each of the learned clas-
siﬁers f1, . . . , fM are individually overﬁt, they are likely to be overﬁt
to different things. Through voting, you are able to overcome a sig-
niﬁcant portion of this overﬁtting. Figure 13.2 shows this effect by
comparing regularization via hyperparameters to regularization via
bagging.

13.2 Boosting Weak Learners

Boosting is the process of taking a crummy learning algorithm (tech-
nically called a weak learner) and turning it into a great learning
algorithm (technically, a strong learner). Of all the ideas that origi-
nated in the theoretical machine learning community, boosting has
had—perhaps—the greatest practical impact. The idea of boosting
is reminiscent of what you (like me!) might have thought when you
ﬁrst learned about ﬁle compression. If I compress a ﬁle, and then
re-compress it, and then re-compress it, eventually I’ll end up with a
ﬁnal that’s only one byte in size!
To be more formal, let’s deﬁne a strong learning algorithm L as
follows. When given a desired error rate , a failure probability δ
and access to “enough” labeled examples from some distribution D,
then, with high probability (at least 1 − δ), L learns a classiﬁer f that
has error at most . This is precisely the deﬁnition of PAC learning
that you learned about in Chapter 12. Building a strong learning
algorithm might be difﬁcult. We can as if, instead, it is possible to
build a weak learning algorithm W that only has to achieve an error
rate of 49%, rather than some arbitrary user-deﬁned parameter .
(49% is arbitrary: anything strictly less than 50% would be ﬁne.)
work for taking a weak learning algorithm W and turning it into a
strong learning algorithm. The particular boosting algorithm dis-
cussed here is AdaBoost, short for “adaptive boosting algorithm.”
AdaBoost is famous because it was one of the ﬁrst practical boosting
algorithms: it runs in polynomial time and does not require you to
deﬁne a large number of hyperparameters. It gets its name from the
latter beneﬁt: it automatically adapts to the data that you give it.

Boosting is more of a “framework” than an algorithm. It’s a frame-

ensemble methods

167

?

What happens if the weak learn-
ing assumption is violated and ˆ is
equal to 50%? What if it is worse
than 50%? What does this mean, in
practice?

N , 1

Algorithm 32 AdaBoost(W, D, K)
1: d(0) ← (cid:104) 1
2: for k = 1 . . . K do
3:

N(cid:105)
N , . . . , 1
f (k) ← W (D, d(k-1))
ˆyn ← f (k)(xn), ∀n
(cid:17)
(cid:16) 1− ˆ(k)
ˆ(k) ← ∑n d(k-1)
[yn (cid:54)= ˆyn]
α(k) ← 1
exp[−α(k)yn ˆyn], ∀n
n ← 1
d(k)

n
2 log
Z d(k-1)
n

4:

5:

6:

ˆ(k)

7:
8: end for

9: return f (ˆx) = sgn(cid:2)∑k α(k) f (k)(ˆx)(cid:3)

// Initialize uniform importance to each example

// Train kth classiﬁer on weighted data
// Make predictions on training data
// Compute weighted training error
// Compute “adaptive” parameter

// Re-weight examples and normalize

// Return (weighted) voted classiﬁer

The intuition behind AdaBoost is like studying for an exam by

using a past exam. You take the past exam and grade yourself. The
questions that you got right, you pay less attention to. Those that you
got wrong, you study more. Then you take the exam again and repeat
this process. You continually down-weight the importance of questions
you routinely answer correctly and up-weight the importance of ques-
tions you routinely answer incorrectly. After going over the exam
multiple times, you hope to have mastered everything.

The precise AdaBoost training algorithm is shown in Algorithm 13.2.

The basic functioning of the algorithm is to maintain a weight dis-
tribution d, over data points. A weak learner, f (k) is trained on this
weighted data. (Note that we implicitly assume that our weak learner
can accept weighted training data, a relatively mild assumption that
is nearly always true.) The (weighted) error rate of f (k) is used to de-
termine the adaptive parameter α, which controls how “important” f (k)
is. As long as the weak learner does, indeed, achieve < 50% error,
then α will be greater than zero. As the error drops to zero, α grows
without bound.

After the adaptive parameter is computed, the weight distibution
is updated for the next iteration. As desired, examples that are cor-
rectly classiﬁed (for which yn ˆyn = +1) have their weight decreased
multiplicatively. Examples that are incorrectly classiﬁed (yn ˆyn = −1)
have their weight increased multiplicatively. The Z term is a nom-
ralization constant to ensure that the sum of d is one (i.e., d can be
interpreted as a distribution). The ﬁnal classiﬁer returned by Ad-
aBoost is a weighted vote of the individual classiﬁers, with weights
given by the adaptive parameters.

To better understand why α is deﬁned as it is, suppose that our

weak learner simply returns a constant function that returns the
(weighted) majority class. So if the total weight of positive exam-
ples exceeds that of negative examples, f (x) = +1 for all x; otherwise
f (x) = −1 for all x. To make the problem moderately interesting,
suppose that in the original training set, there are 80 positive ex-

168 a course in machine learning

2 log 4] = 1

2 log 4] = 2. We can compute Z = 80×1

amples and 20 negative examples. In this case, f (1)(x) = +1. It’s
weighted error rate will be ˆ(1) = 0.2 because it gets every negative
example wrong. Computing, we get α(1) = 1
2 log 4. Before normaliza-
tion, we get the new weight for each positive (correct) example to be
1 exp[− 1
2. The weight for each negative (incorrect) example
2 + 20×2 = 80.
becomes 1 exp[ 1
Therefore, after normalization, the weight distribution on any single
positive example is 1
160 and the weight on any negative example is 1
40.
However, since there are 80 positive examples and 20 negative exam-
ples, the cumulative weight on all positive examples is 80× 1
160 = 1
2;
the cumulative weight on all negative examples is 20× 1
40 = 1
2. Thus,
after a single boosting iteration, the data has become precisely evenly
weighted. This guarantees that in the next iteration, our weak learner
must do something more interesting than majority voting if it is to
achieve an error rate less than 50%, as required.

One of the major attractions of boosting is that it is perhaps easy
to design computationally efﬁcient weak learners. A very popular
type of weak learner is a shallow decision tree: a decision tree with a
small depth limit. Figure 13.3 shows test error rates for decision trees
of different maximum depths (the different curves) run for differing
numbers of boosting iterations (the x-axis). As you can see, if you
are willing to boost for many iterations, very shallow trees are quite
effective.

In fact, a very popular weak learner is a decision decision stump:
a decision tree that can only ask one question. This may seem like a
silly model (and, in fact, it is on it’s own), but when combined with
boosting, it becomes very effective. To understand why, suppose for
a moment that our data consists only of binary features, so that any
question that a decision tree might ask is of the form “is feature 5
on?” By concentrating on decision stumps, all weak functions must
have the form f (x) = s(2xd − 1), where s ∈ {±1} and d indexes some
feature.

Now, consider the ﬁnal form of a function learned by AdaBoost.

?

This example uses concrete num-
bers, but the same result holds no
matter what the data distribution
looks like nor how many examples
there are. Write out the general case
to see that you will still arrive at an
even weighting after one iteration.

We can expand it as follow, where we let fk denote the single feature
selected by the kth decision stump and let sk denote its sign:

(cid:35)

(cid:35)

(cid:35)

f (x) = sgn

= sgn

αk f (k)(x)

αksk(2x fk − 1)

2αkskx fk − ∑

αksk

k

= sgn
= sgn [w · x + b]

(cid:34)
(cid:34)
(cid:34)

∑
k
∑
k
∑
k

Figure 13.3: perf comparison of depth
vs # boost
?

Why do the functions have this
form?

(13.1)

(13.2)

(13.3)

(13.4)

ensemble methods

169

Algorithm 33 RandomForestTrain(D, depth, K)
1: for k = 1 . . . K do
2:

t(k) ← complete binary tree of depth depth with random feature splits
f (k) ← the function computed by t(k), with leaves ﬁlled in by D

3:
4: end for

5: return f (ˆx) = sgn(cid:2)∑k f (k)(ˆx)(cid:3)

// Return voted classiﬁer

where wd = ∑
k: fk=d

2αksk

and b = − ∑
k

αksk

(13.5)

Thus, when working with decision stumps, AdaBoost actually pro-
vides an algorithm for learning linear classiﬁers! In fact, this con-
nection has recently been strengthened: you can show that AdaBoost
provides an algorithm for optimizing exponential loss. (However,
this connection is beyond the scope of this book.)

As a further example, consider the case of boosting a linear classi-
ﬁer. In this case, if we let the kth weak classiﬁer be parameterized by
w(k) and b(k), the overall predictor will have the form:

(13.6)

(cid:34)

(cid:16)

w(k) · x + b(k)(cid:17)(cid:35)

f (x) = sgn

∑
k

αksgn

You can notice that this is nothing but a two-layer neural network,
with K-many hidden units! Of course it’s not a classiﬁcally trained
neural network (once you learn w(k) you never go back and update
it), but the structure is identical.

13.3 Random Ensembles

One of the most computationally expensive aspects of ensembles of
decision trees is training the decision trees. This is very fast for de-
cision stumps, but for deeper trees it can be prohibitively expensive.
The expensive part is choosing the tree structure. Once the tree struc-
ture is chosen, it is very cheap to ﬁll in the leaves (i.e., the predictions
of the trees) using the training data.

An efﬁcient and surprisingly effective alternative is to use trees
with ﬁxed structures and random features. Collections of trees are
called forests, and so classiﬁers built like this are called random
forests. The random forest training algorithm, shown in Algo-
rithm 13.3 is quite short. It takes three arguments: the data, a desired
depth of the decision trees, and a number K of total decision trees to
build.

The algorithm generates each of the K trees independently, which

makes it very easy to parallelize. For each trees, it constructs a full
binary tree of depth depth. The features used at the branches of this

170 a course in machine learning

tree are selected randomly, typically with replacement, meaning that
the same feature can appear multiple times, even in one branch. The
leaves of this tree, where predictions are made, are ﬁlled in based on
the training data. This last step is the only point at which the training
data is used. The resulting classiﬁer is then just a voting of the K-
many random trees.

The most amazing thing about this approach is that it actually

works remarkably well. It tends to work best when all of the features
are at least marginally relevant, since the number of features selected
for any given tree is small. An intuitive reason that it works well
is the following. Some of the trees will query on useless features.
These trees will essentially make random predictions. But some
of the trees will happen to query on good features and will make
good predictions (because the leaves are estimated based on the
training data). If you have enough trees, the random ones will wash
out as noise, and only the good trees will have an effect on the ﬁnal
classiﬁcation.

13.4 Further Reading

TODO further reading

14 | EFFICIENT LEARNING

Learning Objectives:
• Understand and be able to imple-
ment stochastic gradient descent
algorithms.

• Compare and contrast small ver-
sus large batch sizes in stochastic
optimization.

• Derive subgradients for sparse

regularizers.

• Implement feature hashing.

Dependencies:

One essential object is to choose that arrangement which shall
tend to reduce to a minimum the time necessary for completing
the calculation.

– Ada Lovelace

So far, our focus has been on models of learning and basic al-
gorithms for those models. We have not placed much emphasis on
how to learn quickly. The basic techniques you learned about so far
are enough to get learning algorithms running on tens or hundreds
of thousands of examples. But if you want to build an algorithm for
web page ranking, you will need to deal with millions or billions
of examples, in hundreds of thousands of dimensions. The basic
approaches you have seen so far are insufﬁcient to achieve such a
massive scale.

In this chapter, you will learn some techniques for scaling learning

algorithms. This are useful even when you do not have billions of
training examples, because it’s always nice to have a program that
runs quickly. You will see techniques for speeding up both model
training and model prediction. The focus in this chapter is on linear
models (for simplicity), but most of what you will learn applies more
generally.

14.1 What Does it Mean to be Fast?

Everyone always wants fast algorithms. In the context of machine
learning, this can mean many things. You might want fast training
algorithms, or perhaps training algorithms that scale to very large
data sets (for instance, ones that will not ﬁt in main memory). You
might want training algorithms that can be easily parallelized. Or,
you might not care about training efﬁciency, since it is an ofﬂine
process, and only care about how quickly your learned functions can
make classiﬁcation decisions.

It is important to separate out these desires. If you care about

efﬁciency at training time, then what you are really asking for are
more efﬁcient learning algorithms. On the other hand, if you care
about efﬁciency at test time, then you are asking for models that can
be quickly evaluated.

One issue that is not covered in this chapter is parallel learning.

172 a course in machine learning

This is largely because it is currently not a well-understood area in
machine learning. There are many aspects of parallelism that come
into play, such as the speed of communication across the network,
whether you have shared memory, etc. Right now, this the general,
poor-man’s approach to parallelization, is to employ ensembles.

14.2 Stochastic Optimization

During training of most learning algorithms, you consider the entire
data set simultaneously. This is certainly true of gradient descent
algorithms for regularized linear classiﬁers (recall Algorithm 7.4), in
which you ﬁrst compute a gradient over the entire training data (for
simplicity, consider the unbiased case):

g = ∑
n

∇w(cid:96)(yn, w · xn) + λw

(14.1)

where (cid:96)(y, ˆy) is some loss function. Then you update the weights by
w ← w − ηg. In this algorithm, in order to make a single update, you
have to look at every training example.

When there are billions of training examples, it is a bit silly to look

at every one before doing anything. Perhaps just on the basis of the
ﬁrst few examples, you can already start learning something!

Stochastic optimization involves thinking of your training data
as a big distribution over examples. A draw from this distribution
corresponds to picking some example (uniformly at random) from
your data set. Viewed this way, the optimization problem becomes a
stochastic optimization problem, because you are trying to optimize
some function (say, a regularized linear classiﬁer) over a probability
distribution. You can derive this intepretation directly as follows:

w∗ = arg max

w

= arg max

w

= arg max

w

∑
n

∑
n

∑
n

= arg max

w

E

(y,x)∼D

(cid:21)

R(w)

(cid:96)(yn, w · xn) + R(w)
(cid:20)
(cid:20) 1

(cid:96)(yn, w · xn) +

1
N

(cid:96)(yn, w · xn) +
(cid:20)

(cid:96)(y, w · x) +

N

(cid:21)
(cid:21)

1
N2 R(w)

1
N

R(w)

deﬁnition

(14.2)

move R inside sum
(14.3)

divide through by N
(14.4)

write as expectation
(14.5)
(14.6)

where D is the training data distribution

Given this framework, you have the following general form of an

efficient learning 173

Algorithm 34 StochasticGradientDescent(F, D, S, K, η1, . . . )
1: z(0) ← (cid:104)0, 0, . . . , 0(cid:105)
2: for k = 1 . . . K do
3:

// initialize variable we are optimizing

g(k) ← ∇zF (D(k))(cid:12)(cid:12)z(k-1)

D(k) ← S-many random data points from D
z(k) ← z(k-1) − η(k)g(k)

// compute gradient on sample
// take a step down the gradient

4:

5:
6: end for
7: return z(K)

optimization problem:
ζ [F (z, ζ)]

min

E

z

(14.7)

In the example, ζ denotes the random choice of examples over the
dataset, z denotes the weight vector and F (w, ζ) denotes the loss on
that example plus a fraction of the regularizer.

Stochastic optimization problems are formally harder than regu-
lar (deterministic) optimization problems because you do not even
get access to exact function values and gradients. The only access
you have to the function F that you wish to optimize are noisy mea-
surements, governed by the distribution over ζ. Despite this lack of
information, you can still run a gradient-based algorithm, where you
simply compute local gradients on a current sample of data.

More precisely, you can draw a data point at random from your
data set. This is analogous to drawing a single value ζ from its
distribution. You can compute the gradient of F just at that point.
In this case of a 2-norm regularized linear model, this is simply
g = ∇w(cid:96)(y, w · x) + 1
N w, where (y, x) is the random point you
selected. Given this estimate of the gradient (it’s an estimate because
it’s based on a single random draw), you can take a small gradient
step w ← w − ηg.

This is the stochastic gradient descent algorithm (SGD). In prac-

tice, taking gradients with respect to a single data point might be
too myopic. In such cases, it is useful to use a small batch of data.
Here, you can draw 10 random examples from the training data
and compute a small gradient (estimate) based on those examples:
g = ∑10
N w, where you need to include 10
counts of the regularizer. Popular batch sizes are 1 (single points)
and 10. The generic SGD algorithm is depicted in Algorithm 14.2,
which takes K-many steps over batches of S-many examples.

m=1 ∇w(cid:96)(ym, w · xm) + 10

In stochastic gradient descent, it is imperative to choose good step
sizes. It is also very important that the steps get smaller over time at
a reasonable slow rate. In particular, convergence can be guaranteed
for learning rates of the form: η(k) = η0√
k , where η0 is a ﬁxed, initial
step size, typically 0.01, 0.1 or 1 depending on how quickly you ex-

174 a course in machine learning

pect the algorithm to converge. Unfortunately, in comparisong to
gradient descent, stochastic gradient is quite sensitive to the selection
of a good learning rate.

There is one more practical issues related to the use of SGD as a
learning algorithm: do you really select a random point (or subset
of random points) at each step, or do you stream through the data
in order. The answer is akin to the answer of the same question for
the perceptron algorithm (Chapter 4). If you do not permute your
data at all, very bad things can happen. If you do permute your data
once and then do multiple passes over that same permutation, it
will converge, but more slowly. In theory, you really should permute
every iteration. If your data is small enough to ﬁt in memory, this
is not a big deal: you will only pay for cache misses. However, if
your data is too large for memory and resides on a magnetic disk
that has a slow seek time, randomly seeking to new data points for
each example is prohibitivly slow, and you will likely need to forgo
permuting the data. The speed hit in convergence speed will almost
certainly be recovered by the speed gain in not having to seek on disk
routinely. (Note that the story is very different for solid state disks,
on which random accesses really are quite efﬁcient.)

14.3 Sparse Regularization

For many learning algorithms, the test-time efﬁciency is governed
by how many features are used for prediction. This is one reason de-
cision trees tend to be among the fastest predictors: they only use a
small number of features. Especially in cases where the actual com-
putation of these features is expensive, cutting down on the number
that are used at test time can yield huge gains in efﬁciency. Moreover,
the amount of memory used to make predictions is also typically
governed by the number of features. (Note: this is not true of kernel
methods like support vector machines, in which the dominant cost is
the number of support vectors.) Furthermore, you may simply believe
that your learning problem can be solved with a very small number
of features: this is a very reasonable form of inductive bias.

This is the idea behind sparse models, and in particular, sparse
regularizers. One of the disadvantages of a 2-norm regularizer for
linear models is that they tend to never produce weights that are
exactly zero. They get close to zero, but never hit it. To understand
why, as a weight wd approaches zero, its gradient also approaches
zero. Thus, even if the weight should be zero, it will essentially never
get there because of the constantly shrinking gradient.

This suggests that an alternative regularizer is required to yield a
sparse inductive bias. An ideal case would be the zero-norm regular-

efficient learning 175

izer, which simply counts the number of non-zero values in a vector:
||w||0 = ∑d[wd (cid:54)= 0]. If you could minimize this regularizer, you
would be explicitly minimizing the number of non-zero features. Un-
fortunately, not only is the zero-norm non-convex, it’s also discrete.
Optimizing it is NP-hard.
A reasonable middle-ground is the one-norm: ||w||1 = ∑d |wd|.
It is indeed convex: in fact, it is the tighest (cid:96)p norm that is convex.
Moreover, its gradients do not go to zero as in the two-norm. Just as
hinge-loss is the tightest convex upper bound on zero-one error, the
one-norm is the tighest convex upper bound on the zero-norm.

At this point, you should be content. You can take your subgradi-
ent optimizer for arbitrary functions and plug in the one-norm as a
regularizer. The one-norm is surely non-differentiable at wd = 0, but
you can simply choose any value in the range [−1, +1] as a subgradi-
ent at that point. (You should choose zero.)

Unfortunately, this does not quite work the way you might expect.

The issue is that the gradient might “overstep” zero and you will
never end up with a solution that is particularly sparse. For example,
at the end of one gradient step, you might have w3 = 0.6. Your
gradient might have g6 = 0.8 and your gradient step (assuming
η = 1) will update so that the new w3 = −0.2. In the subsequent
iteration, you might have g6 = −0.3 and step to w3 = 0.1.

This observation leads to the idea of trucated gradients. The idea

is simple: if you have a gradient that would step you over wd = 0,
then just set wd = 0. In the easy case when the learning rate is 1, this
means that if the sign of wd − gd is different than the sign of wd then
you truncate the gradient step and simply set wd = 0. In other words,
gd should never be larger than wd Once you incorporate learning
rates, you can express this as:

 gd

gd
0

gd ←

if wd > 0 and gd ≤ 1
if wd < 0 and gd ≥ 1
otherwise

η(k) wd
η(k) wd

(14.8)

This works quite well in the case of subgradient descent. It works
somewhat less well in the case of stochastic subgradient descent. The
problem that arises in the stochastic case is that wherever you choose
to stop optimizing, you will have just touched a single example (or
small batch of examples), which will increase the weights for a lot of
features, before the regularizer “has time” to shrink them back down
to zero. You will still end up with somewhat sparse solutions, but not
as sparse as they could be. There are algorithms for dealing with this
situation, but they all have a heuristic ﬂavor to them and are beyond
the scope of this book.

176 a course in machine learning

14.4 Feature Hashing

As much as speed is a bottleneck in prediction, so often is memory
usage. If you have a very large number of features, the amount of
memory that it takes to store weights for all of them can become
prohibitive, especially if you wish to run your algorithm on small de-
vices. Feature hashing is an incredibly simple technique for reducing
the memory footprint of linear models, with very small sacriﬁces in
accuracy.

The basic idea is to replace all of your features with hashed ver-
sions of those features, thus reducing your space from D-many fea-
ture weights to P-many feature weights, where P is the range of
the hash function. You can actually think of hashing as a (random-
ized) feature mapping φ : RD → RP, for some P (cid:28) D. The idea
is as follows. First, you choose a hash function h whose domain is
[D] = {1, 2, . . . , D} and whose range is [P]. Then, when you receive a
feature vector x ∈ RD, you map it to a shorter feature vector ˆx ∈ RP.
Algorithmically, you can think of this mapping as follows:

1. Initialize ˆx = (cid:104)0, 0, . . . , 0(cid:105)

2. For each d = 1 . . . D:

(a) Hash d to position p = h(d)
(b) Update the pth position by adding xd: ˆxp ← ˆxp + xd

3. Return ˆx

Mathematically, the mapping looks like:

φ(x)p = ∑
d

[h(d) = p]xd = ∑

d∈h−1(p)

xd

where h−1(p) = {d : h(d) = p}.

(14.9)

In the (unrealistic) case where P = D and h simply encodes a per-

mutation, then this mapping does not change the learning problem
at all. All it does is rename all of the features. In practice, P (cid:28) D
and there will be collisions. In this context, a collision means that
two features, which are really different, end up looking the same to
the learning algorithm. For instance, “is it sunny today?” and “did
my favorite sports team win last night?” might get mapped to the
same location after hashing. The hope is that the learning algorithm
is sufﬁciently robust to noise that it can handle this case well.

Consider the kernel deﬁned by this hash mapping. Namely:
K(hash)(x, z) = φ(x) · φ(z)

(cid:33)

(cid:32)

∑
d,e

= ∑
p
= ∑
p
= ∑
d

e∈h−1(h(d))

= x · z + ∑
d

xdze

∑
e(cid:54)=d,

e∈h−1(h(d))

[h(d) = p]zd

∑
d

[h(d) = p]xd

∑
d
[h(d) = p][h(e) = p]xdze
∑

(cid:33)(cid:32)

xdze

efficient learning 177

(14.10)

(14.11)

(14.12)

(14.13)

(14.14)

This hash kernel has the form of a linear kernel plus a small number
of quadratic terms. The particular quadratic terms are exactly those
given by collisions of the hash function.

There are two things to notice about this. The ﬁrst is that collisions

might not actually be bad things! In a sense, they’re giving you a
little extra representational power. In particular, if the hash function
happens to select out feature pairs that beneﬁt from being paired,
then you now have a better representation. The second is that even if
this doesn’t happen, the quadratic term in the kernel has only a small
effect on the overall prediction. In particular, if you assume that your
hash function is pairwise independent (a common assumption of
hash functions), then the expected value of this quadratic term is zero,
and its variance decreases at a rate of O(P−2). In other words, if you
choose P ≈ 100, then the variance is on the order of 0.0001.

14.5 Further Reading

TODO further reading

15 | UNSUPERVISED LEARNING

Learning Objectives:
• Explain the difference between

linear and non-linear dimensionality
reduction.

• Relate the view of PCA as maximiz-

ing variance with the view of it as
minimizing reconstruction error.

• Implement latent semantic analysis

for text data.

• Motivate manifold learning from the

perspective of reconstruction error.
• Understand K-means clustering as

distance minimization.

• Explain the importance of initial-

ization in k-means and furthest-ﬁrst
heuristic.

• Implement agglomerative clustering.
• Argue whether spectral cluster-
ing is a clustering algorithm or a
dimensionality reduction algorithm.

Dependencies:

[My father] advised me to sit every few months in my reading
chair for an entire evening, close my eyes and try to think of new
problems to solve. I took his advice very seriously and have been
glad ever since that he did.
– Luis Walter Alvarez

If you have access to labeled training data, you know what
to do. This is the “supervised” setting, in which you have a teacher
telling you the right answers. Unfortunately, ﬁnding such a teacher
is often difﬁcult, expensive, or down right impossible. In those cases,
you might still want to be able to analyze your data, even though you
do not have labels.

Unsupervised learning is learning without a teacher. One basic

thing that you might want to do with data is to visualize it. Sadly, it
is difﬁcult to visualize things in more than two (or three) dimensions,
and most data is in hundreds of dimensions (or more). Dimension-
ality reduction is the problem of taking high dimensional data and
embedding it in a lower dimension space. Another thing you might
want to do is automatically derive a partitioning of the data into
clusters. You’ve already learned a basic approach for doing this: the
k-means algorithm (Chapter 3). Here you will analyze this algorithm
to see why it works. You will also learn more advanced clustering
approaches.

15.1 K-Means Clustering, Revisited

The K-means clustering algorithm is re-presented in Algorithm 15.1.

There are two very basic questions about this algorithm: (1) does it
converge (and if so, how quickly); (2) how sensitive it is to initializa-
tion? The answers to these questions, detailed below, are: (1) yes it
converges, and it converges very quickly in practice (though slowly
in theory); (2) yes it is sensitive to initialization, but there are good
ways to initialize it.

Consider the question of convergence. The following theorem

states that the K-Means algorithm converges, though it does not say
how quickly it happens. The method of proving the convergence is
to specify a clustering quality objective function, and then to show
that the K-Means algorithm converges to a (local) optimum of that
objective function. The particular objective function that K-Means

Algorithm 35 K-Means(D, K)
1: for k = 1 to K do
µk ← some random location
2:
3: end for
4: repeat
5:

for n = 1 to N do

zn ← argmink ||µk − xn||

end for
for k = 1 to K do

µk ← mean({ xn : zn = k })

6:

7:

8:

9:

end for

10:
11: until converged
12: return z

unsupervised learning 179

// randomly initialize mean for kth cluster

// assign example n to closest center

// re-estimate mean of cluster k

// return cluster assignments

is optimizing is the sum of squared distances from any data point to its
assigned center. This is a natural generalization of the deﬁnition of a
mean: the mean of a set of points is the single point that minimizes
the sum of squared distances from the mean to every point in the
data. Formally, the K-Means objective is:
= ∑
k

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)xn − µzn

L(z, µ; D) = ∑
n

||xn − µk||2

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2

∑
n:zn=k

(15.1)

Theorem 16 (K-Means Convergence Theorem). For any dataset D and
any number of clusters K, the K-means algorithm converges in a ﬁnite num-
ber of iterations, where convergence is measured by L ceasing the change.
Proof of Theorem 16. The proof works as follows. There are only two
points in which the K-means algorithm changes the values of µ or z:
lines 6 and 9. We will show that both of these operations can never
increase the value of L. Assuming this is true, the rest of the argu-
ment is as follows. After the ﬁrst pass through the data, there are
are only ﬁnitely many possible assignments to z and µ, because z is
discrete and because µ can only take on a ﬁnite number of values:
means of some subset of the data. Furthermore, L is lower-bounded
by zero. Together, this means that L cannot decrease more than a
ﬁnite number of times. Thus, it must stop decreasing at some point,
and at that point the algorithm has converged.
It remains to show that lines 6 and 9 decrease L. For line 6, when
looking at example n, suppose that the previous value of zn is a and
the new value is b. It must be the case that ||xn − µb|| ≤ ||xn − µb||.
Thus, changing from a to b can only decrease L. For line 9, consider
the second form of L. Line 9 computes µk as the mean of the data
points for which zn = k, which is precisely the point that minimizes
squared sitances. Thus, this update to µk can only decrease L.

There are several aspects of K-means that are unfortunate. First,
the convergence is only to a local optimum of L. In practice, this

180 a course in machine learning

means that you should usually run it 10 times with different initial-
izations and pick the one with minimal resulting L. Second, one
can show that there are input datasets and initializations on which
it might take an exponential amount of time to converge. Fortu-
nately, these cases almost never happen in practice, and in fact it has
recently been shown that (roughly) if you limit the ﬂoating point pre-
cision of your machine, K-means will converge in polynomial time
(though still only to a local optimum), using techniques of smoothed
analysis.

The biggest practical issue in K-means is initialization. If the clus-
ter means are initialized poorly, you often get convergence to uninter-
esting solutions. A useful heuristic is the furthest-ﬁrst heuristic. This
gives a way to perform a semi-random initialization that attempts to
pick initial means as far from each other as possible. The heuristic is
sketched below:
1. Pick a random example m and set µ1 = xm.
2. For k = 2 . . . K:

(a) Find the example m that is as far as possible from all previ-

ously selected means; namely: m = arg maxm mink(cid:48)<k ||xm − µk(cid:48)||2
and set µk = xm

In this heuristic, the only bit of randomness is the selection of the
ﬁrst data point. After that, it is completely deterministic (except in
the rare case that there are multiple equidistant points in step 2a). It
is extremely important that when selecting the 3rd mean, you select
that point that maximizes the minimum distance to the closest other
mean. You want the point that’s as far away from all previous means
as possible.

The furthest-ﬁrst heuristic is just that: a heuristic. It works very

well in practice, though can be somewhat sensitive to outliers (which
will often get selected as some of the initial means). However, this
outlier sensitivity is usually reduced after one iteration through the
K-means algorithm. Despite being just a heuristic, it is quite useful in
practice.

You can turn the heuristic into an algorithm by adding a bit more

randomness. This is the idea of the K-means++ algorithm, which
is a simple randomized tweak on the furthest-ﬁrst heuristic. The
idea is that when you select the kth mean, instead of choosing the
absolute furthest data point, you choose a data point at random, with
probability proportional to its distance squared. This is made formal
in Algorithm 15.1.

If you use K-means++ as an initialization for K-means, then you
are able to achieve an approximation guarantee on the ﬁnal value

unsupervised learning 181

Algorithm 36 K-Means++(D, K)
1: µ1 ← xm for m chosen uniformly at random // randomly initialize ﬁrst point
2: for k = 2 to K do
3:

// compute distances
// normalize to probability distribution
// pick an example at random

4:

5:

dn ← mink(cid:48)<k ||xn − µk(cid:48)||2, ∀n
p ← 1
∑n nd
m ← random sample from p
µk ← xm

d

6:
7: end for
8: run K-Means using µ as initial centers

of the objective. This doesn’t tell you that you will reach the global
optimum, but it does tell you that you will get reasonably close. In
particular, if ˆL is the value obtained by running K-means++, then this
will not be “too far” from L(opt), the true global minimum.
Theorem 17 (K-means++ Approximation Guarantee). The expected
value of the objective returned by K-means++ is never more than O(log K)
from optimal and can be as close as O(1) from optimal. Even in the former
case, with 2K random restarts, one restart will be O(1) from optimal (with

high probability). Formally: E(cid:2) ˆL(cid:3) ≤ 8(log K + 2)L(opt). Moreover, if the
data is “well suited” for clustering, then E(cid:2) ˆL(cid:3) ≤ O(1)L(opt).

The notion of “well suited” for clustering informally states that
the advantage of going from K − 1 clusters to K clusters is “large.”
Formally, it means that LK
(opt) is the
optimal value for clustering with K clusters, and  is the desired
degree of approximation. The idea is that if this condition does not
hold, then you shouldn’t bother clustering the data.

(opt) ≤ 2LK−1

(opt), where LK

One of the biggest practical issues with K-means clustering is
“choosing K.” Namely, if someone just hands you a dataset and
asks you to cluster it, how many clusters should you produce? This
is difﬁcult, because increasing K will always decrease LK
(opt) (until
K > N), and so simply using L as a notion of goodness is insufﬁ-
cient (analogous to overﬁtting in a supervised setting). A number
of “information criteria” have been proposed to try to address this
problem. They all effectively boil down to “regularizing” K so that
the model cannot grow to be too complicated. The two most popular
are the Bayes Information Criteria (BIC) and the Akaike Information
Criteria (AIC), deﬁned below in the context of K-means:

BIC:

AIC:

arg min

K

arg min

K

ˆLK + K log D
ˆLK + 2KD

(15.2)
(15.3)

The informal intuition behind these criteria is that increasing K is
going to make LK go down. However, if it doesn’t go down “by
enough” then it’s not worth doing. In the case of BIC, “by enough”

182 a course in machine learning

means by an amount proportional to log D; in the case of AIC, it’s
proportional to 2D. Thus, AIC provides a much stronger penalty for
many clusters than does BIC, especially in high dimensions.

A more formal intuition for BIC is the following. You ask yourself

the question “if I wanted to send this data across a network, how
many bits would I need to send?” Clearly you could simply send
all of the N examples, each of which would take roughly log D bits
to send. This gives N log D to send all the data. Alternatively, you
could ﬁrst cluster the data and send the cluster centers. This will take
K log D bits. Then, for each data point, you send its center as well as
its deviation from that center. It turns out this will cost exactly ˆLK
bits. Therefore, the BIC is precisely measuring how many bits it will
take to send your data using K clusters. The K that minimizes this
number of bits is the optimal value.

15.2 Linear Dimensionality Reduction

Dimensionality reduction is the task of taking a dataset in high di-
mensions (say 10000) and reducing it to low dimensions (say 2) while
retaining the “important” characteristics of the data. Since this is
an unsupervised setting, the notion of important characteristics is
difﬁcult to deﬁne.

Consider the dataset in Figure 15.1, which lives in high dimensions

(two) and you want to reduce to low dimensions (one). In the case
of linear dimensionality reduction, the only thing you can do is to
project the data onto a vector and use the projected distances as the
embeddings. Figure 15.2 shows a projection of this data onto the
vector that points in the direction of maximal variance of the original
dataset. Intuitively, this is a reasonable notion of importance, since
this is the direction in which most information is encoded in the data.

For the rest of this section, assume that the data is centered:
namely, the mean of all the data is at the origin. (This will sim-
ply make the math easier.) Suppose the two dimensional data is
x1, . . . , xN and you’re looking for a vector u that points in the direc-
tion of maximal variance. You can compute this by projecting each
point onto u and looking at the variance of the result. In order for
the projection to make sense, you need to constrain ||u||2 = 1. In
this case, the projections are x1 · u, x2 · u, . . . , xN · u. Call these values
p1, . . . , pN.
The goal is to compute the variance of the {pn}s and then choose
u to maximize this variance. To compute the variance, you ﬁrst need
to compute the mean. Because the mean of the xns was zero, the

Figure 15.1: unsup:pcadata: Data in
two dimensions

Figure 15.2: unsup:pcadata2: Projection
of that data down to one dimension by
PCA

MATH REVIEW | EIGENVALUES AND EIGENVECTORS
todo the usual...

unsupervised learning 183

Figure 15.3:

mean of the ps is also zero. This can be seen as follows:

(cid:32)

(cid:33)

∑
n

pn = ∑
n

xn · u =

∑
n

xn

· u = 0 · u = 0

(15.4)

The variance of the {pn} is then just ∑n p2
n. Finding the optimal
u (from the perspective of variance maximization) reduces to the
following optimization problem:

max

u

(xn · u)2

∑
n

subj. to

||u||2 = 1

(15.5)

In this problem it becomes apparent why keeping u unit length is
important: if not, u would simply stretch to have inﬁnite length to
maximize the objective.
It is now helpful to write the collection of datapoints xn as a N×
D matrix X. If you take this matrix X and multiply it by u, which
has dimensions D×1, you end up with a N×1 vector whose values
are exactly the values p. The objective in Eq (15.5) is then just the
squared norm of p. This simpliﬁes Eq (15.5) to:

||Xu||2

subj. to

||u||2 − 1 = 0

max

u

(15.6)

where the constraint has been rewritten to make it amenable to con-
structing the Lagrangian. Doing so and taking gradients yields:

(cid:17)

L(u, λ) = ||Xu||2 − λ

(cid:16)||u||2 − 1
(cid:17)
∇uL = 2X(cid:62)Xu − 2λu
=⇒ λu =
u

X(cid:62)X

(cid:16)

(15.7)
(15.8)
(15.9)

You can solve this expression (λu = X(cid:62)Xu) by computing the ﬁrst
eigenvector and eigenvalue of the matrix X(cid:62)X.

This gives you the solution to a projection into a one-dimensional

space. To get a second dimension, you want to ﬁnd a new vector v on
which the data has maximal variance. However, to avoid redundancy,
you want v to be orthogonal to u; namely u · v = 0. This gives:

||Xv||2

subj. to

||v||2 = 1, and u · v = 0

(15.10)

max

v

Following the same procedure as before, you can construct a La-

184 a course in machine learning

Algorithm 37 PCA(D, K)
1: µ ← mean(X)

X − µ1(cid:62)(cid:17) (cid:62)(cid:16)

2: D ←(cid:16)

X − µ1(cid:62)(cid:17)

3: {λk, uk} ← top K eigenvalues/eigenvectors of D
4: return (X − µ1) U

// compute data mean for centering
// compute covariance, 1 is a vector of ones

grangian and differentiate:

L(v, λ1, λ2) = ||Xv||2 − λ1

(cid:17) − λ2u · v

(cid:16)||v||2 − 1
(cid:17)

∇uL = 2X(cid:62)Xv − 2λ1v − λ2u
v − λ2
=⇒ λ1v =
u
2

X(cid:62)X

(cid:16)

// project data using U

(15.11)
(15.12)
(15.13)

However, you know that u is the ﬁrst eigenvector of X(cid:62)X, so the
solution to this problem for λ1 and v is given by the second eigen-
value/eigenvector pair of X(cid:62)X.

Repeating this analysis inductively tells you that if you want to

project onto K mutually orthogonal dimensions, you simply need to
take the ﬁrst K eigenvectors of the matrix X(cid:62)X. This matrix is often
called the data covariance matrix because [X(cid:62)X]i,j = ∑n ∑m xn,ixm,j,
which is the sample covariance between features i and j.

This leads to the technique of principle components analysis,
or PCA. For completeness, the is depicted in Algorithm 15.2. The
important thing to note is that the eigenanalysis only gives you the
projection directions. It does not give you the embedded data. To
embed a data point x you need to compute its embedding as (cid:104)x ·
u1, x · u2, . . . , x · uK(cid:105). If you write U for the D×K matrix of us, then this
is just XU.

There is an alternative derivation of PCA that can be informative,

based on reconstruction error. Consider the one-dimensional case
again, where you are looking for a single projection direction u. If
you were to use this direction, your projected data would be Z = Xu.
Each Zn gives the position of the nth datapoint along u. You can
project this one-dimensional data back into the original space by
multiplying it by u(cid:62). This gives you reconstructed values Zu(cid:62). Instead
of maximizing variance, you might instead want to minimize the
reconstruction error, deﬁned by:

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)X − Zu(cid:62)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)X − Xuu(cid:62)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2

=

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)Xuu(cid:62)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2 − 2X(cid:62)Xuu(cid:62)

= ||X||2 +

deﬁnition of Z

(15.14)

quadratic rule

(15.15)

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)Xuu(cid:62)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2 − 2u(cid:62)X(cid:62)Xu

= ||X||2 +

= ||X||2 + ||X||2 − 2u(cid:62)X(cid:62)Xu

unsupervised learning 185

quadratic rule

(15.16)

u is a unit vector

(15.17)

= C − 2||Xu||2

join constants, rewrite last term

(15.18)
Minimizing this ﬁnal term is equivalent to maximizing ||Xu||2, which
is exactly the form of the maximum variance derivation of PCA.
Thus, you can see that maximizing variance is identical to minimiz-
ing reconstruction error.

The same question of “what should K be” arises in dimension-
ality reduction as in clustering. If the purpose of dimensionality
reduction is to visualize, then K should be 2 or 3. However, an alter-
native purpose of dimensionality reduction is to avoid the curse of
dimensionality. For instance, even if you have labeled data, it might
be worthwhile to reduce the dimensionality before applying super-
vised learning, essentially as a form of regularization. In this case,
the question of an optimal K comes up again. In this case, the same
criteria (AIC and BIC) that can be used for clustering can be used for
PCA. The only difference is the quality measure changes from a sum
of squared distances to means (for clustering) to a sum of squared
distances to original data points (for PCA). In particular, for BIC you
get the reconstruction error plus K log D; for AIC, you get the recon-
struction error plus 2KD.

15.3 Autoencoders

TODO

15.4 Further Reading

TODO

16 | EXPECTATION MAXIMIZATION

Learning Objectives:
• Explain the relationship between
parameters and hidden variables.

• Construct generative stories for

clustering and dimensionality
reduction.

• Draw a graph explaining how EM

works by constructing convex lower
bounds.

• Implement EM for clustering with

mixtures of Gaussians, and contrast-
ing it with k-means.

• Evaluate the differences betweem

EM and gradient descent for hidden
variable models.

Dependencies:

A hen is only an egg’s way of making another egg. – Samuel Butler

Suppose you were building a naive Bayes model for a text cate-
gorization problem. After you were done, your boss told you that it
became prohibitively expensive to obtain labeled data. You now have
a probabilistic model that assumes access to labels, but you don’t
have any labels! Can you still do something?

Amazingly, you can. You can treat the labels as hidden variables,
and attempt to learn them at the same time as you learn the param-
eters of your model. A very broad family of algorithms for solving
problems just like this is the expectation maximization family. In this
chapter, you will derive expectation maximization (EM) algorithms
for clustering and dimensionality reduction, and then see why EM
works.

16.1 Grading an Exam without an Answer Key

Alice’s machine learning professor Carlos gives out an exam that
consists of 50 true/false questions. Alice’s class of 100 students takes
the exam and Carlos goes to grade their solutions. If Carlos made
an answer key, this would be easy: he would just count the fraction
of correctly answered questions each student got, and that would be
their score. But, like many professors, Carlos was really busy and
didn’t have time to make an answer key. Can he still grade the exam?

There are two insights that suggest that he might be able to. Sup-
pose he know ahead of time that Alice was an awesome student, and
is basically guaranteed to get 100% on the exam. In that case, Carlos
can simply use Alice’s answers as the ground truth. More generally,
if Carlos assumes that on average students are better than random
guessing, he can hope that the majority answer for each question is
likely to be correct. Combining this with the previous insight, when
doing the “voting”, he might want to pay more attention to the an-
swers of the better students.

To be a bit more pedantic, suppose there are N = 100 students

and M = 50 questions. Each student n has a score sn, between 0 and

expectation maximization 187

1 that denotes how well they do on the exam. The score is what we
really want to compute. For each question m and each student n, the
student has provided an answer an,m, which is either zero or one.
There is also an unknown ground truth answer for each question m,
which we’ll call tm, which is also either zero or one.

As a starting point, let’s consider a simple heuristic and then com-
plexify it. The heuristic is the “majority vote” heuristic and works as
follows. First, we estimate tm as the most common answer for ques-
tion m: tm = argmaxt ∑n 1[an,m = t]. Once we have a guess for each
true answer, we estimate each students’ score as how many answers
M ∑m 1[an,m = tm].
they produced that match this guessed key: sn = 1
Once we have these scores, however, we might want to trust some

of the students more than others. In particular, answers from stu-
dents with high scores are perhaps more likely to be correct, so we
can recompute the ground truth, according to weighted votes. The
weight of the votes will be precisely the score the corresponding each
student:

tm = argmax

t

∑
n

sn1[an,m = t]

(16.1)

You can recognize this as a chicken and egg problem. If you knew the
student’s scores, you could estimate an answer key. If you had an
answer key, you could compute student scores. A very common
strategy in computer science for dealing with such chicken and egg
problems is to iterate. Take a guess at the ﬁrst, compute the second,
recompute the ﬁrst, and so on.

In order to develop this idea formally, we have to case the prob-
lem in terms of a probabilistic model with a generative story. The
generative story we’ll use is:
1. For each question m, choose a true answer tm ∼ Ber(0.5)
2. For each student n, choose a score sn ∼ Uni(0, 1)
3. For each question m and each student n, choose an answer

an,m ∼ Ber(sn)tmBer(1 − sn)1−tm
In the ﬁrst step, we generate the true answers independently by
ﬂipping a fair coin. In the second step, each students’ overall score
is determined to be a uniform random number between zero and
one. The tricky step is step three, where each students’ answer is
generated for each question. Consider student n answering question
m, and suppose that sn = 0.9. If tm = 1, then an,m should be 1 (i.e.,
correct) 90% of the time; this can be accomplished by drawing the an-
swer from Ber(0.9). On the other hand, if tm = 0, then an,m should 1
(i.e., incorrect) 10% of the time; this can be accomplished by drawing

188 a course in machine learning

the answer from Ber(0.1). The exponent in step 3 selects which of two
Bernoulli distributions to draw from, and then implements this rule.

This can be translated into the following likelihood:

(cid:35)

(cid:34)

(cid:35)

0.5tm0.51−tm

×

∏
n

1

(cid:34)

=

p(a, t, s)
∏
m
×

(cid:34)

(1 − sn)(1−an,m)tm

(1 − sn)an,m(1−tm)(cid:105)

san,mtm
n

∏
∏
n
m
s(1−an,m)(1−tm)
n
∏
= 0.5M∏
m
n

san,mtm
n

(1 − sn)(1−an,m)tms(1−an,m)(1−tm)

n

(16.2)
(1 − sn)an,m(1−tm)
(16.3)

Suppose we knew the true lables t. We can take the log of this
likelihood and differentiate it with respect to the score sn of some
student (note: we can drop the 0.5M term because it is just a con-
stant):

(cid:104)

log p(a, t, s) = ∑
n

∑
m

an,mtm log sn + (1 − an,m)(1 − tm) log(sn)
+ (1 − an,m)tm log(1 − sn) + an,m(1 − tm) log(1 − sn)
(16.4)

(cid:104) an,mtm + (1 − an,m)(1 − tm)

(cid:105)

− (1 − an,m)tm + an,m(1 − tm)

(cid:105)

∂ log p(a, t, s)

∂sn

= ∑
m

sn

1 − sn
(16.5)

(16.6)

(16.7)

(16.8)

(16.9)

The derivative has the form A
sn
solve for sn, we get an optimum of sn = A

− B

1−sn . If we set this equal to zero and

A+B . In this case:

(cid:2)an,mtm + (1 − an,m)(1 − tm)(cid:3)
(cid:2)(1 − an,m)tm + an,m(1 − tm)(cid:3)
(cid:2)1(cid:3) = M
(cid:2)an,mtm + (1 − an,m)(1 − tm)(cid:3)

A = ∑
m
B = ∑
m
A + B = ∑
m

sn =

1
M

∑
m

Putting this together, we get:

In the case of known ts, this matches exactly what we had in the
heuristic.

However, we do not know t, so instead of using the “true” val-
ues of t, we’re going to use their expectations. In particular, we will
compute sn by maximizing its likelihood under the expected values

expectation maximization 189

of t, hence the name expectation maximization. If we are going
to compute expectations of t, we have to say: expectations accord-
ing to which probability distribution? We will use the distribution
p(tm | a, s). Let ˜tm denote Etm∼p(tm | a,s)[tm]. Because tm is a bi-
nary variable, its expectation is equal to it’s probability; namely:
˜tm = p(tm | a, s).

How can we compute this? We will compute C = p(tm = 1, a, s)
and D = p(tm = 0, a, s) and then compute ˜tm = C/(C + D). The
computation is straightforward:

C = 0.5 ∏
n
D = 0.5 ∏
n

san,m
n

s1−an,m

n

(1 − sn)1−an,m = 0.5 ∏
an,m=1
(1 − sn)an,m = 0.5 ∏
an,m=1

n:

n:

(1 − sn)

(16.10)

sn

(16.11)

sn ∏
n:
an,m=0

(1 − sn) ∏
an,m=0

n:

If you inspect the value of C, it is basically “voting” (in a product
form, not a sum form) the scores of those students who agree that the
answer is 1 with one-minus-the-score of those students who do not.
The value of D is doing the reverse. This is a form of multiplicative
voting, which has the effect that if a given student has a perfect score
of 1.0, their results will carry the vote completely.

We now have a way to:

1. Compute expected ground truth values ˜tm, given scores.
2. Optimize scores sn given expected ground truth values.

The full solution is then to alternate between these two. You can
start by initializing the ground truth values at the majority vote (this
seems like a safe initialization). Given those, compute new scores.
Given those new scores, compute new ground truth values. And
repeat until tired.

In the next two sections, we will consider a more complex unsu-
pervised learning model for clustering, and then a generic mathe-
matical framework for expectation maximization, which will answer
questions like: will this process converge, and, if so, to what?

16.2 Clustering with a Mixture of Gaussians

In Chapter 9, you learned about probabilitic models for classiﬁcation
based on density estimation. Let’s start with a fairly simple classiﬁca-
tion model that assumes we have labeled data. We will shortly remove
this assumption. Our model will state that we have K classes, and
data from class k is drawn from a Gaussian with mean µk and vari-
ance σ2
k . The choice of classes is parameterized by θ. The generative
story for this model is:

190 a course in machine learning

1. For each example n = 1 . . . N:
(a) Choose a label yn ∼ Disc(θ)
(b) Choose example xn ∼ Nor(µyn, σ2
yn )

This generative story can be directly translated into a likelihood as
before:

p(D) = ∏
n

(cid:122)

=

∏
n

Mult(yn | θ)Nor(xn | µyn, σ2
yn )
(cid:34)

for each example

(cid:125)(cid:124)

(cid:105)− D

2πσ2
yn

2 exp

θyn(cid:124)(cid:123)(cid:122)(cid:125)

choose label

(cid:104)
(cid:124)

− 1
2σ2
yn

(cid:123)(cid:122)

choose feature values

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)xn − µyn

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2

(16.12)

(16.13)

(cid:123)
(cid:35)
(cid:125)

If you had access to labels, this would be all well and good, and
you could obtain closed form solutions for the maximum likelihood
estimates of all parameters by taking a log and then taking gradients
of the log likelihood:

θk = fraction of training examples in class k

=

1
N

∑
n

[yn = k]

µk = mean of training examples in class k

=

∑n[yn = k]xn
∑n[yn = k]

σ2
k = variance of training examples in class k

∑n[yn = k] ||xn − µk||

∑n[yn = k]

=

(16.14)

(16.15)

(16.16)

?

You should be able to derive the
maximum likelihood solution re-
sults formally by now.

Suppose that you don’t have labels. Analogously to the K-means
algorithm, one potential solution is to iterate. You can start off with
guesses for the values of the unknown variables, and then iteratively
improve them over time. In K-means, the approach was the assign
examples to labels (or clusters). This time, instead of making hard
assignments (“example 10 belongs to cluster 4”), we’ll make soft as-
signments (“example 10 belongs half to cluster 4, a quarter to cluster
2 and a quarter to cluster 5”). So as not to confuse ourselves too
much, we’ll introduce a new variable, zn = (cid:104)zn,1, . . . , zn,K (that sums
to one), to denote a fractional assignment of examples to clusters.

This notion of soft-assignments is visualized in Figure 16.1. Here,
we’ve depicted each example as a pie chart, and it’s coloring denotes
the degree to which it’s been assigned to each (of three) clusters. The
size of the pie pieces correspond to the zn values.

Figure 16.1: em:piecharts: A ﬁgure
showing pie charts

Formally, zn,k denotes the probability that example n is assigned to

cluster k:

expectation maximization 191

zn,k = p(yn = k | xn)
p(yn = k, xn)

=

=

1
Zn

p(xn)
Mult(k | θ)Nor(xn | µk, σ2
k )

(16.17)

(16.18)

(16.19)

Here, the normalizer Zn is to ensure that zn sums to one.

Given a set of parameters (the θs, µs and σ2s), the fractional as-
signments zn,k are easy to compute. Now, akin to K-means, given
fractional assignments, you need to recompute estimates of the
model parameters. In analogy to the maximum likelihood solution
(Eqs (??)-(??)), you can do this by counting fractional points rather
than full points. This gives the following re-estimation updates:

θk = fraction of training examples in class k

=

1
N

∑
n

zn,k

µk = mean of fractional examples in class k

=

∑n zn,kxn
∑n zn,k

σ2
k = variance of fractional examples in class k

∑n zn,k ||xn − µk||

=

∑n zn,k

(16.20)

(16.21)

(16.22)

All that has happened here is that the hard assignments “[yn = k]”
have been replaced with soft assignments “zn,k”. As a bit of fore-
shadowing of what is to come, what we’ve done is essentially replace
known labels with expected labels, hence the name “expectation maxi-
mization.”

Putting this together yields Algorithm 16.2. This is the GMM
(“Gaussian Mixture Models”) algorithm, because the probabilitic
model being learned describes a dataset as being drawn from a mix-
ture distribution, where each component of this distribution is a
Gaussian.

Just as in the K-means algorithm, this approach is succeptible to
local optima and quality of initialization. The heuristics for comput-
ing better initializers for K-means are also useful here.

16.3 The Expectation Maximization Framework

At this point, you’ve seen a method for learning in a particular prob-
abilistic model with hidden variables. Two questions remain: (1) can

?

Aside from the fact that GMMs
use soft assignments and K-means
uses hard assignments, there are
other differences between the two
approaches. What are they?

// randomly initialize mean for kth cluster
// initialize variances
// each cluster equally likely a priori

(cid:2)2πσ2

(cid:3)− D

for k = 1 to K do

zn,k ← θk
(unnormalized) fractional assignments

2 exp

2σ2
k

k

(cid:104)− 1

||xn − µk||2(cid:105)

// compute

192 a course in machine learning

Algorithm 38 GMM(X, K)

3:

1: for k = 1 to K do
2:

µk ← some random location
k ← 1
σ2
θk ← 1/K
4:
5: end for
6: repeat
7:

for n = 1 to N do

8:

9:

10:

11:

12:

13:

14:

15:

16:

end for
zn ← 1
∑k zn,k

zn

end for
for k = 1 to K do
θk ← 1
N ∑n zn,k
µk ← ∑n zn,kxn
∑n zn,k
k ← ∑n zn,k||xn−µk||
σ2
∑n zn,k

end for

17:
18: until converged
19: return z

// normalize fractional assignments

// re-estimate prior probability of cluster k
// re-estimate mean of cluster k
// re-estimate variance of cluster k

// return cluster assignments

you apply this idea more generally and (2) why is it even a reason-
able thing to do? Expectation maximization is a family of algorithms
for performing maximum likelihood estimation in probabilistic mod-
els with hidden variables.
The general ﬂavor of how we will proceed is as follows. We want
to maximize the log likelihood L, but this will turn out to be difﬁ-
cult to do directly. Instead, we’ll pick a surrogate function ˜L that’s a
lower bound on L (i.e., ˜L ≤ L everywhere) that’s (hopefully) easier
to maximize. We’ll construct the surrogate in such a way that increas-
ing it will force the true likelihood to also go up. After maximizing
˜L, we’ll construct a new lower bound and optimize that. This process
is shown pictorially in Figure 16.2.

To proceed, consider an arbitrary probabilistic model p(x, y | θ),
where x denotes the observed data, y denotes the hidden data and
θ denotes the parameters. In the case of Gaussian Mixture Models,
x was the data points, y was the (unknown) labels and θ included
the cluster prior probabilities, the cluster means and the cluster vari-
ances. Now, given access only to a number of examples x1, . . . , xN,
you would like to estimate the parameters (θ) of the model.

Probabilistically, this means that some of the variables are un-
known and therefore you need to marginalize (or sum) over their
possible values. Now, your data consists only of X = (cid:104)x1, x2, . . . , xN(cid:105),

Figure 16.2: em:lowerbound: A ﬁgure
showing successive lower bounds

expectation maximization 193

not the (x, y) pairs in D. You can then write the likelihood as:

p(X | θ) = ∑
y1

∑
y2

· · · ∑
yN

p(X, y1, y2, . . . yN | θ)

= ∑
y1

∑
y2

· · · ∑
yN

∏
n

p(xn, yn | θ)

= ∏
n

∑
yn

p(xn, yn | θ)

marginalization

(16.23)

examples are independent

(16.24)

algebra

(16.25)

At this point, the natural thing to do is to take logs and then start
taking gradients. However, once you start taking logs, you run into a
problem: the log cannot eat the sum!
p(xn, yn | θ)

(16.26)

L(X | θ) = ∑
n

log ∑
yn

The next step is to apply the somewhat strange, but strangely

Namely, the log gets “stuck” outside the sum and cannot move in to
decompose the rest of the likelihood term!
useful, trick of multiplying by 1. In particular, let q(·) be an arbitrary
probability distribution. We will multiply the p(. . . ) term above by
q(yn)/q(yn), a valid step so long as q is never zero. This leads to:

L(X | θ) = ∑
n

log ∑
yn

q(yn)

p(xn, yn | θ)

q(yn)

(16.27)

We will now construct a lower bound using Jensen’s inequality.
This is a very useful (and easy to prove!) result that states that
f (∑i λixi) ≥ ∑i λi f (xi), so long as (a) λi ≥ 0 for all i, (b) ∑i λi = 1,
and (c) f is concave. If this looks familiar, that’s just because it’s a
direct result of the deﬁnition of concavity. Recall that f is concave if
f (ax + by) ≥ a f (x) + b f (x) whenever a + b = 1.

You can now apply Jensen’s inequality to the log likelihood by
identifying the list of q(yn)s as the λs, log as f (which is, indeed,
concave) and each “x” as the p/q term. This yields:

?

Prove Jensen’s inequality using the
deﬁnition of concavity and induc-
tion.

p(xn, yn | θ)

q(yn) log
q(yn) log p(xn, yn | θ) − q(yn) log q(yn)

q(yn)

L(X | θ) ≥ ∑
(cid:104)
n
= ∑
n
(cid:44) ˜L(X | θ)

∑
yn
∑
yn

(cid:105)

(16.28)

(16.29)

(16.30)

Note that this inequality holds for any choice of function q, so long as
its non-negative and sums to one. In particular, it needn’t even by the

194 a course in machine learning

same function q for each n. We will need to take advantage of both of
these properties.
We have succeeded in our ﬁrst goal: constructing a lower bound
on L. When you go to optimize this lower bound for θ, the only part
that matters is the ﬁrst term. The second term, q log q, drops out as a
function of θ. This means that the the maximization you need to be
able to compute, for ﬁxed qns, is:

θ(new) ← arg max

θ

∑
n

∑
yn

qn(yn) log p(xn, yn | θ)

(16.31)

This is exactly the sort of maximization done for Gaussian mixture
models when we recomputed new means, variances and cluster prior
probabilities.

The second question is: what should qn(·) actually be? Any rea-

sonable q will lead to a lower bound, so in order to choose one q over
another, we need another criterion. Recall that we are hoping to max-
imize L by instead maximizing a lower bound. In order to ensure
that an increase in the lower bound implies an increase in L, we need
to ensure that L(X | θ) = ˜L(X | θ). In words:
˜L should be a lower
bound on L that makes contact at the current point, θ.

16.4 Further Reading

TODO further reading

17 | STRUCTURED PREDICTION

Learning Objectives:
• Recognize when a problem should
be solved using a structured predic-
tion technique.

• Implement the structured perceptron

algorithm for sequence labeling.

• Map “argmax” problems to integer

linear programs.

• Augment the structured perceptron

with losses to derive structured
SVMs.

Dependencies:

It is often the case that instead of predicting a single output, you
need to predict multiple, correlated outputs simultaneously. In nat-
ural language processing, you might want to assign a syntactic label
(like noun, verb, adjective, etc.) to words in a sentence: there is clear
correlation among these labels. In computer vision, you might want
to label regions in an image with object categories; again, there is
correlation among these regions. The branch of machine learning that
studies such questions is structured prediction.

In this chapter, we will cover two of the most common algorithms

for structured prediction: the structured perceptron and the struc-
tured support vector machine. We will consider two types of struc-
ture. The ﬁrst is the “sequence labeling” problem, typiﬁed by the
natural language processing example above, but also common in
computational biology (labeling amino acids in DNA) and robotics
(labeling actions in a sequence). For this, we will develop specialized
prediction algorithms that take advantage of the sequential nature
of the task. We will also consider more general structures beyond
sequences, and discuss how to cast them in a generic optimization
framework: integer linear programming (or ILP).

The general framework we will explore is that of jointly scoring

input/output conﬁgurations. We will construct algorithms that learn a
function s(x, ˆy) (s for “score”), where x is an input (like an image)
and ˆy is some predicted output (like a segmentation of that image).
For any given image, there are a lot of possible segmentations (i.e.,
a lot of possible ˆys), and the goal of s is to rank them in order of
“how good” they are: how compatible they are with the input x. The
most important thing is that the scoring function s ranks the true
segmentation y higher than any other imposter segmentation ˆy. That
is, we want to ensure that s(x, y) > s(x, ˆy) for all ˆy (cid:54)= y. The main
challenge we will face is how to do this efﬁciently, given that there are
so many imposter ˆys.

196 a course in machine learning

17.1 Multiclass Perceptron

In order to build up to structured problems, let’s begin with a simpli-
ﬁed by pedagogically useful stepping stone: multiclass classiﬁcation
with a perceptron. As discussed earlier, in multiclass classiﬁcation we
have inputs x ∈ RD and output labels y ∈ {1, 2, . . . , K}. Our goal
is to learn a scoring function s so that s(x, y) > s(x, ˆy) for all ˆy (cid:54)= y,
where y is the true label and ˆy is an imposter label. The general form
of scoring function we consider is a linear function of a joint feature
vector φ(x, y):

s(x, y) = w · φ(x, y)

(17.1)

Here, the features φ(x, y) should denote how “compatible” the input
x is with the label y. We keep track of a single weight vector w that
learns how to weigh these different “compatibility” features.

A natural way to represent φ, if you know nothing else about

the problem, is an outer product between x and the label space. This
yields the following representation:

(cid:68)

φ(x, k) =

(cid:124)

(cid:123)(cid:122)

0, 0, . . . , 0
D(k−1) zeros

(cid:125)

, x(cid:124)(cid:123)(cid:122)(cid:125)∈RD

(cid:124)

(cid:123)(cid:122)

(cid:125)

, 0, 0, . . . , 0
D(K−k) zeros

(cid:69) ∈ RDK

(17.2)

In this representation, w effectively encodes a separate weight for
every feature/label pair.

How are we going to learn w? We will start with w = 0 and then

process each input one at a time. Suppose we get an input x with
gold standard label y. We will use the current scoring function to
predict a label. In particular, we will predict the label ˆy that maxi-
mizes the score:

ˆy = argmax
ˆy∈[1,K]
= argmax
ˆy∈[1,K]

s(x, ˆy)
w · φ(x, ˆy)

(17.3)

(17.4)

If this predicted output is correct (i.e., ˆy = y), then, per the normal
perceptron, we will do nothing. Suppose that ˆy (cid:54)= y. This means that
the score of ˆy is greater than the score of y, so we want to update w
so that the score of ˆy is decreased and the score of y is increased. We
do this by:

w ← w + φ(x, y) − φ(x, ˆy)

(17.5)

To make sure this is doing what we expect, let’s consider what would
happen if we computed scores under the updated value of w. To make
the notation clear, let’s say w(old) are the weights before update, and

structured prediction 197

Algorithm 39 MulticlassPerceptronTrain(D, MaxIter)
1: w ← 0
2: for iter = 1 . . . MaxIter do
3:

for all (x,y) ∈ D do

// initialize weights

// compute prediction

// update weights

// return learned weights

ˆy ← argmaxk w · φ(x, k)
if ˆy (cid:54)= y then

w ← w + φ(x, y) − φ(x, ˆy)

4:

5:

6:

7:

end if
end for

8:
9: end for
10: return w

w(new) are the weights after update. Then:

(cid:16)
w(new) · φ(x, y)
=
(cid:123)(cid:122)
(cid:124)
(cid:125)
= w(old) · φ(x, y)

w(old) + φ(x, y) − φ(x, ˆy)
(cid:123)(cid:122)

(cid:17) · φ(x, y)
(cid:124)
(cid:125)
(cid:124)
(cid:125)
+ φ(x, y) · φ(x, y)
− φ(x, ˆy) · φ(x, y)

(cid:123)(cid:122)

=0

old prediction

≥0

(17.6)
(17.7)
(17.8)

Here, the ﬁrst term is the old prediction. The second term is of the
form a · a which is non-negative (and, unless φ(x, y) is the zero vec-
tor, positive). The third term is the dot product between φ for two
different labels, which by deﬁnition of φ is zero (see Eq (17.2)).

This gives rise to the updated multiclass perceptron speciﬁed in
Algorithm 17.1. As with the normal perceptron, the generalization
of the multiclass perceptron increases dramatically if you do weight
averaging.

An important note is that MulticlassPerceptronTrain is actually

more powerful than suggested so far. For instance, suppose that you
have three categories, but believe that two of them are tightly related,
while the third is very different. For instance, the categories might
be {music, movies, oncology}. You can encode this relatedness by
deﬁning a feature expansion φ that reﬂects this:

φ(x, music) = (cid:104)x, 0, 0, x(cid:105)
φ(x, movies) = (cid:104)0, x, 0, x(cid:105)
φ(x, oncology) = (cid:104)0, 0, x, 0(cid:105)

(17.9)
(17.10)
(17.11)

This encoding is identical to the normal encoding in the ﬁrst three
positions, but includes an extra copy of the features at the end,
shared between music and movies. By doing so, if the perceptron
wants to learn something common to music and movies, it can use
this ﬁnal shared position.

?

Verify the score of ˆy, w(new) · φ(x, ˆy),
decreases after an update, as we
would want.

?

Suppose you have a hierarchy
of classes arranged in a tree.
How could you use that to
construct a feature representa-
tion. You can think of the mu-
sic/movies/oncology example as
a binary tree: the left branch of the
root splits into music and movies;
the right branch of the root is just
oncology.

198 a course in machine learning

17.2 Structured Perceptron

Let us now consider the sequence labeling task. In sequence labeling,
the outputs are themselves variable-length vectors. An input/output
pair (which must have the same length) might look like:

x = “ monsters eat tasty bunnies “
y =

noun verb adj

noun

(17.12)
(17.13)

To set terminology, we will refer to the entire sequence y as the “out-
put” and a single label within y as a “label”. As before, our goal is to
learn a scoring function that scores the true output sequence y higher
than any imposter output sequence.

As before, despite the fact that y is now a vector, we can still de-

ﬁne feature functions over the entire input/output pair. For instance,
we might want to count the number of times “monsters” has been
tagged as “noun” in a given output. Or the number of times “verb”
is followed by “noun” in an output. Both of these are features that
are likely indicative of a correct output. We might also count the num-
ber of times “tasty” has been tagged as a verb (probably a negative
feature) and the number of times two verbs are adjacent (again, prob-
ably a negative feature).

More generally, a very standard set of features would be:

• the number of times word w has been labeled with tag l, for all

words w and all syntactic tags l

• the number of times tag l is adjacent to tag l(cid:48) in the output, for all

tags l and l(cid:48)

The ﬁrst set of features are often called unary features, because they
talk only about the relationship between the input (sentence) and a
single (unit) label in the output sequence. The second set of features
are often called Markov features, because they talk about adjacent la-
bels in the output sequence, which is reminiscent of Markov models
which only have short term memory.

Note that for a given input x of length L (in the example, L =

4), the number of possible outputs is KL, where K is the number of
syntactic tags. This means that the number of possible outputs grows
exponentially in the length of the input. In general, we write Y (x) to
mean “the set of all possible structured outputs for the input x”. We
have just seen that |Y (x)| = Klen(x).

Despite the fact that the inputs and outputs have variable length,
the size of the feature representation is constant. If there are V words
in your vocabulary and K labels for a given word, the the number of
unary features is VK and the number of Markov features is K2, so

structured prediction 199

Algorithm 40 StructuredPerceptronTrain(D, MaxIter)
1: w ← 0
2: for iter = 1 . . . MaxIter do
3:

for all (x,y) ∈ D do

// initialize weights

// compute prediction

// update weights

// return learned weights

ˆy ← argmax ˆy∈Y (x) w · φ(x, ˆy)
if ˆy (cid:54)= y then
w ← w + φ(x, y) − φ(x, ˆy)

4:

5:

6:

7:

end if
end for

8:
9: end for
10: return w

the total number of features is K(V + K). Of course, more complex
feature representations are possible and, in general, are a good idea.
For example, it is often useful to have unary features of neighboring
words like “the number of times the word immediately preceding a
verb was ’monsters’.”

Now that we have a ﬁxed size feature representation, we can de-
velop a perceptron-style algorithm for sequence labeling. The core
idea is the same as before. We will maintain a single weight vector w.
We will make predictions by choosing the (entire) output sequence
ˆy that maximizes a score given by w · φ(x, ˆy). And if this output se-
quence is incorrect, we will adjust the weights word the correct output
sequence y and away from the incorrect output sequence ˆy. This is
summarized in Algorithm 17.2

You may have noticed that Algorithm 17.2 for the structured per-
ceptron is identical to Algorithm 17.1, aside from the fact that in the
multiclass perceptron the argmax is over the K possible classes, while
in the structured perceptron, the argmax is over the KL possible out-
put sequences!

The only difﬁculty in this algorithm is in line 4:
ˆy ← argmax
ˆy∈Y (x)

w · φ(x, ˆy)

(17.14)

In principle, this requires you to search over KL possible output se-
quences ˆy to ﬁnd the one that maximizes the dot product. Except for
very small K or very small L, this is computationally infeasible. Be-
cause of its difﬁculty, this is often refered to as the argmax problem
in structured prediction. Below, we consider how to solve the argmax
problem for sequences.

17.3 Argmax for Sequences

We now face an algorithmic question, not a machine learning ques-
tion: how to compute the argmax in Eq 17.14 efﬁciently. In general,

200 a course in machine learning

this is not possible. However, under somewhat restrictive assump-
tions about the form of our features φ, we can solve this problem efﬁ-
ciently, by casting it as the problem of computing a maximum weight
path through a speciﬁcally constructed lattice. This is a variant of the
Viterbi algorithm for hidden Markov models, a classic example of dy-
namic programming. (Later, in Section 17.6, we will consider argmax
for more general problems.)

The key observation for sequences is that—so long as we restrict

our attention to unary features and Markov features—the feature
function φ decomposes over the input. This is easiest to see with
an example. Consider the input/output sequence from before: x =
“monsters eat tasty bunnies” and y = [noun verb adj noun]. If we
want to compute the number of times “bunnies” is tagged as “noun”
in this pair, we can do this by:
1. count the number of times “bunnies” is tagged as “noun” in the

ﬁrst three words of the sentence

2. add to that the number of times “bunnies” is tagged as “noun” in

the ﬁnal word

We can do a similar exercise for Markov features, like the number of
times “adj” is followed by “noun”.

However, we don’t actually need these counts. All we need for
computing the argmax sequence is the dot product between the
weights w and these counts. In particular, we can compute w · φ(x, y)
as the dot product on all-but-the-last word plus the dot product on
the last word: w · φ1:3(x, y) + w · φ4(x, y). Here, φ1:3 means “fea-
tures for everything up to and including position 3” and φ4 means
“features for position 4.”

More generally, we can write φ(x, y) = ∑L

l=1 φl(x, y), where

φl(x, y) only includes features about position l.1 In particular, we’re
taking advantage of the associative law for addition:

w · φ(x, y) = w · L∑

l=1

φl(x, y)

decomposition of structure

(17.15)

=

L∑

l=1

w · φl(x, y)

associative law

(17.16)

What this means is that we can build a graph like that in Figure ??,
with one verticle slice per time step (l 1 . . . L).2 Each edge in this
graph will receive a weight, constructed in such a way that if you
take a complete path through the lattice, and add up all the weights,
this will correspond exactly to w · φ(x, y).
To complete the construction, let φl(x,· · · ◦ y ◦ y(cid:48)) denote the unary

features at position l together with the Markov features that end at

1 In the case of Markov features, we
think of them as pairs that end at
position l, so “verb adj” would be the
active feature for φ3.

2 A graph of this sort is called a trel-
lis, and sometimes a lattice in the
literature.

structured prediction 201

Figure 17.1: A picture of a trellis se-
quence labeling. At each time step l
the corresponding word can have any
of the three possible labels. Any path
through this trellis corresponds to a
unique labeling of this sentence. The
gold standard path is drawn with bold
red arrows. The highlighted edge cor-
responds to the edge between l = 2
and l = 3 for verb/adj as described
in the text. That edge has weight
w · φ3(x,· · · ◦ verb ◦ adj).

position l. These features depend only on x, y and y(cid:48), and not any of
the previous parts of the output.

For example, in the running example “monsters/noun eat/verb

tasty/adj bunnies/noun”, consider the edge between l = 2 and
l = 3 going from “verb” to “adj”. (Note: this is a “correct” edge, in
the sense that it belongs to the ground truth output.) The features
associated with this edge will be unary features about “tasty/adj”
as well as Markov features about “verb/adj”. The weight of this edge
will be exactly the total score (according to w) of those features.

Formally, consider an edge in the trellis that goes from time l −
1 to l, and transitions from y to y(cid:48). Set the weight of this edge to
exactly w · φl(x,· · · ◦ y ◦ y(cid:48)). By doing so, we guarantee that the
sum of weights along any path through this lattice is exactly equal
to the score of that path. Once we have constructed the graph as
such, we can run any max-weight path algorithm to compute the
highest scoring output. For trellises, this can be computed by the
Viterbi algorithm, or by applying any of a number of path ﬁnding
algorithms for more general graphs. A complete derivation of the
dynamic program in this case is given in Section 17.7 for those who
want to implement it directly.

The main beneﬁt of this construction is that it is guaranteed to
exactly compute the argmax output for sequences required in the
structured perceptron algorithm, efﬁciently. In particular, it’s run-
time is O(LK2), which is an exponential improvement on the naive
O(KL) runtime if one were to enumerate every possible output se-
quence. The algorithm can be naturally extended to handle “higher
order” Markov assumptions, where features depend on triples or
quadruples of the output. The trellis becomes larger, but the algo-
rithm remains essentially the same. In order to handle a length M
Markov features, the resulting algorithm will take O(LKM) time. In
practice, it’s rare that M > 3 is necessary or useful.

tastyNVAbunniesNVAeatNVAmonstersNVA202 a course in machine learning

17.4 Structured Support Vector Machines

In Section 7.7 we saw the support vector machine as a very useful
general framework for binary classiﬁcation. In this section, we will
develop a related framework for structured support vector machines.
The two main advantages of structured SVMs over the structured
perceptron are (1) it is regularized (though averaging in structured
perceptron achieves a similar effect) and (2) we can incorporate more
complex loss functions.

In particular, one suboptimal thing about the structured percep-
tron is that all errors are consider equally bad. For structured prob-
lems, we often have much more nuanced and elaborate loss functions
that we want to optimize. Even for sequence labeling, it is typically
far worse to label every word incorrectly than to just label one word
incorrectly. It is very common to use Hamming loss as a general loss
function for structured prediction. Hamming loss simply counts:
of all the predictions you made, how many were incorrect? For se-
quence labeling, it is:
L∑

(cid:96)(Ham)(y, ˆy) =

1[yl (cid:54)= ˆyl]

(17.17)

l=1

In order to build up to structured SVMs, recall that SVMs began with
the following optimization problem:

min
w,ξ

||w||2

(cid:124) (cid:123)(cid:122) (cid:125)

+ C ∑
n

1
2
large margin

(cid:124) (cid:123)(cid:122) (cid:125)
subj. to yn (w · xn + b) ≥ 1 − ξn

small slack

ξn

ξn ≥ 0

(17.18)

(∀n)
(∀n)

After a bit of work, we were able to reformulate this in terms of a
standard loss optimization algorithm with hinge loss:

min
w

||w||2

(cid:124) (cid:123)(cid:122) (cid:125)

1
2
large margin

+ C ∑
n

(cid:124)

(cid:125)
(cid:96)(hin)(yn, w · xn + b)

(cid:123)(cid:122)

small slack

(17.19)

We can do a similar derivation in the structured case. The question
is: exactly what should the slack be measuring? Our goal is for the
score of the true output y to beat the score of any imposter output
ˆy. To incorporate loss, we will say that we want the score of the true
output to beat the score of any imposter output by at least the loss
that would be suffered if we were to predict that imposter output. An
alternative view is the ranking view: we want the true output to be
ranked above any imposter by an amount at least equal to the loss.

structured prediction 203

To keep notation simple, we will write sw(x, y) to denote the score
of the pair x, y, namely w · φ(x, y). This suggests a set of constraints
of the form:

sw(x, y) − sw(x, ˆy) ≥ (cid:96)(Ham)(y, ˆy) − ξ ˆy

(∀n,∀ ˆy ∈ Y (x))

(17.20)

The rest of the optimization problem remains the same, yielding:

1
2

min
w,ξ

||w||2 + C ∑
n

∑
ˆy∈Y xn
subj. to sw(x, y) − sw(x, ˆy)

ξn, ˆy

(17.21)

ξn, ˆy ≥ 0

≥ (cid:96)(Ham)(yn, ˆy) − ξn, ˆy

(∀n,∀ ˆy ∈ Y (xn))
(∀n,∀ ˆy ∈ Y (xn))
This optimization problem asks for a large margin and small slack,
where there is a slack very for every training example and every
possible incorrect output associated with that training example. In
general, this is way too many slack variables and way too many con-
straints!
There is a very useful, general trick we can apply. If you focus on
the ﬁrst constraint, it roughly says (letting s() denote score): s(y) ≥

(cid:2)s( ˆy) + (cid:96)(y, ˆy)(cid:3) for all ˆy, modulo slack. We’ll refer to the thing in

(cid:2)s( ˆy) + (cid:96)(y, ˆy)(cid:3), modulo slack. Expanding out the deﬁnition

brackets as the “loss-augmented score.” But if we want to guarantee
that the score of the true y beats the loss-augmented score of all ˆy, it’s
enough to ensure that it beats the loss-augmented score of the most
confusing imposter. Namely, it is sufﬁcient to require that s(y) ≥
max ˆy
of s() and adding slack back in, we can replace the exponentially
large number of constraints in Eq (17.21) with the simpler set of
constraints:

(cid:105) − ξn

(∀n)

sw(xn, yn) ≥ max
ˆy∈Y (xn)

sw(xn, ˆy) + (cid:96)(Ham)(yn, ˆy)

We can now apply the same trick as before to remove ξn from the
analysis. In particular, because ξn is constrained to be ≥ 0 and be-
cause we are trying to minimize it’s sum, we can ﬁgure out that out
(cid:41)
the optimum, it will be the case that:

(cid:40)

(cid:105) − sw(xn, yn)

sw(xn, ˆy) + (cid:96)(Ham)(yn, ˆy)

(cid:104)

(cid:104)

ξn = max

0, max
ˆy∈Y (xn)

= (cid:96)(s-h)(yn, xn, w)

(17.22)
(17.23)

This value is referred to as the structured hinge loss, which we have
denoted as (cid:96)(s-h)(yn, xn, w). This is because, although it is more com-
plex, it bears a striking resemlance to the hinge loss from Chapter 7.

204 a course in machine learning

In particular, if the score of the true output beats the score of every
the best imposter by at least its loss, then ξn will be zero. On the
other hand, if some imposter (plus its loss) beats the true output, the
loss scales linearly as a function of the difference. At this point, there
is nothing special about Hamming loss, so we will replace it with
some arbitrary structured loss (cid:96).

Plugging this back into the objective function of Eq (17.21), we can
write the structured SVM as an unconstrained optimization problem,
akin to Eq (17.19), as:

min
w

1
2

||w||2 + C ∑
n

(cid:96)(s-h)(yn, xn, w)

(17.24)

This is now in a form that we can optimize using subgradient descent
(Chapter 7) or stochastic subgradient descent (Chapter 14).

In order to compute subgradients of Eq (17.24), we need to be able
to compute subgradients of the structured hinge loss. Mathematically
this is straightforward. If the structured hinge loss on an example
(x, vy) is zero, then the gradient with respect to w is also zero. If the
structured hinge loss is positive, then the gradient is:

if the loss is > 0

∇w(cid:96)(s-h)(y, x, w)
expand deﬁnition using arbitrary structured loss (cid:96)
= ∇w

w · φ(xn, ˆy) + (cid:96)(yn, ˆy)

(cid:105) − w · φ(xn, yn)

(cid:104)

(cid:41)

(17.25)

(17.26)

max
ˆy∈Y (xn)

w · φ(xn, ˆy) − w · φ(xn, yn) + (cid:96)(yn, ˆy)

deﬁne ˆyn to be the output that attains the maximum above, rearrange
= ∇w
take gradient
= φ(xn, ˆy) − φ(xn, yn)
(cid:40)

Putting this together, we get the full gradient as:

(17.27)

(17.28)

∇w(cid:96)(s-h)(yn, xn, w) =

(cid:40)
(cid:110)

(cid:111)

if (cid:96)(s-h)(yn, xn, w) = 0

0
(cid:105)
φ(xn, ˆyn) − φ(xn, yn) otherwise
w · φ(xn, ˆyn) + (cid:96)(yn, ˆyn)

(cid:104)

(17.29)

where ˆyn = argmax
ˆyn∈Y (xn)

The form of this gradient is very simple: it is equal to the features
of the worst imposter minus the features of the truth, unless the
truth beats all imposters, in which case it’s zero. When plugged into
stochastic subgradient descent, you end up with an update that looks
very much like the structured perceptron: if the current prediction
( ˆyn) is correct, there is no gradient step. But if the current prediction
is incorrect, you step w toward the truth and away from the imposter.

structured prediction 205

Algorithm 41 StochSubGradStructSVM(D, MaxIter, λ, (cid:96))
1: w ← 0
2: for iter = 1 . . . MaxIter do
3:

for all (x,y) ∈ D do

// initialize weights

ˆy ← argmax ˆy∈Y (x) w · φ(x, ˆy) + (cid:96)(y, ˆy)
if ˆy (cid:54)= y then

w ← w + φ(x, y) − φ(x, ˆy)

// loss-augmented prediction

// update weights

// shrink weights due to regularizer

// return learned weights

4:

5:

6:

7:

8:

end if
w ← w − λ

N w

end for

9:
10: end for
11: return w

We will consider how to compute the loss-augmented argmax in

the next section, but before that we summarize an algorithm for opti-
mizing structured SVMs using stochastic subgradient descent: Algo-
rithm 17.4. Of course there are other possible optimization strategies;
we are highlighting this one because it is nearly identical to the struc-
tured perceptron. The only differences are: (1) on line 4 you use loss-
augmented argmax instead of argmax; and (2) on line 8 the weights
are shrunk slightly corresponding to the (cid:96)2 regularizer on w. (Note:
we have used λ = 1/(2C) to make the connection to linear models
clearer.)

17.5 Loss-Augmented Argmax

The challenge that arises is that we now have a more complicated
argmax problem that before. In structured perceptron, we only
needed to compute ˆyn as the output that maximized its score (see
Eq 17.14). Here, we need to ﬁnd the output that maximizes it score
plus it’s loss (Eq (17.29)). This optimization problem is refered to as
loss-augmented search or loss-augmented inference.

Before solving the loss-augmented inference problem, it’s worth
thinking about why it makes sense. What is ˆyn? It’s the output that
has the highest score among all outputs, after adding the output’s
corresponding loss to that score. In other words, every incorrect
output gets an artiﬁcial boost to its score, equal to its loss. The loss is
serving to make imposters look even better than they really are, so if
the truth is to beat an imposter, it has to beat it by a lot. In fact, this
loss augmentation is essentially playing the role of a margin, where
the required margin scales according to the loss.

The algorithmic question, then, is how to compute ˆyn. In the fully
general case, this is at least as hard as the normal argmax problem, so
we cannot expect a general solution. Moreover, even in cases where
the argmax problem is easy (like for sequences), the loss-augmented

206 a course in machine learning

argmax problem can still be difﬁcult. In order to make it easier, we
need to assume that the loss decomposes of the input in a way that’s
consistent with the features. In particular, if the structured loss func-
tion is Hamming loss, this is often straightforward.

As a concrete example, let’s consider loss-augmented argmax for

sequences under Hamming loss. In comparison to the trellis problem
solved in Section 17.7, the only difference is that we want to reward
paths that go through incorrect nodes in the trellis! In particular, in
Figure 17.1, all of the edges that are not part of the gold standard
path—those that are thinner and grey—get a free “+1” added to their
weights. Since Hamming loss adds one to the score for any word
that’s predicted incorrectly, this means that every edge in the trellis
that leads to an incorrect node (i.e., one that does not match the gold
truth label) gets a “+1” added to its weight.
Again, consider an edge in the trellis that goes from time l − 1 to
l, and transitions from y to y(cid:48). In the non-loss-augmented, the weight
of this edge was exactly w · φl(x,· · · ◦ y ◦ y(cid:48)). In the loss-augmented
cases, the weight of this edge becomes:
(cid:125)
(cid:124)
(cid:124)
(cid:123)(cid:122)
(cid:125)
w · φl(x,· · · ◦ y ◦ y(cid:48))
1[y(cid:48) (cid:54)= yl]

(17.30)

(cid:123)(cid:122)

+

edge score, as before

+1 for mispredictions

Once this loss-augmented graph has been constructed, the same max-
weight path algorithm can be run to ﬁnd the loss-augmented argmax
sequence.

17.6 Argmax in General

The general argmax problem for structured perceptron is the algo-
rithmic question of whether the following can be efﬁciently com-
puted:

ˆy ← argmax
ˆy∈Y (x)

w · φ(x, ˆy)

(17.31)

We have seen that if the output space Y (x) is sequences and the
only types of features are unary features and Markov features, then
this can be computed efﬁciently. There are a small number of other
structured output spaces and feature restrictions for which efﬁcient
problem-speciﬁc algorithms exist:

• Binary trees, with context-free features: use the CKY algorithm
• 2d image segmentation, with adjacent-pixel features: use a form of

graph cuts

• Spanning trees, with edge-based features: use Kruskal’s algorithm
(or for directed spanning trees, use Chu-Liu/Edmonds algorithm)

structured prediction 207

3 I like Gurobi best, and it’s free for
academic use. It also has a really nice
Python interface.

These special cases are often very useful, and many problems can be
cast in one of these frameworks. However, it is often the case that you
need a more general solution.

One of the most generally useful solutions is to cast the argmax
problem as an integer linear program, or ILP. ILPs are a speciﬁc
type of mathematical program/optimization problem, in which the
objective function being optimized is linear and the constraints are
linear. However, unlike “normal” linear programs, in an ILP you are
allowed to have integer constraints and disallow fractional values.
The general form of an ILP is, for a ﬁxed vector a:

a · z

max

z

subj. to linear constraints on z

(17.32)

The main point is that the constraints on z are allowed to include
constraints like z3 ∈ {0, 1}, which is considered an integer constraint.
Being able to cast your argmax problem as an ILP has the advan-
tage that there are very good, efﬁciently, well-engineered ILP solvers
out there in the world.3 ILPs are not a panacea though: in the worst
case, the ILP solver will be horribly inefﬁcient. But for prototyping,
or if there are no better options, it’s a very handy technique.

Figuring out how exactly to cast your argmax problem as an ILP

can be a bit challenging. Let’s start with an example of encoding
sequence labeling with Markov features as an ILP. We ﬁrst need
to decide what the variables will be. Because we need to encode
pairwise features, we will let our variables be of the form:

zl,k(cid:48),k = 1[label l is k and label l − 1 is k(cid:48)]

(17.33)

These zs will all be binary indicator variables.
Our next task is to construct the linear objective function. To do
so, we need to assign a value to al,k(cid:48),k in such a way that a · z will be
exactly equal to w · φ(x, y(z)), where y(z) denotes the sequence that
we can read off of the variables z. With a little thought, we arrive at:

al,k(cid:48),k = w · φl(x,(cid:104). . . , k(cid:48), k(cid:105))

(17.34)

Finally, we need to construct constaints. There are a few things that
these constraints need to enforce:
1. That all the zs are binary. That’s easy: just say zl,k(cid:48),k ∈ {0, 1}, for

all l, k(cid:48), k.

2. That for a given position l, there is exactly one active z. We can do

this with an equality constraint: ∑k ∑k(cid:48) zl,k(cid:48),k = 1 for all l.

3. That the zs are internally consistent: if the label at position 5 is
supposed to be “noun” then both z5,.,. and z6,.,. need to agree on

208 a course in machine learning

this. We can do this as: ∑k(cid:48) zl,k(cid:48),k = ∑k(cid:48)(cid:48) zl+1,k,k(cid:48)(cid:48) for all l, k. Effec-
tively what this is saying is that z5,?,verb = z6,verb,? where the “?”
means “sum over all possibilities.”

This fully speciﬁes an ILP that you can relatively easily implement
(arguably more easily than the dynamic program in Algorithm 17.7)
and which will solve the argmax problem for you. Will it be efﬁcient?
In this case, probably yes. Will it be as efﬁcient as the dynamic pro-
gram? Probably not.

It takes a bit of effort and time to get used to casting optimization
problems as ILPs, and certainly not all can be, but most can and it’s a
very nice alternative.

In the case of loss-augmented search for structured SVMs (as

opposed to structured perceptron), the objective function of the ILP
will need to be modiﬁed to include terms corresponding to the loss.

17.7 Dynamic Programming for Sequences

Recall the decomposition we derived earlier:

w · φ(x, y) = w · L∑

l=1

φl(x, y)

decomposition of structure

(17.35)

=

L∑

l=1

w · φl(x, y)

associative law

(17.36)

This decomposition allows us to construct the following dynamic
program. We will compute αl,k as the score of the best possible output
preﬁx up to and including position l that labels the lth word with
label k. More formally:

αl,k = max
ˆy1:l−1

w · φ1:l(x, ˆy ◦ k)

(17.37)

Here, ˆy is a sequence of length l − 1, and ˆy ◦ k denotes the sequence
of length l obtained by adding k onto the end. The max denotes the
fact that we are seeking the best possible preﬁx up to position l − 1,
and the forcing the label for position l to be k.

Before working through the details, let’s consider an example.

Suppose that we’ve computing the αs up to l = 2, and have: α2,noun =
2, α2,verb = 9, α2,adj = −1 (recall: position l = 2 is “eat”). We want
to extend this to position 3; for example, we want to compute α3,adj.
Let’s assume there’s a single unary feature here, “tasty/adj” and
three possible Markov features of the form “?:adj”. Assume these
weights are as given to the right. 4 Now, the question for α3,adj is:
what’s the score of the best preﬁx that labels “tasty” as “adj”? We can
obtain this by taking the best preﬁx up to “eat” and then appending

4 w“tasty/adj” = 1.2
w“noun:adj” = −5
w“verb:adj” = 2.5
w“adj:adj” = 2.2

structured prediction 209

each possible label. Whichever combination is best is the winner. The
relevant computation is:

(cid:110)

α2,noun + w“tasty/adj” + w“noun:adj”
α2,verb + w“tasty/adj” + w“verb:adj”
α2,adj + w“tasty/adj” + w“adj:adj”
2 + 1.2 − 5,

(cid:111)

9 + 1.2 + 2.5, −1 + 1.2 + 2.2

α3,adj = max

= max

= max

(cid:110)
(cid:110) − 1.8,

12.7,

2.4

= 12.7

(cid:111)

(cid:111)

(17.38)

(17.39)

(17.40)

This means that (a) the score for the preﬁx ending at position 3 la-
beled as adjective is 12.7, and (b) the “winning” previous label was
“verb”. We will need to record these winning previous labels so that
we can extract the best path at the end. Let’s denote by ζl,k the label
at position l − 1 that achieves the max.

From here, we can formally compute the αs recursively. The

main observation that will be necessary is that, because we have
limited ourselves to Markov features, φl+1(x,(cid:104)y1, y2, . . . , yl, yl+1(cid:105))
depends only on the last two terms of y, and does not depend on
y1, y2, . . . , yl−1. The full recursion is derived as:

α0,k = 0 ∀k
ζ0,k = ∅ ∀k

the score for any empty sequence is zero

αl+1,k = max
ˆy1:l

w · φ1:l+1(x, ˆy ◦ k)

w ·(cid:16)
(cid:104)

separate score of preﬁx from score of position l+1

= max
ˆy1:l

φ1:l(x, ˆy) + φl+1(x, ˆy ◦ k)

distributive law over dot products

= max
ˆy1:l

w · φ1:l(x, ˆy) + w · φl+1(x, ˆy ◦ k)
(cid:104)

separate out ﬁnal label from preﬁx, call it k’

(cid:17)

(cid:105)

(17.41)
(17.42)

(17.43)

(17.44)

(17.45)

(17.46)

(17.47)

(17.48)

(cid:105)

= max
ˆy1:l−1

max
k(cid:48)

w · φ1:l(x, ˆy ◦ k(cid:48)) + w · φl+1(x, ˆy ◦ k(cid:48) ◦ k)

swap order of maxes, and last term doesn’t depend on preﬁx

(cid:105)
+ w · φl+1(x,(cid:104). . . , k(cid:48), k(cid:105))

(cid:105)

(cid:20)(cid:104)

(cid:104)

= max

k(cid:48)

max
ˆy1:l−1

w · φ1:l(x, ˆy ◦ k(cid:48))

apply recursive deﬁnition

= max

k(cid:48)

αl,k(cid:48) + w · φl+1(x,(cid:104). . . , k(cid:48), k(cid:105))

(cid:105)

210 a course in machine learning

Algorithm 42 ArgmaxForSequences(x, w)
1: L ← len(x)
2: αl,k ← 0,
ζk,l ← 0,
3: for l = 0 . . . L-1 do
for k = 1 . . . K do
4:

αl+1,k ← maxk(cid:48)(cid:2)αl,k(cid:48) + w · φl+1(x,(cid:104). . . , k(cid:48), k(cid:105))(cid:3)

∀ k = 1 . . . K,

∀l = 0 . . . L

5:

6:

// recursion:
// here, φl+1(. . . k(cid:48), k . . . ) is the set of features associated with
// output position l + 1 and two adjacent labels k(cid:48) and k at that position
// store backpointer

ζl+1,k ← the k’ that achieves the maximum above

// initialize variables

end for

7:
8: end for
9: y ← (cid:104)0, 0, . . . , 0(cid:105)
10: yL ← argmaxk αL,k
11: for l = L-1 . . . 1 do
12:
13: end for
14: return y

yl ← ζl,yl+1

(cid:104)

ζl+1,k = argmax

k(cid:48)

// initialize predicted output to L-many zeros
// extract highest scoring ﬁnal label

// traceback ζ based on yl+1

// return predicted output

and record a backpointer to the k’ that achieves the max

αl,k(cid:48) + w · φl+1(x,(cid:104). . . , k(cid:48), k(cid:105))

(17.49)

(cid:105)

At the end, we can take maxk αL,k as the score of the best output
sequence. To extract the ﬁnal sequence, we know that the best label
for the last word is argmax αL,k. Let’s call this ˆyL Once we know that,
the best previous label is ζL−1, ˆyL. We can then follow a path through ζ
back to the beginning. Putting this all together gives Algorithm 17.7.
The main beneﬁt of Algorithm 17.7 is that it is guaranteed to ex-

actly compute the argmax output for sequences required in the struc-
tured perceptron algorithm, efﬁciently. In particular, it’s runtime is
O(LK2), which is an exponential improvement on the naive O(KL)
runtime if one were to enumerate every possible output sequence.
The algorithm can be naturally extended to handle “higher order”
Markov assumptions, where features depend on triples or quadru-
ples of the output. The memoization becomes notationally cumber-
some, but the algorithm remains essentially the same. In order to
handle a length M Markov features, the resulting algorithm will take
O(LKM) time. In practice, it’s rare that M > 3 is necessary or useful.

In the case of loss-augmented search for structured SVMs (as
opposed to structured perceptron), we need to include the scores
coming from the loss augmentation in the dynamic program. The
only thing that changes between the standard argmax solution (Al-
gorithm 17.7, and derivation in Eq (17.48)) is that the any time an
incorrect label is used, the (loss-augmented) score increases by one.
Recall that in the non-loss-augmented case, we have the α recursion

structured prediction 211

as:

αl+1,k = max
ˆy1:l
= max

k(cid:48)

(cid:104)
w · φ1:l+1(x, ˆy ◦ k)
αl,k(cid:48) + w · φl+1(x,(cid:104). . . , k(cid:48), k(cid:105))

(cid:105)

(17.50)

(17.51)

If we deﬁne ˜α to be the loss-augmented score, the corresponding
recursion is (differences highlighted in blue):

˜αl+1,k = max
ˆy1:l
= max

k(cid:48)

(cid:104)
w · φ1:l+1(x, ˆy ◦ k)+(cid:96)(Ham)
˜αl,k(cid:48) + w · φl+1(x,(cid:104). . . , k(cid:48), k(cid:105))

(cid:105)
1:l+1 (y, ˆy ◦ k)

+1[k (cid:54)= yl+1]

(17.52)

(17.53)

In other words, when computing ˜α in the loss-augmented case,
whenever the output prediction is forced to pass through an incorrect
label, the score for that cell in the dynamic program gets increased
by one. The resulting algorithm is identical to Algorithm 17.7, except
that Eq (17.53) is used for computing αs.

17.8 Further Reading

TODO

18 | IMITATION LEARNING

Learning Objectives:
• Be able to formulate imitation

learning problems.

• Understand the failure cases of

simple classiﬁcation approaches to
imitation learning.

• Implement solutions to those prob-

lems based on either classiﬁcation or
dataset aggregation.

• Relate structured prediction and

imitation learning.

Dependencies:

Programming is a skill best acquired by practice and example
rather than from books.

– Alan Turing

So far, we have largely considered machine learning
problems in which the goal of the learning algorithm is to make
a single prediction. In many real world problems, however, an algo-
rithm must make a sequence of decisions, with the world possibly
changing during that sequence. Such problems are often called se-
quential decision making problems. A straightforward example—
which will be the running example for this chapter—is that of self-
driving cars. We want to train a machine learning algorithm to drive
a car. But driving a car is not a single prediction: it’s a sequence of
predictions over time. And as the machine is driving the car, the
world around it is changing, often based on its own behavior. This
creates complicated feedback loops, and one of the major challenges
we will face is how to deal with these feedback loops.

To make this discussion more concrete, let’s consider the case of a
self-driving car. And let’s consider a very simplistic car, in which the
only decision that has to be made is how to steer, and that’s between
one of three options: {left, right, none}. In the imitation learning
setting, we assume that we have access to an expert or oracle that al-
ready knows how to drive. We want to watch the expert driving, and
learn to imitate their behavior. Hence: imitation learning (sometimes
called learning by demonstration or programming by example, in
the sense that programs are learned, and not implemented).

At each point in time t = 1 . . . T, the car recieves sensor informa-
tion xt (for instance, a camera photo ahead of the car, or radar read-
ings). It then has to take an action, at; in the case of the car, this is
one of the three available steering actions. The car then suffers some
loss (cid:96)t; this might be zero in the case that it’s driving well, or large in
the case that it crashes. The world then changes, moves to time step
t + 1, sensor readings xt+1 are observed, action at+1 is taken, loss (cid:96)t+1
is suffered, and the process continues.

The goal is to learn a function f that maps from sensor readings xt
to actions. Because of close connections to the ﬁeld of reinforcement
learning, this function is typically called a policy. The measure of

imitation learning 213

1 It’s completely okay for f to look
at more than just xt when making
predictions; for instance, it might want
to look at xt−1, or at−1 and at−2. As
long as it only references information
from the past, this is ﬁne. For notational
simplicity, we will assume that all of
this relevant information is summarized
in xt.

Figure 18.1: A single expert trajectory in
a self-driving car.

success of a policy is: if we were to run this policy, how much total
loss would be suffered. In particular, suppose that the trajectory
(denoted τ) of observation/action/reward triples encountered by
your policy is:

τ = x1 ,

, (cid:96)1 , x2 ,

, (cid:96)2 ,

. . . , xT ,

(cid:104)∑T

The losses (cid:96)t depend implicitly on the state of the world and the
actions of the policy. The goal of f is to minimize the expected loss
τ∼ f
E
the world, and the sequence of actions taken is according to f .1

, where the expectation is taken over all randomness in

t=1 (cid:96)t

a2(cid:124)(cid:123)(cid:122)(cid:125)

= f (x2)

aT(cid:124)(cid:123)(cid:122)(cid:125)

= f (xT )

, (cid:96)T

(18.1)

= f (x1)

a1(cid:124)(cid:123)(cid:122)(cid:125)
(cid:105)

18.1

Imitation Learning by Classiﬁcation

We will begin with a straightforward, but brittle, approach to imita-
tion learning. We assume access to a set of training trajectories taken
by an expert. For example, consider a self-driving car, like that in Fig-
ure 18.1. A single trajectory τ consists of a sequence of observations
(what is seen from the car’s sensors) and a sequence of actions (what
action did the expect take at that point in time). The idea in imitation
learning by classiﬁcation is to learn a classiﬁer that attempts to mimic
the expert’s action based on the observations at that time.

In particular, we have τ1, τ2, . . . , τN. Each of the N trajectories
comprises a sequence of T-many observation/action/loss triples,
where the action is the action taken by the expert. T, the length of
the trajectory is typically called the time horizon (or just horizon).
For instance, we may ask an expert human driver to drive N = 20
different routes, and record the observations and actions that driver
saw and took during those routes. These are our training trajectories.
We assume for simplicity that each of these trajectories is of ﬁxed
length T, though this is mostly for notational convenience.

The most straightforward thing we can do is convert this expert

data into a big multiclass classiﬁcation problem. We take our favorite
multiclass classiﬁcation algorithm, and use it to learn a mapping
from x to a. The data on which it is trained is the set of all observa-
tion/action pairs visited during any of the N trajectories. In total,
this would be NT examples. This approach is summarized in Algo-
rithm 18.1 for training and Algorithm 18.1 for prediction.

How well does this approach work?
The ﬁrst question is: how good is the expert? If we learn to mimic
an expert, but the expert is no good, we lose. In general, it also seems
unrealistic to believe this algorithm should be able to improve on
the expert. Similarly, if our multiclass classiﬁcation algorithm A
is crummy, we also lose. So part of the question “how well does

expertexpert214 a course in machine learning

1: D ←(cid:10)(x, a) : ∀n , ∀(x, a, (cid:96)) ∈ τn
Algorithm 43 SupervisedImitationTrain(A, τ1, τ2, . . . , τN)
2: return A(D)

// collect all observation/action pairs
// train multiclass classiﬁer on D

(cid:11)

Algorithm 44 SupervisedImitationTest( f )
1: for t = 1 . . . T do
2:

xt ← current observation
at ← f (xt)
take action at
(cid:96)t ← observe instantaneous loss

3:

4:

5:
6: end for
7: return ∑T

t=1 (cid:96)t

// ask policy to choose an action

// return total loss

this work” is the more basic question of: what are we even trying to
measure?

There is a nice theorem2 that gives an upper bound on the loss
suffered by the SupervisedIL algorithm (Algorithm 18.1) as a func-
tion of (a) the quality of the expert, and (b) the error rate of the
learned classiﬁer. To be clear, we need to distinguish between the
loss of the policy when run for T steps to form a full trajectory, and
the error rate of the learned classiﬁer, which is just it’s average mul-
ticlass classiﬁcation error. The theorem states, roughly, that the loss
of the learned policy is at most the loss of the expert plus T2 times the
error rate of the classiﬁer.

2 Ross et al. 2011

Theorem 18 (Loss of SupervisedIL). Suppose that one runs Algo-
rithm 18.1 using a multiclass classiﬁer that optimizes the 0-1 loss (or an
upperbound thereof). Let  be the error rate of the underlying classiﬁer
(in expectation) and assume that all instantaneous losses are in the range
[0, (cid:96)(max)]. Let f be the learned policy; then:

(cid:34)
(cid:123)(cid:122)

∑
t

(cid:96)t

E

τ∼ f

(cid:124)

(cid:35)
(cid:125)

(cid:34)
≤ Eτ∼expert
(cid:124)
(cid:123)(cid:122)

∑
t

(cid:96)t

(cid:35)
(cid:125)

+(cid:96)(max)T2

(18.2)

loss of learned policy

loss of expert

Intuitively, this bound on the loss is about a factor of T away from
what we might hope for. In particular, the multiclass classiﬁer makes
errors on an  fraction of it’s actions, measured by zero/one loss.
In the worst case, this will lead to a loss of (cid:96)(max) for a single step.
Summing all these errors over the entire trajectory would lead to
a loss on the order of (cid:96)(max)T, which is a factor T better than this
theorem provides. A natural question (addressed in the next section)
is whether this is analysis is tight. A related question (addressed in
the section after that) is whether we can do better. Before getting
there, though, it’s worth highlighting that an extra factor of T is really

imitation learning 215

bad. It can cause even very small multiclass error rates to blow up; in
particular, if  ≥ 1/T, we lose, and T can be in the hundreds or more.

18.2 Failure Analysis

The biggest single issue with the supervised learning approach to
imitation learning is that it cannot learn to recover from failures. That
is: it has only been trained based on expert trajectories. This means
that the only training data it has seen is that of an expert driver. If
it ever veers from that state distribution, it may have no idea how
to recover. As a concrete example, perhaps the expert driver never
ever gets themselves into a state where they are directly facing a
wall. Moreover, the expert driver probably tends to drive forward
more than backward. If the imperfect learner manages to make a few
errors and get stuck next to a wall, it’s likely to resort to the general
“drive forward” rule and stay there forever. This is the problem of
compounding error; and yes, it does happen in practice.

It turns out that it’s possible to construct an imitation learning

problem on which the T2 compounding error is unavoidable. Con-
sider the following somewhat artiﬁcial problem. At time t = 1 you’re
shown a picture of either a zero or a one. You have two possible ac-
tions: press a button marked “zero” or press a button marked “one.”
The “correct” thing to do at t = 1 is to press the button that corre-
sponds to the image you’ve been shown. Pressing the correct button
leads to (cid:96)1 = 0; the incorrect leads to (cid:96)1 = 1. Now, at time t = 2 you
are shown another image, again of a zero or one. The correct thing to
do in this time step is the xor of (a) the number written on the picture
you see right now, and (b) the correct answer from the previous time
step. This holds in general for t > 1.

There are two important things about this construction. The ﬁrst

is that the expert can easily get zero loss. The second is that once the
learned policy makes a single mistake, this can cause it to make all
future decisions incorrectly. (At least until it “luckily” makes another
“mistake” to get it back on track.)

Based on this construction, you can show the following theorem3.

3 Kääriäinen 2006

Theorem 19 (Lower Bound for SupervisedIL). There exist imitation
learning problems on which Algorithm 18.1 is able to achieve small classiﬁ-
cation error  ∈ [0, 1/T] under an optimal expert, but for which the test loss
is lower bounded as:

(cid:104)

1 − (1 − 2)T+1(cid:105)

(18.3)

(cid:34)
(cid:123)(cid:122)

E

τ∼ f

(cid:124)

(cid:35)
(cid:125)

∑
t

(cid:96)t

≥ T + 1

2

− 1
4

loss of learned policy

which is bounded by T2 and, for small , grows like T2.

216 a course in machine learning

Up to constants, this gives matching upper and lower bounds for
the loss of a policy learned by supervised imitation learning that is
pretty far (a factor of T) from what we might hope for.

18.3 Dataset Aggregation

Supervised imitation learning fails because once it gets “off the ex-
pert path,” things can go really badly. Ideally, we might want to train
our policy to deal with any possible situation it could encounter.
Unfortunately, this is unrealistic: we cannot hope to be able to train
on every possible conﬁguration of the world; and if we could, we
wouldn’t really need to learn anyway, we could just memorize. So
we want to train f on a subset of world conﬁgurations, but using
“conﬁgurations visited by the expert” fails because f cannot learn to
recover from its own errors. Somehow what we’d like to do is train f
to do well on the conﬁgurations that it, itself, encounters!

This is a classic chicken-and-egg problem. We want a policy f that
does well in a bunch of world conﬁgurations. What set of conﬁgura-
tions? The conﬁgurations that f encounters! A very classic approach
to solving chicken-and-egg problems is iteration. Start with some
policy f . Run f and see what conﬁgurations is visits. Train a new f
to do well there. Repeat.

This is exactly what the Dataset Aggregation algorithm (“Dagger”)

does. Continuing with the self-driving car analogy, we ﬁrst let a
human expert drive a car for a while, and learn an initial policy f0 by
running standard supervised imitation learning (Algorithm 18.1) on
the trajectories visited by the human. We then do something unusual.
We put the human expert in the car, and record their actions, but the
car behaves not according to the expert’s behavior, but according to
f0. That is, f0 is in control of the car, and the expert is trying to steer,
but the car is ignoring them4 and simply recording their actions as
training data. This is shown in Figure 18.2.

Based on trajectories generated by f0 but actions given by the

expert, we generate a new dataset that contains information about
how to recover from the errors of f0. We now will train a new policy,
f1. Because we don’t want f1 to “forget” what f0 already knows, f1
is trained on the union of the initial expert-only trajectories together
with the new trajectories generated by f0. We repeat this process a
number of times MaxIter, yielding Algorithm 18.3.

This algorithm returns the list of all policies generated during its
run. A very practical question is: which one should you use? There
are essentially two choices. The ﬁrst choice is just to use the ﬁnal
policy learned. The problem with this approach is that Dagger can
be somewhat unstable in practice, and policies do not monotonically

4 This is possibly terrifying for the
expert!

Figure 18.2: In DAgger, the trajectory
(red) is generated according to the
previously learned policy, f0, but the
gold standard actions are given by the
expert.

expertexpertff00imitation learning 217

(cid:11) // collect all pairs (same as supervised)

// train initial policy (multiclass classiﬁer) on D0

(0)

(0)
n

Algorithm 45 DaggerTrain(A, MaxIter, N, expert)
1: (cid:104)τ

n=1 ← run the expert N many times

3:
4: for i = 1 . . . MaxIter do
5:

n (cid:105)N
f0 ← A(D0)
(cid:104)τ

2: D0 ←(cid:10)(x, a) : ∀n , ∀(x, a, (cid:96)) ∈ τ
Di ←(cid:10)(x, expert(x)) : ∀n , ∀(x, a, (cid:96)) ∈ τ
fi ← A(cid:16)(cid:83)i

n (cid:105)N

n=1 ← run policy fi−1 N-many times

(cid:17)

(cid:11)

(i)

6:

j=0 Dj

7:
8: end for
9: return (cid:104) f0, f1, . . . , fMaxIter(cid:105)

(i)
n

// trajectories by fi−1
// collect data set
// observations x visited by fi−1
// but actions according to the expert
// train policy fi on union of all data so far

// return collection of all learned policies

improve. A safer alternative (as we’ll see by theory below) is to test
all of them on some held-out “development” tasks, and pick the one
that does best there. This requires a bit more computation, but is a
much better approach in general.

One major difference in requirements between Dagger (Algo-

rithm 18.3) and SupervisedIL (Algorithm 18.1) is the requirement
of interaction with the expert. In SupervisedIL, you only need access
to a bunch of trajectories taken by the expert, passively. In Dagger,
you need access to them expert themselves, so you can ask questions
like “if you saw conﬁguration x, what would you do?” This puts
much more demand on the expert.

Another question that arises is: what should N, the number of
trajectories generated in each round, be? In practice, the initial N
should probably be reasonably large, so that the initial policy f0
is pretty good. The number of trajectories generated by iteration
subsequently can be much smaller, perhaps even just one.

Intuitively, Dagger should be less sensitive to compounding error
than SupervisedIL, precisely because it gets trained on observations
that it is likely to see at test time. This is formalized in the following
theorem:

Theorem 20 (Loss of Dagger). Suppose that one runs Algorithm 18.3
using a multiclass classiﬁer that optimizes the 0-1 loss (or an upperbound
thereof). Let  be the error rate of the underlying classiﬁer (in expectation)
and assume that all instantaneous losses are in the range [0, (cid:96)(max)]. Let f be
the learned policy; then:

(cid:18) (cid:96)(max)T log T

(cid:19)

MaxIter

(18.4)

(cid:34)
(cid:123)(cid:122)

∑
t

(cid:96)t

E

τ∼ f

(cid:124)

(cid:35)
(cid:125)

(cid:34)
≤ Eτ∼expert
(cid:123)(cid:122)
(cid:124)

∑
t

(cid:96)t

(cid:35)
(cid:125)

loss of learned policy

loss of expert

+(cid:96)(max)T + O

Furthermore, if the loss function is strongly convex in f , and MaxIter is

218 a course in machine learning

˜O(T/), then:

(cid:34)
(cid:123)(cid:122)

∑
t

(cid:96)t

E

τ∼ f

(cid:124)

(cid:35)
(cid:125)

(cid:34)
≤ Eτ∼expert
(cid:123)(cid:122)
(cid:124)

∑
t

(cid:96)t

(cid:35)
(cid:125)

+(cid:96)(max)T + O()

(18.5)

loss of learned policy

loss of expert

Both of these results show that, assuming MaxIter is large enough,

the loss of the learned policy f (here, taken to be the best on of all
the MaxIter policies learned) grows like T, which is what we hope
for. Note that the ﬁnal term in the ﬁrst bound gets small so long as
MaxIter is at least T log T.

18.4 Expensive Algorithms as Experts

Because of the strong requirement on the expert in Dagger (i.e., that
you need to be able to query it many times during training), one of
the most substantial use cases for Dagger is to learn to (quickly) imi-
tate otherwise slow algorithms. Here are two prototypical examples:
1. Game playing. When a game (like chess or minecraft) can be run

in simulation, you can often explicitly compute a semi-optimal
expert behavior with brute-force search. But this search might be
too computationally expensive to play in real time, so you can
use it during training time, learning a fast policy that attempts
to mimic the expensive search. This learned policy can then be
applied at test time.

2. Discrete optimizers. Many discrete optimization problems can be
computationally expensive to run in real time; for instance, even
shortest path search on a large graph can be too slow for real time
use. We can compute shortest paths ofﬂine as “training data” and
then use imitation learning to try to build shortest path optimizers
that will run sufﬁciently efﬁciently in real time.

Consider the game playing example, and for concreteness, sup-
pose you are trying to learn to play solitaire (this is an easier exam-
ple because it’s a single player game). When running DaggerTrain
(Algorithm 18.3 to learn a chess-playing policy, the algorithm will
repeatedly ask for expert(x), where x is the current state of the game.
What should this function return? Ideally, it should return the/an ac-
tion a such that, if a is taken, and then the rest of the game is played
optimally, the player wins. Computing this exactly is going to be very
difﬁcult for anything except the simplest games, so we need to restort
to an approxiamtion.

imitation learning 219

Algorithm 46 DepthLimitedDFS(x, h, MaxDepth)
1: if x is a terminal state or MaxDepth ≤ 0 then

return (⊥, h(x))

3: else
4:

BestAction, BestScore ← ⊥, −∞
for all actions a from x do

// if we cannot search deeper
// return “no action” (⊥) and the current heuristic score

// keep track of best action & its score

(_, score) ← DepthLimitedDFS(x ◦ a, h, MaxDepth − 1)

// get score
// for action a, depth reduced by one by appending a to x

if score > BestScore then

BestAction, BestScore ← a, score

// update tracked best action & score

2:

5:

6:

7:

8:

9:

end if
end for

10:
11: end if
12: return (BestAction, BestScore)

// return best found action and its score

A common strategy is to run a depth-limited depth ﬁrst search,

starting at state x, and terminating after at most three of four moves
(see Figure 18.3). This will generate a search tree. Unless you are
very near the end of the game, none of the leaves of this tree will
correspond to the end of the game. So you’ll need some heuristic, h,
for evaluating states that are non-terminals. You can propagate this
heuristic score up to the root, and choose the action that looks best
with this depth four search. This is not necessarily going to be the
optimal action, and there’s a speed/accuracy trade-off for searching
deeper, but this is typically effective. This approach summarized in
Algorithm 18.4.

18.5 Structured Prediction via Imitation Learning

A ﬁnal case where an expert can often be computed algorithmically
arises when one solves structured prediction (see Chapter 17) via
imitation learning. It is clearest how this can work in the case of
sequence labeling. Recall there that predicted outputs should be
sequences of labels. The running example from the earlier chapter
was:

Figure 18.3: imit:dldfs: Depth limited
depth-ﬁrst search

x = “ monsters eat tasty bunnies “
y =

noun verb adj

noun

(18.6)
(18.7)

One can easily cast the prediction of y as a sequential decision mak-
ing problem, by treating the production of y in a left-to-right manner.
In this case, we have a time horizon T = 4. We want to learn a policy
f that ﬁrst predicts “noun” then “verb” then “adj” then “noun” on
this input.

220 a course in machine learning

Let’s suppose that the input to f consists of features extracted both
from the input (x) and the current predicted output preﬁx ˆy, denoted
φ(x, ˆy). For instance, φ(x, ˆy) might represent a similar set of features
to those use in Chapter 17. It is perhaps easiest to think of f as just
a classiﬁer: given some features of the input sentence x (“monsters
eat tasty bunnies”), and some features about previous predictions in
the output preﬁx (so far, produced “noun verb”), the goal of f is to
predict the tag for the next word (“tasty”) in this context.

An important question is: what is the “expert” in this case? In-
tuitively, the expert should provide the correct next label, but what
does this mean? That depends on the loss function being optimized.
Under Hamming loss (sum zero/one loss over each individual pre-
diction), the expert is straightforward. When the expert is asked to
produce an action for the third word, the expert’s response is always
“adj” (or whatever happens to be the correct label for the third word
in the sentence it is currently training on).

More generally, the expert gets to look at x, y and a preﬁx ˆy of the
output. Note, importantly, that the preﬁx might be wrong! In particular,
after the ﬁrst iteration of Dagger, the preﬁx will be predicted by
the learned policy, which may make mistakes! The expert also has
some structured loss function (cid:96) that it is trying to minimize. Like
in the previous section, the expert’s goal is to choose the action that
minimizes the long-term loss according to (cid:96) on this example.

To be more formal, we need a bit of notation. Let best((cid:96), y, ˆy)

denote the loss (according to (cid:96) and the ground truth y) of the best
reachable output starting at ˆy. For instance, if y is “noun verb adj
noun” and ˆy is “noun noun”, and the loss is Hamming loss, then the
best achievable output (predicting left-to-right) is “noun noun adj
noun” which has a loss of 1. Thus, best for this situation is 1.

Given that notion of best, the expert is easy to deﬁne:

expert((cid:96), y, ˆy) = argmin

a

best((cid:96), y, ˆy ◦ a)

(18.8)

Namely, it is the action that leads to the best possible completion
after taking that action. So in the example above, the expert action
is “adj”. For some problems and some loss functions, computing
the expert is easy. In particular, for sequence labeling under Ham-
ming loss, it’s trivial. In the case that you can compute the expert
exactly, it is often called an oracle.5 For some other problems, exactly
computing an oracle is computationally expensive or intractable. In
those cases, one can often resort to depth limited depth-ﬁrst-search
(Algorithm 18.4) to compute an approximate oracle as an expert.

To be very concrete, a typical implementation of Dagger applied
to sequence labeling would go as follows. Each structured training
example (a pair of sentence and tag-sequence) gives rise to one trajec-

5 Some literature calls it a “dynamic
oracle”, though the extra word is
unnecessary.

imitation learning 221

tory. At training time, a predict tag seqence is generated left-to-right,
starting with the empty sequence. At any given time step, you are
attempting to predict the label of the tth word in the input. You de-
ﬁne a feature vector φ(x, ˆy), which will typically consist of: (a) the tth
word, (b) left and right neighbors of the tth word, (c) the last few pre-
dictions in ˆy, and (d) anything else you can think of. In particular, the
features are not limited to Markov style features, because we’re not
longer trying to do dynamic programming. The expert label for the
tth word is just the corresponding label in the ground truth y. Given
all this, one can run Dagger (Algorithm 18.4) exactly as speciﬁed.
Moving to structured prediction problems other than sequence

labeling problems is beyond the scope of this book. The general
framework is to cast your structured prediction problem as a sequen-
tial decision making problem. Once you’ve done that, you need to
decide on features (this is the easy part) and an expert (this is often
the harder part). However, once you’ve done so, there are generic
libraries for “compiling” your speciﬁcation down to code.

18.6 Further Reading

TODO further reading

CODE AND DATASETS

Rating

+2
+2
+2
+2
+2
+1
+1
+1
0
0
0
0
-1
-1
-1
-1
-2
-2
-2
-2

Easy? AI? Sys? Thy? Morning?

y
y
n
n
n
y
y
n
n
y
n
y
y
n
n
y
n
n
y
y

y
y
y
n
y
y
y
y
n
n
y
y
y
n
n
n
n
y
n
n

n
n
n
n
y
n
n
n
n
n
n
y
y
y
y
y
y
y
y
y

y
y
n
y
n
n
y
y
n
y
y
y
n
y
n
n
y
n
n
n

n
n
n
n
y
n
n
n
y
y
n
y
y
n
y
y
n
y
n
y

Table 1: Course rating data set

BIBLIOGRAPHY

Shai Ben-David, John Blitzer, Koby Crammer, and Fernando Pereira.
Analysis of representations for domain adaptation. Advances in
neural information processing systems, 19:137, 2007.

Steffen Bickel, Michael Bruckner, and Tobias Scheffer. Discriminative
learning for differing training and test distributions. In Proceedings
of the International Conference on Machine Learning (ICML), 2007.

Sergey Brin. Near neighbor search in large metric spaces. In Confer-
ence on Very Large Databases (VLDB), 1995.

Hal Daumé III. Frustratingly easy domain adaptation. In Conference
of the Association for Computational Linguistics (ACL), Prague, Czech
Republic, 2007.

Sorelle A Friedler, Carlos Scheidegger, and Suresh Venkatasub-
ramanian. On the (im)possibility of fairness. arXiv preprint
arXiv:1609.07236, 2016.

Moritz Hardt, Eric Price, and Nathan Srebro. Equality of oppor-
tunity in supervised learning. In Advances in Neural Information
Processing Systems, pages 3315–3323, 2016.

Matti Kääriäinen. Lower bounds for reductions. Talk at the Atomic
Learning Workshop (TTI-C), March 2006.
Tom M. Mitchell. Machine Learning. McGraw Hill, 1997.
J. Ross Quinlan. Induction of decision trees. Machine learning, 1(1):
81–106, 1986.

Frank Rosenblatt. The perceptron: A probabilistic model for infor-
mation storage and organization in the brain. Psychological Review,
65:386–408, 1958. Reprinted in Neurocomputing (MIT Press, 1998).

Stéphane Ross, Geoff J. Gordon, and J. Andrew Bagnell. A reduction
of imitation learning and structured prediction to no-regret online
learning. In Proceedings of the Workshop on Artiﬁcial Intelligence and
Statistics (AIStats), 2011.

224 a course in machine learning

INDEX

K-nearest neighbors, 58
dA-distance, 113
p-norms, 92
0/1 loss, 88
80% rule, 111

absolute loss, 14
activation function, 130
activations, 41
AdaBoost, 166
adaptation, 105
algorithm, 87
all pairs, 80
all versus all, 80
approximation error, 71
architecture selection, 139
area under the curve, 64, 84
argmax problem, 199
AUC, 64, 83, 84
AVA, 80
averaged perceptron, 52

back-propagation, 134, 137
bag of words, 56
bagging, 165
base learner, 164
batch, 173
Bayes error rate, 20
Bayes optimal classiﬁer, 19
Bayes optimal error rate, 20
Bayes rule, 117
Bernouilli distribution, 121
bias, 42
bias/variance trade-off, 72
binary features, 30
bipartite ranking problems, 83
boosting, 155, 164
bootstrap resampling, 165
bootstrapping, 67, 69

categorical features, 30
chain rule, 117, 120
chord, 90
circuit complexity, 138
clustering, 35, 178
clustering quality, 178
complexity, 34
compounding error, 215
concave, 90
concavity, 193
concept, 157
conﬁdence intervals, 68
constrained optimization problem,

100

contour, 92
convergence rate, 95
convex, 87, 89
covariate shift, 105
cross validation, 65, 68
cubic feature map, 144
curvature, 95

data covariance matrix, 184
data generating distribution, 15
decision boundary, 34
decision stump, 168
decision tree, 8, 10
decision trees, 57
density estimation, 107
development data, 26
dimensionality reduction, 178
discrepancy, 113
discrete distribution, 121
disparate impact, 111
distance, 31
domain adaptation, 105
dominates, 63
dot product, 45
dual problem, 151

dual variables, 151

early stopping, 53, 132
embedding, 178
ensemble, 164
error driven, 43
error rate, 88
estimation error, 71
Euclidean distance, 31
evidence, 127
example normalization, 59, 60
examples, 9
expectation maximization, 186, 189
expected loss, 16
expert, 212
exponential loss, 90, 169

feasible region, 101
feature augmentation, 109
feature combinations, 54
feature mapping, 54
feature normalization, 59
feature scale, 33
feature space, 31
feature values, 11, 29
feature vector, 29, 31
features, 11, 29
forward-propagation, 137
fractional assignments, 191
furthest-ﬁrst heuristic, 180

Gaussian distribution, 121
Gaussian kernel, 147
Gaussian Mixture Models, 191
generalize, 9, 17
generative story, 123
geometric view, 29
global minimum, 94
GMM, 191

226 a course in machine learning

gradient, 93
gradient ascent, 93
gradient descent, 93

Hamming loss, 202
hard-margin SVM, 101
hash kernel, 177
held-out data, 26
hidden units, 129
hidden variables, 186
hinge loss, 90, 203
histogram, 12
horizon, 213
hyperbolic tangent, 130
hypercube, 38
hyperparameter, 26, 44, 89
hyperplane, 41
hyperspheres, 38
hypothesis, 71, 157
hypothesis class, 71, 160
hypothesis testing, 67

i.i.d. assumption, 117
identically distributed, 24
ILP, 195, 207
imbalanced data, 73
imitation learning, 212
importance sampling, 106
importance weight, 74
independent, 24
independently, 117
independently and identically dis-

tributed, 117

indicator function, 88
induce, 16
induced distribution, 76
induction, 9
inductive bias, 20, 31, 33, 91, 121
integer linear program, 207
integer linear programming, 195
iteration, 36

jack-kniﬁng, 69
Jensen’s inequality, 193
joint, 124

KKT conditions, 152

label, 11
Lagrange multipliers, 119
Lagrange variable, 119
Lagrangian, 119
lattice, 200
layer-wise, 139
learning by demonstration, 212
leave-one-out cross validation, 65
level-set, 92
license, 2
likelihood, 127
linear classiﬁer, 169
linear classiﬁers, 169
linear decision boundary, 41
linear regression, 98
linearly separable, 48
link function, 130
log likelihood, 118
log posterior, 127
log probability, 118
log-likelihood ratio, 122
logarithmic transformation, 61
logistic loss, 90
logistic regression, 126
LOO cross validation, 65
loss function, 14
loss-augmented inference, 205
loss-augmented search, 205

margin, 49, 100
margin of a data set, 49
marginal likelihood, 127
marginalization, 117
Markov features, 198
maximum a posteriori, 127
maximum depth, 26
maximum likelihood estimation, 118
mean, 59
Mercer’s condition, 146
model, 87
modeling, 25
multi-layer network, 129

K-nearest neighbors, 32
Karush-Kuhn-Tucker conditions, 152
kernel, 141, 145
kernel trick, 146
kernels, 54

naive Bayes assumption, 120
nearest neighbor, 29, 31
neural network, 169
neural networks, 54, 129
neurons, 41
noise, 21

non-convex, 135
non-linear, 129
Normal distribution, 121
normalize, 46, 59
null hypothesis, 67

objective function, 88
one versus all, 78
one versus rest, 78
online, 42
optimization problem, 88
oracle, 212, 220
oracle experiment, 28
output unit, 129
OVA, 78
overﬁtting, 23
oversample, 76

p-value, 67
PAC, 156, 166
paired t-test, 67
parametric test, 67
parity, 21
parity function, 138
patch representation, 56
PCA, 184
perceptron, 41, 42, 58
perpendicular, 45
pixel representation, 55
policy, 212
polynomial kernels, 146
positive semi-deﬁnite, 146
posterior, 127
precision, 62
precision/recall curves, 63
predict, 9
preference function, 82
primal variables, 151
principle components analysis, 184
prior, 127
probabilistic modeling, 116
Probably Approximately Correct, 156
programming by example, 212
projected gradient, 151
projection, 46
psd, 146

radial basis function, 139
random forests, 169
random variable, 117
RBF kernel, 147

RBF network, 139
recall, 62
receiver operating characteristic, 64
reconstruction error, 184
reductions, 76
redundant features, 56
regularized objective, 89
regularizer, 88, 91
reinforcement learning, 212
representer theorem, 143, 145
ROC curve, 64

sample complexity, 157, 158, 160
sample mean, 59
sample selection bias, 105
sample variance, 59
semi-supervised adaptation, 106
sensitivity, 64
separating hyperplane, 87
sequential decision making, 212
SGD, 173
shallow decision tree, 21, 168
shape representation, 56
sigmoid, 130
sigmoid function, 126
sigmoid network, 139
sign, 130
single-layer network, 129
singular, 98
slack, 148
slack parameters, 101
smoothed analysis, 180
soft assignments, 190
soft-margin SVM, 101

span, 143
sparse, 92
speciﬁcity, 64
squared loss, 14, 90
statistical inference, 116
statistically signiﬁcant, 67
steepest ascent, 93
stochastic gradient descent, 173
stochastic optimization, 172
strong law of large numbers, 24
strong learner, 166
strong learning algorithm, 166
strongly convex, 95
structural risk minimization, 87
structured hinge loss, 203
structured prediction, 195
sub-sampling, 75
subderivative, 96
subgradient, 96
subgradient descent, 97
sum-to-one, 117
support vector machine, 100
support vectors, 153
surrogate loss, 90
symmetric modes, 135

t-test, 67
test data, 25
test error, 25
test set, 9
text categorization, 56
the curse of dimensionality, 37
threshold, 42
Tikhonov regularization, 87

index

227

time horizon, 213
total variation distance, 113
train/test mismatch, 105
training data, 9, 16, 24
training error, 16
trajectory, 213
trellis, 200
trucated gradients, 175
two-layer network, 129

unary features, 198
unbiased, 47
underﬁtting, 23
unit hypercube, 39
unit vector, 46
unsupervised adaptation, 106
unsupervised learning, 35

validation data, 26
Vapnik-Chernovenkis dimension, 162
variance, 59, 165
variational distance, 113
VC dimension, 162
vector, 31
visualize, 178
vote, 32
voted perceptron, 52
voting, 52

weak learner, 166
weak learning algorithm, 166
weights, 41

zero/one loss, 14

